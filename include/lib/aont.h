#ifndef AONT_H
#define AONT_H

#include <linux/random.h>
#include <linux/types.h>
#include "cauchy_rs.h"
#include <linux/crypto.h>
#include <linux/scatterlist.h>
#include <crypto/skcipher.h>
#include <crypto/hash.h>

#define CANARY_SIZE 16
#define KEY_SIZE 32

static inline size_t get_share_size(size_t data_length, size_t data_blocks){
    return (data_length + CANARY_SIZE + KEY_SIZE) / data_blocks;
}

int encrypt_payload(uint8_t *data, const size_t datasize, uint8_t *key, size_t keylength, int enc);

/**
 * Encode data contained in the data buffer into data_blocks+parity_blocks number of shares using AONT-RS
 * The shares array should be allocated before calling this function. The length of each share can be determined
 * using the function get_share_size()
 *
 * data: the input data to be encoded
 * data_length: length of the input data
 * shares: 2 dimensional array of shares generated by the function
 * data_blocks: number of data shares (equal to the reconstruction threshold)
 * parity_blocks: number of redundant shares
 * nonce: array of two 64 bit integers makes up a 128 bit nonce
 */
int encode_aont_package(uint8_t *difference, const uint8_t *data, size_t data_length, uint8_t **shares, size_t data_blocks, size_t parity_blocks, uint64_t *nonce);

/**
 * Decodes a set of shares using AONT-RS and places the reconstructed data into the data buffer
 *
 * data: output buffer for the function
 * data_length: expected length of the output buffer
 * shares: array of shares to be decoded
 * data_blocks: reconstruction threshold
 * parity_blocks: number of redundant blocks
 * nonce: array of two 64 bit integers makes up a 128 bit nonce for encryption purposes
 * erasures: an array identifying erasures (used for reed-solomon decoding)
 * num_erasures: the number of total known erasures.
 */
int decode_aont_package(uint8_t *difference, uint8_t *data, size_t data_length, uint8_t **shares, size_t data_blocks, size_t parity_blocks, uint64_t *nonce, uint8_t *erasures, uint8_t num_erasures);


#endif
