
dm_afs.ko:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <afs_cleanq>:
afs_cleanq():
/home/austen/programming/dm-afs/src/dm_afs.c:137
 * This is scheduled on the global kernel workqueue. Simply
 * removes all elements which have finished processing.
 */
static void
afs_cleanq(struct work_struct *ws)
{
       0:	e8 00 00 00 00       	callq  5 <afs_cleanq+0x5>
			1: R_X86_64_PC32	__fentry__-0x4
       5:	55                   	push   %rbp
       6:	48 89 e5             	mov    %rsp,%rbp
       9:	41 57                	push   %r15
       b:	41 56                	push   %r14
       d:	41 55                	push   %r13
       f:	41 54                	push   %r12
/home/austen/programming/dm-afs/src/dm_afs.c:144
    struct afs_engine_queue *flight_eq = NULL;
    struct afs_map_queue *node = NULL, *node_extra = NULL;
    long long state;

    context = container_of(ws, struct afs_private, clean_ws);
    flight_eq = &context->flight_eq;
      11:	4c 8d bf d0 3f fe ff 	lea    -0x1c030(%rdi),%r15
/home/austen/programming/dm-afs/src/dm_afs.c:137
{
      18:	53                   	push   %rbx
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
      19:	48 8d 9f d0 ef ff ff 	lea    -0x1030(%rdi),%rbx
afs_cleanq():
/home/austen/programming/dm-afs/src/dm_afs.c:137
      20:	49 89 fc             	mov    %rdi,%r12
      23:	48 83 ec 08          	sub    $0x8,%rsp
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
      27:	48 89 df             	mov    %rbx,%rdi
      2a:	e8 00 00 00 00       	callq  2f <afs_cleanq+0x2f>
			2b: R_X86_64_PC32	_raw_spin_lock-0x4
afs_cleanq():
/home/austen/programming/dm-afs/src/dm_afs.c:147

    spin_lock(&flight_eq->mq_lock);
    list_for_each_entry_safe (node, node_extra, &flight_eq->mq.list, list) {
      2f:	49 8b 84 24 00 e0 ff 	mov    -0x2000(%r12),%rax
      36:	ff 
      37:	4c 8b 30             	mov    (%rax),%r14
      3a:	48 8d b8 d0 5f fe ff 	lea    -0x1a030(%rax),%rdi
      41:	49 81 ee 30 a0 01 00 	sub    $0x1a030,%r14
      48:	49 39 ff             	cmp    %rdi,%r15
      4b:	74 66                	je     b3 <afs_cleanq+0xb3>
list_del():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:126
      4d:	49 bd 00 01 00 00 00 	movabs $0xdead000000000100,%r13
      54:	00 ad de 
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:127
      57:	49 bc 00 02 00 00 00 	movabs $0xdead000000000200,%r12
      5e:	00 ad de 
      61:	eb 19                	jmp    7c <afs_cleanq+0x7c>
afs_cleanq():
/home/austen/programming/dm-afs/src/dm_afs.c:147
      63:	49 8b 86 30 a0 01 00 	mov    0x1a030(%r14),%rax
      6a:	4d 39 f7             	cmp    %r14,%r15
      6d:	4c 89 f7             	mov    %r14,%rdi
      70:	48 8d 90 d0 5f fe ff 	lea    -0x1a030(%rax),%rdx
      77:	74 3a                	je     b3 <afs_cleanq+0xb3>
      79:	49 89 d6             	mov    %rdx,%r14
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188
      7c:	48 8b 87 00 90 01 00 	mov    0x19000(%rdi),%rax
afs_cleanq():
/home/austen/programming/dm-afs/src/dm_afs.c:149
        state = atomic64_read(&node->req.state);
        if (state == REQ_STATE_COMPLETED) {
      83:	48 83 f8 04          	cmp    $0x4,%rax
      87:	75 da                	jne    63 <afs_cleanq+0x63>
__list_del_entry():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:120
      89:	48 8b 97 30 a0 01 00 	mov    0x1a030(%rdi),%rdx
      90:	48 8b 87 38 a0 01 00 	mov    0x1a038(%rdi),%rax
__list_del():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:105
      97:	48 89 42 08          	mov    %rax,0x8(%rdx)
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
      9b:	48 89 10             	mov    %rdx,(%rax)
list_del():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:126
      9e:	4c 89 af 30 a0 01 00 	mov    %r13,0x1a030(%rdi)
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:127
      a5:	4c 89 a7 38 a0 01 00 	mov    %r12,0x1a038(%rdi)
afs_cleanq():
/home/austen/programming/dm-afs/src/dm_afs.c:151
            list_del(&node->list);
            kfree(node);
      ac:	e8 00 00 00 00       	callq  b1 <afs_cleanq+0xb1>
			ad: R_X86_64_PC32	kfree-0x4
      b1:	eb b0                	jmp    63 <afs_cleanq+0x63>
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
      b3:	48 89 df             	mov    %rbx,%rdi
      b6:	ff 14 25 00 00 00 00 	callq  *0x0
			b9: R_X86_64_32S	pv_lock_ops+0x8
afs_cleanq():
/home/austen/programming/dm-afs/src/dm_afs.c:155
        }
    }
    spin_unlock(&flight_eq->mq_lock);
}
      bd:	48 83 c4 08          	add    $0x8,%rsp
      c1:	5b                   	pop    %rbx
      c2:	41 5c                	pop    %r12
      c4:	41 5d                	pop    %r13
      c6:	41 5e                	pop    %r14
      c8:	41 5f                	pop    %r15
      ca:	5d                   	pop    %rbp
      cb:	c3                   	retq   
      cc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000000d0 <afs_map>:
afs_map():
/home/austen/programming/dm-afs/src/dm_afs.c:392
 *  DM_MAPIO_REQUEUE:   dm_afs encountered a problem and the bio needs to
 *                      be resubmitted.
 */
static int
afs_map(struct dm_target *ti, struct bio *bio)
{
      d0:	e8 00 00 00 00       	callq  d5 <afs_map+0x5>
			d1: R_X86_64_PC32	__fentry__-0x4
      d5:	55                   	push   %rbp
      d6:	48 89 e5             	mov    %rsp,%rbp
      d9:	41 55                	push   %r13
      db:	41 54                	push   %r12
      dd:	53                   	push   %rbx
      de:	49 89 f4             	mov    %rsi,%r12
      e1:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs.c:415
    // Moreover, we only support processing a single block per bio.
    // Hence, a request such as (length: 4KB, sector: 1) crosses
    // a block boundary and involves two blocks. For all such requests,
    // we truncate the bio to within the single page.

    sector_offset = bio->bi_iter.bi_sector % (AFS_BLOCK_SIZE / AFS_SECTOR_SIZE);
      e5:	8b 46 28             	mov    0x28(%rsi),%eax
/home/austen/programming/dm-afs/src/dm_afs.c:416
    max_sector_count = (AFS_BLOCK_SIZE / AFS_SECTOR_SIZE) - sector_offset;
      e8:	be 08 00 00 00       	mov    $0x8,%esi
/home/austen/programming/dm-afs/src/dm_afs.c:395
    struct afs_private *context = ti->private;
      ed:	4c 8b 6f 40          	mov    0x40(%rdi),%r13
/home/austen/programming/dm-afs/src/dm_afs.c:415
    sector_offset = bio->bi_iter.bi_sector % (AFS_BLOCK_SIZE / AFS_SECTOR_SIZE);
      f1:	83 e0 07             	and    $0x7,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:416
    max_sector_count = (AFS_BLOCK_SIZE / AFS_SECTOR_SIZE) - sector_offset;
      f4:	29 c6                	sub    %eax,%esi
/home/austen/programming/dm-afs/src/dm_afs.c:417
    if (bio_sectors(bio) > max_sector_count) {
      f6:	41 8b 44 24 30       	mov    0x30(%r12),%eax
      fb:	c1 e8 09             	shr    $0x9,%eax
      fe:	39 f0                	cmp    %esi,%eax
     100:	0f 87 5d 01 00 00    	ja     263 <afs_map+0x193>
kmalloc_large():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:433
     106:	ba 05 00 00 00       	mov    $0x5,%edx
     10b:	be c0 00 40 01       	mov    $0x14000c0,%esi
     110:	bf 00 b0 01 00       	mov    $0x1b000,%edi
     115:	e8 00 00 00 00       	callq  11a <afs_map+0x4a>
			116: R_X86_64_PC32	kmalloc_order_trace-0x4
afs_map():
/home/austen/programming/dm-afs/src/dm_afs.c:423
        dm_accept_partial_bio(bio, max_sector_count);
    }

    // Build request.
    map_element = kmalloc(sizeof(*map_element), GFP_KERNEL);
    afs_action(map_element, ret = DM_MAPIO_KILL, done, "could not allocate memory for request");
     11a:	48 85 c0             	test   %rax,%rax
kmalloc_large():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:433
     11d:	48 89 c3             	mov    %rax,%rbx
afs_map():
/home/austen/programming/dm-afs/src/dm_afs.c:423
     120:	0f 84 4a 01 00 00    	je     270 <afs_map+0x1a0>
/home/austen/programming/dm-afs/src/dm_afs.c:426

    req = &map_element->req;
    req->bdev = context->bdev;
     126:	49 8b 45 08          	mov    0x8(%r13),%rax
     12a:	48 89 83 18 90 01 00 	mov    %rax,0x19018(%rbx)
/home/austen/programming/dm-afs/src/dm_afs.c:427
    req->map = context->afs_map;
     131:	49 8b 85 50 b0 03 00 	mov    0x3b050(%r13),%rax
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
     138:	c7 83 70 90 01 00 00 	movl   $0x0,0x19070(%rbx)
     13f:	00 00 00 
afs_map():
/home/austen/programming/dm-afs/src/dm_afs.c:431
    req->config = &context->config;
    req->fs = &context->passive_fs;
    req->vector = &context->vector;
    req->allocated_write_page = NULL;
     142:	48 c7 83 38 90 01 00 	movq   $0x0,0x19038(%rbx)
     149:	00 00 00 00 
/home/austen/programming/dm-afs/src/dm_afs.c:433
    atomic_set(&req->pending, 0);
    spin_lock_init(&req->req_lock);
     14d:	c7 83 74 90 01 00 00 	movl   $0x0,0x19074(%rbx)
     154:	00 00 00 
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
     157:	48 c7 83 00 90 01 00 	movq   $0x1,0x19000(%rbx)
     15e:	01 00 00 00 
afs_map():
/home/austen/programming/dm-afs/src/dm_afs.c:427
    req->map = context->afs_map;
     162:	48 89 83 10 90 01 00 	mov    %rax,0x19010(%rbx)
/home/austen/programming/dm-afs/src/dm_afs.c:428
    req->config = &context->config;
     169:	49 8d 45 10          	lea    0x10(%r13),%rax
     16d:	48 89 83 20 90 01 00 	mov    %rax,0x19020(%rbx)
/home/austen/programming/dm-afs/src/dm_afs.c:429
    req->fs = &context->passive_fs;
     174:	49 8d 85 00 20 00 00 	lea    0x2000(%r13),%rax
     17b:	48 89 83 28 90 01 00 	mov    %rax,0x19028(%rbx)
/home/austen/programming/dm-afs/src/dm_afs.c:430
    req->vector = &context->vector;
     182:	49 8d 85 08 21 00 00 	lea    0x2108(%r13),%rax
     189:	48 89 83 30 90 01 00 	mov    %rax,0x19030(%rbx)
/home/austen/programming/dm-afs/src/dm_afs.c:436
    atomic64_set(&req->state, REQ_STATE_GROUND);

    switch (bio_op(bio)) {
     190:	41 0f b6 44 24 10    	movzbl 0x10(%r12),%eax
     196:	83 f8 01             	cmp    $0x1,%eax
     199:	0f 86 80 00 00 00    	jbe    21f <afs_map+0x14f>
     19f:	83 f8 02             	cmp    $0x2,%eax
     1a2:	75 4d                	jne    1f1 <afs_map+0x121>
     1a4:	49 8d 9d 00 f0 01 00 	lea    0x1f000(%r13),%rbx
     1ab:	49 81 c5 00 30 00 00 	add    $0x3000,%r13
     1b2:	eb 0a                	jmp    1be <afs_map+0xee>
/home/austen/programming/dm-afs/src/dm_afs.c:450
        ret = DM_MAPIO_SUBMITTED;
        break;

    case REQ_OP_FLUSH:
        while (afs_eq_req_exist(&context->flight_eq, bio) || afs_eq_req_exist(&context->ground_eq, bio)) {
            msleep(1);
     1b4:	bf 01 00 00 00       	mov    $0x1,%edi
     1b9:	e8 00 00 00 00       	callq  1be <afs_map+0xee>
			1ba: R_X86_64_PC32	msleep-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:449
        while (afs_eq_req_exist(&context->flight_eq, bio) || afs_eq_req_exist(&context->ground_eq, bio)) {
     1be:	4c 89 e6             	mov    %r12,%rsi
     1c1:	48 89 df             	mov    %rbx,%rdi
     1c4:	e8 00 00 00 00       	callq  1c9 <afs_map+0xf9>
			1c5: R_X86_64_PC32	afs_eq_req_exist-0x4
     1c9:	84 c0                	test   %al,%al
     1cb:	75 e7                	jne    1b4 <afs_map+0xe4>
/home/austen/programming/dm-afs/src/dm_afs.c:449 (discriminator 1)
     1cd:	4c 89 e6             	mov    %r12,%rsi
     1d0:	4c 89 ef             	mov    %r13,%rdi
     1d3:	e8 00 00 00 00       	callq  1d8 <afs_map+0x108>
			1d4: R_X86_64_PC32	afs_eq_req_exist-0x4
     1d8:	84 c0                	test   %al,%al
     1da:	75 d8                	jne    1b4 <afs_map+0xe4>
/home/austen/programming/dm-afs/src/dm_afs.c:452
        }
        bio_endio(bio);
     1dc:	4c 89 e7             	mov    %r12,%rdi
     1df:	e8 00 00 00 00       	callq  1e4 <afs_map+0x114>
			1e0: R_X86_64_PC32	bio_endio-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:469
        if (map_element) {
            kfree(map_element);
        }
    }
    return ret;
}
     1e4:	48 83 c4 08          	add    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs.c:453
        ret = DM_MAPIO_SUBMITTED;
     1e8:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:469
}
     1ea:	5b                   	pop    %rbx
     1eb:	41 5c                	pop    %r12
     1ed:	41 5d                	pop    %r13
     1ef:	5d                   	pop    %rbp
     1f0:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs.c:457
        afs_debug("unknown operation");
     1f1:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1f7 <afs_map+0x127>
			1f3: R_X86_64_PC32	afs_debug_mode-0x4
     1f7:	85 c0                	test   %eax,%eax
     1f9:	0f 85 9d 00 00 00    	jne    29c <afs_map+0x1cc>
/home/austen/programming/dm-afs/src/dm_afs.c:463
        bio_endio(bio);
     1ff:	4c 89 e7             	mov    %r12,%rdi
     202:	e8 00 00 00 00       	callq  207 <afs_map+0x137>
			203: R_X86_64_PC32	bio_endio-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:465
            kfree(map_element);
     207:	48 89 df             	mov    %rbx,%rdi
     20a:	e8 00 00 00 00       	callq  20f <afs_map+0x13f>
			20b: R_X86_64_PC32	kfree-0x4
     20f:	b8 04 00 00 00       	mov    $0x4,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:469
}
     214:	48 83 c4 08          	add    $0x8,%rsp
     218:	5b                   	pop    %rbx
     219:	41 5c                	pop    %r12
     21b:	41 5d                	pop    %r13
     21d:	5d                   	pop    %rbp
     21e:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs.c:440
        afs_action(req->bio, ret = DM_MAPIO_KILL, done, "could not clone bio");
     21f:	4d 85 e4             	test   %r12,%r12
/home/austen/programming/dm-afs/src/dm_afs.c:439
        req->bio = __clone_bio(bio, &req->allocated_write_page, true);
     222:	4c 89 a3 08 90 01 00 	mov    %r12,0x19008(%rbx)
/home/austen/programming/dm-afs/src/dm_afs.c:440
        afs_action(req->bio, ret = DM_MAPIO_KILL, done, "could not clone bio");
     229:	0f 84 8c 00 00 00    	je     2bb <afs_map+0x1eb>
/home/austen/programming/dm-afs/src/dm_afs.c:441
        afs_eq_add(&context->ground_eq, map_element);
     22f:	49 8d bd 00 30 00 00 	lea    0x3000(%r13),%rdi
     236:	48 89 de             	mov    %rbx,%rsi
     239:	e8 00 00 00 00       	callq  23e <afs_map+0x16e>
			23a: R_X86_64_PC32	afs_eq_add-0x4
queue_work():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/workqueue.h:489
     23e:	49 8b b5 00 b0 03 00 	mov    0x3b000(%r13),%rsi
afs_map():
/home/austen/programming/dm-afs/src/dm_afs.c:444
        queue_work(context->ground_wq, &context->ground_ws);
     245:	49 8d 95 10 b0 03 00 	lea    0x3b010(%r13),%rdx
queue_work():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/workqueue.h:489
     24c:	bf 00 20 00 00       	mov    $0x2000,%edi
     251:	e8 00 00 00 00       	callq  256 <afs_map+0x186>
			252: R_X86_64_PC32	queue_work_on-0x4
afs_map():
/home/austen/programming/dm-afs/src/dm_afs.c:469
}
     256:	48 83 c4 08          	add    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs.c:445
        ret = DM_MAPIO_SUBMITTED;
     25a:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:469
}
     25c:	5b                   	pop    %rbx
     25d:	41 5c                	pop    %r12
     25f:	41 5d                	pop    %r13
     261:	5d                   	pop    %rbp
     262:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs.c:418
        dm_accept_partial_bio(bio, max_sector_count);
     263:	4c 89 e7             	mov    %r12,%rdi
     266:	e8 00 00 00 00       	callq  26b <afs_map+0x19b>
			267: R_X86_64_PC32	dm_accept_partial_bio-0x4
     26b:	e9 96 fe ff ff       	jmpq   106 <afs_map+0x36>
/home/austen/programming/dm-afs/src/dm_afs.c:423 (discriminator 1)
    afs_action(map_element, ret = DM_MAPIO_KILL, done, "could not allocate memory for request");
     270:	ba a7 01 00 00       	mov    $0x1a7,%edx
     275:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			278: R_X86_64_32S	.rodata+0x50
     27c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			27f: R_X86_64_32S	.rodata.str1.8
     283:	31 c0                	xor    %eax,%eax
     285:	e8 00 00 00 00       	callq  28a <afs_map+0x1ba>
			286: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:463 (discriminator 1)
        bio_endio(bio);
     28a:	4c 89 e7             	mov    %r12,%rdi
     28d:	e8 00 00 00 00       	callq  292 <afs_map+0x1c2>
			28e: R_X86_64_PC32	bio_endio-0x4
     292:	b8 04 00 00 00       	mov    $0x4,%eax
     297:	e9 78 ff ff ff       	jmpq   214 <afs_map+0x144>
/home/austen/programming/dm-afs/src/dm_afs.c:457 (discriminator 1)
        afs_debug("unknown operation");
     29c:	ba c9 01 00 00       	mov    $0x1c9,%edx
     2a1:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2a4: R_X86_64_32S	.rodata+0x50
     2a8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2ab: R_X86_64_32S	.rodata.str1.8+0x70
     2af:	31 c0                	xor    %eax,%eax
     2b1:	e8 00 00 00 00       	callq  2b6 <afs_map+0x1e6>
			2b2: R_X86_64_PC32	printk-0x4
     2b6:	e9 44 ff ff ff       	jmpq   1ff <afs_map+0x12f>
/home/austen/programming/dm-afs/src/dm_afs.c:440 (discriminator 1)
        afs_action(req->bio, ret = DM_MAPIO_KILL, done, "could not clone bio");
     2bb:	ba b8 01 00 00       	mov    $0x1b8,%edx
     2c0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2c3: R_X86_64_32S	.rodata+0x50
     2c7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2ca: R_X86_64_32S	.rodata.str1.8+0x40
     2ce:	31 c0                	xor    %eax,%eax
     2d0:	e8 00 00 00 00       	callq  2d5 <afs_map+0x205>
			2d1: R_X86_64_PC32	printk-0x4
     2d5:	e9 25 ff ff ff       	jmpq   1ff <afs_map+0x12f>
     2da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000002e0 <afs_groundq>:
afs_groundq():
/home/austen/programming/dm-afs/src/dm_afs.c:221
{
     2e0:	e8 00 00 00 00       	callq  2e5 <afs_groundq+0x5>
			2e1: R_X86_64_PC32	__fentry__-0x4
     2e5:	55                   	push   %rbp
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
     2e6:	48 8d 87 f0 2f fe ff 	lea    -0x1d010(%rdi),%rax
afs_groundq():
/home/austen/programming/dm-afs/src/dm_afs.c:221
     2ed:	48 89 e5             	mov    %rsp,%rbp
     2f0:	41 57                	push   %r15
     2f2:	41 56                	push   %r14
     2f4:	41 55                	push   %r13
     2f6:	41 54                	push   %r12
     2f8:	49 89 fe             	mov    %rdi,%r14
     2fb:	53                   	push   %rbx
/home/austen/programming/dm-afs/src/dm_afs.c:230
    ground_eq = &context->ground_eq;
     2fc:	48 8d 9f f0 4f fc ff 	lea    -0x3b010(%rdi),%rbx
/home/austen/programming/dm-afs/src/dm_afs.c:221
{
     303:	48 83 ec 18          	sub    $0x18,%rsp
/home/austen/programming/dm-afs/src/dm_afs.c:230
    ground_eq = &context->ground_eq;
     307:	4c 8d a3 00 30 00 00 	lea    0x3000(%rbx),%r12
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
     30e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
afs_groundq():
/home/austen/programming/dm-afs/src/dm_afs.c:231
    flight_eq = &context->flight_eq;
     312:	48 81 c3 00 f0 01 00 	add    $0x1f000,%rbx
/home/austen/programming/dm-afs/src/dm_afs.c:233
    while (!afs_eq_empty(ground_eq)) {
     319:	4c 89 e7             	mov    %r12,%rdi
     31c:	e8 00 00 00 00       	callq  321 <afs_groundq+0x41>
			31d: R_X86_64_PC32	afs_eq_empty-0x4
     321:	84 c0                	test   %al,%al
     323:	0f 85 1f 01 00 00    	jne    448 <afs_groundq+0x168>
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
     329:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
     32d:	e8 00 00 00 00       	callq  332 <afs_groundq+0x52>
			32e: R_X86_64_PC32	_raw_spin_lock-0x4
afs_groundq():
/home/austen/programming/dm-afs/src/dm_afs.c:249
        list_for_each_entry_safe (node, node_extra, &ground_eq->mq.list, list) {
     332:	49 8b 86 20 20 fe ff 	mov    -0x1dfe0(%r14),%rax
     339:	4c 8d b8 d0 5f fe ff 	lea    -0x1a030(%rax),%r15
     340:	48 8b 08             	mov    (%rax),%rcx
     343:	4d 39 fc             	cmp    %r15,%r12
     346:	4c 8d a9 d0 5f fe ff 	lea    -0x1a030(%rcx),%r13
     34d:	75 21                	jne    370 <afs_groundq+0x90>
     34f:	e9 03 01 00 00       	jmpq   457 <afs_groundq+0x177>
     354:	49 8b 85 30 a0 01 00 	mov    0x1a030(%r13),%rax
     35b:	4d 89 ef             	mov    %r13,%r15
     35e:	48 2d 30 a0 01 00    	sub    $0x1a030,%rax
     364:	4d 39 ec             	cmp    %r13,%r12
     367:	0f 84 ea 00 00 00    	je     457 <afs_groundq+0x177>
     36d:	49 89 c5             	mov    %rax,%r13
/home/austen/programming/dm-afs/src/dm_afs.c:250
            exists = afs_eq_req_exist(flight_eq, node->req.bio);
     370:	49 8b b7 08 90 01 00 	mov    0x19008(%r15),%rsi
     377:	48 89 df             	mov    %rbx,%rdi
     37a:	e8 00 00 00 00       	callq  37f <afs_groundq+0x9f>
			37b: R_X86_64_PC32	afs_eq_req_exist-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:251
            if (!exists) {
     37f:	84 c0                	test   %al,%al
     381:	75 d1                	jne    354 <afs_groundq+0x74>
__list_del_entry():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:120
     383:	49 8b 87 38 a0 01 00 	mov    0x1a038(%r15),%rax
     38a:	49 8b 8f 30 a0 01 00 	mov    0x1a030(%r15),%rcx
__list_del():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:105
     391:	48 89 41 08          	mov    %rax,0x8(%rcx)
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
     395:	48 89 08             	mov    %rcx,(%rax)
list_del():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:126
     398:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
     39f:	00 ad de 
     3a2:	49 89 87 30 a0 01 00 	mov    %rax,0x1a030(%r15)
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:127
     3a9:	48 05 00 01 00 00    	add    $0x100,%rax
     3af:	49 89 87 38 a0 01 00 	mov    %rax,0x1a038(%r15)
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
     3b6:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
     3ba:	ff 14 25 00 00 00 00 	callq  *0x0
			3bd: R_X86_64_32S	pv_lock_ops+0x8
afs_groundq():
/home/austen/programming/dm-afs/src/dm_afs.c:263
        if (!element) {
     3c1:	4d 85 ff             	test   %r15,%r15
     3c4:	0f 84 95 00 00 00    	je     45f <afs_groundq+0x17f>
/home/austen/programming/dm-afs/src/dm_afs.c:270
        element->clean_ws = &context->clean_ws;
     3ca:	49 8d 46 20          	lea    0x20(%r14),%rax
/home/austen/programming/dm-afs/src/dm_afs.c:274
        afs_eq_add(flight_eq, element);
     3ce:	4c 89 fe             	mov    %r15,%rsi
     3d1:	48 89 df             	mov    %rbx,%rdi
/home/austen/programming/dm-afs/src/dm_afs.c:269
        element->eq = flight_eq;
     3d4:	49 89 9f 28 a0 01 00 	mov    %rbx,0x1a028(%r15)
/home/austen/programming/dm-afs/src/dm_afs.c:271
        INIT_WORK(&element->req_ws, afs_flightq);
     3db:	49 c7 87 18 a0 01 00 	movq   $0x0,0x1a018(%r15)
     3e2:	00 00 00 00 
			3e2: R_X86_64_32S	.text+0x5c0
/home/austen/programming/dm-afs/src/dm_afs.c:270
        element->clean_ws = &context->clean_ws;
     3e6:	49 89 87 20 a0 01 00 	mov    %rax,0x1a020(%r15)
/home/austen/programming/dm-afs/src/dm_afs.c:271
        INIT_WORK(&element->req_ws, afs_flightq);
     3ed:	48 b8 e0 ff ff ff 0f 	movabs $0xfffffffe0,%rax
     3f4:	00 00 00 
     3f7:	49 89 87 00 a0 01 00 	mov    %rax,0x1a000(%r15)
     3fe:	49 8d 87 08 a0 01 00 	lea    0x1a008(%r15),%rax
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
     405:	49 89 87 08 a0 01 00 	mov    %rax,0x1a008(%r15)
INIT_LIST_HEAD():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:29
     40c:	49 89 87 10 a0 01 00 	mov    %rax,0x1a010(%r15)
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
     413:	49 c7 87 00 90 01 00 	movq   $0x2,0x19000(%r15)
     41a:	02 00 00 00 
afs_groundq():
/home/austen/programming/dm-afs/src/dm_afs.c:274
        afs_eq_add(flight_eq, element);
     41e:	e8 00 00 00 00       	callq  423 <afs_groundq+0x143>
			41f: R_X86_64_PC32	afs_eq_add-0x4
queue_work():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/workqueue.h:489
     423:	49 8b 76 f8          	mov    -0x8(%r14),%rsi
afs_groundq():
/home/austen/programming/dm-afs/src/dm_afs.c:271
        INIT_WORK(&element->req_ws, afs_flightq);
     427:	49 8d 97 00 a0 01 00 	lea    0x1a000(%r15),%rdx
queue_work():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/workqueue.h:489
     42e:	bf 00 20 00 00       	mov    $0x2000,%edi
     433:	e8 00 00 00 00       	callq  438 <afs_groundq+0x158>
			434: R_X86_64_PC32	queue_work_on-0x4
afs_groundq():
/home/austen/programming/dm-afs/src/dm_afs.c:233
    while (!afs_eq_empty(ground_eq)) {
     438:	4c 89 e7             	mov    %r12,%rdi
     43b:	e8 00 00 00 00       	callq  440 <afs_groundq+0x160>
			43c: R_X86_64_PC32	afs_eq_empty-0x4
     440:	84 c0                	test   %al,%al
     442:	0f 84 e1 fe ff ff    	je     329 <afs_groundq+0x49>
/home/austen/programming/dm-afs/src/dm_afs.c:289
}
     448:	48 83 c4 18          	add    $0x18,%rsp
     44c:	5b                   	pop    %rbx
     44d:	41 5c                	pop    %r12
     44f:	41 5d                	pop    %r13
     451:	41 5e                	pop    %r14
     453:	41 5f                	pop    %r15
     455:	5d                   	pop    %rbp
     456:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs.c:234
        element = NULL;
     457:	45 31 ff             	xor    %r15d,%r15d
     45a:	e9 57 ff ff ff       	jmpq   3b6 <afs_groundq+0xd6>
/home/austen/programming/dm-afs/src/dm_afs.c:264
            msleep(1);
     45f:	bf 01 00 00 00       	mov    $0x1,%edi
     464:	e8 00 00 00 00       	callq  469 <afs_groundq+0x189>
			465: R_X86_64_PC32	msleep-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:265
            continue;
     469:	e9 ab fe ff ff       	jmpq   319 <afs_groundq+0x39>
     46e:	66 90                	xchg   %ax,%ax

0000000000000470 <afs_dtr>:
afs_dtr():
/home/austen/programming/dm-afs/src/dm_afs.c:645
 *
 * @ti  Target instance to be destroyed.
 */
static void
afs_dtr(struct dm_target *ti)
{
     470:	e8 00 00 00 00       	callq  475 <afs_dtr+0x5>
			471: R_X86_64_PC32	__fentry__-0x4
     475:	55                   	push   %rbp
     476:	48 89 e5             	mov    %rsp,%rbp
     479:	41 56                	push   %r14
     47b:	41 55                	push   %r13
     47d:	41 54                	push   %r12
     47f:	53                   	push   %rbx
     480:	49 89 fe             	mov    %rdi,%r14
/home/austen/programming/dm-afs/src/dm_afs.c:646
    struct afs_private *context = ti->private;
     483:	48 8b 5f 40          	mov    0x40(%rdi),%rbx
     487:	4c 8d a3 00 f0 01 00 	lea    0x1f000(%rbx),%r12
     48e:	4c 8d ab 00 30 00 00 	lea    0x3000(%rbx),%r13
/home/austen/programming/dm-afs/src/dm_afs.c:650
    int err;

    // Wait for all requests to have processed. DO NOT busy wait.
    while (!afs_eq_empty(&context->flight_eq) || !afs_eq_empty(&context->ground_eq)) {
     495:	eb 0a                	jmp    4a1 <afs_dtr+0x31>
/home/austen/programming/dm-afs/src/dm_afs.c:651
        msleep(1);
     497:	bf 01 00 00 00       	mov    $0x1,%edi
     49c:	e8 00 00 00 00       	callq  4a1 <afs_dtr+0x31>
			49d: R_X86_64_PC32	msleep-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:650
    while (!afs_eq_empty(&context->flight_eq) || !afs_eq_empty(&context->ground_eq)) {
     4a1:	4c 89 e7             	mov    %r12,%rdi
     4a4:	e8 00 00 00 00       	callq  4a9 <afs_dtr+0x39>
			4a5: R_X86_64_PC32	afs_eq_empty-0x4
     4a9:	84 c0                	test   %al,%al
     4ab:	74 ea                	je     497 <afs_dtr+0x27>
/home/austen/programming/dm-afs/src/dm_afs.c:650 (discriminator 1)
     4ad:	4c 89 ef             	mov    %r13,%rdi
     4b0:	e8 00 00 00 00       	callq  4b5 <afs_dtr+0x45>
			4b1: R_X86_64_PC32	afs_eq_empty-0x4
     4b5:	84 c0                	test   %al,%al
     4b7:	74 de                	je     497 <afs_dtr+0x27>
/home/austen/programming/dm-afs/src/dm_afs.c:655
    }

    // Update the Artifice map on the disk.
    err = afs_create_map_blocks(context);
     4b9:	48 89 df             	mov    %rbx,%rdi
     4bc:	e8 00 00 00 00       	callq  4c1 <afs_dtr+0x51>
			4bd: R_X86_64_PC32	afs_create_map_blocks-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:656
    if (err) {
     4c1:	85 c0                	test   %eax,%eax
     4c3:	0f 85 8f 00 00 00    	jne    558 <afs_dtr+0xe8>
/home/austen/programming/dm-afs/src/dm_afs.c:659
        afs_alert("could not create Artifice map blocks [%d]", err);
    } else {
        err = write_map_blocks(context, true);
     4c9:	be 01 00 00 00       	mov    $0x1,%esi
     4ce:	48 89 df             	mov    %rbx,%rdi
     4d1:	e8 00 00 00 00       	callq  4d6 <afs_dtr+0x66>
			4d2: R_X86_64_PC32	write_map_blocks-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:660
        if (err) {
     4d6:	85 c0                	test   %eax,%eax
     4d8:	0f 85 b7 00 00 00    	jne    595 <afs_dtr+0x125>
/home/austen/programming/dm-afs/src/dm_afs.c:663
            afs_alert("could not update Artifice map on disk [%d]", err);
        }
        vfree(context->afs_map_blocks);
     4de:	48 8b bb 58 b0 03 00 	mov    0x3b058(%rbx),%rdi
     4e5:	e8 00 00 00 00       	callq  4ea <afs_dtr+0x7a>
			4e6: R_X86_64_PC32	vfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:668
    }
    

    // Free the Artifice pointer blocks.
    kfree(context->afs_ptr_blocks);
     4ea:	48 8b bb 60 b0 03 00 	mov    0x3b060(%rbx),%rdi
     4f1:	e8 00 00 00 00       	callq  4f6 <afs_dtr+0x86>
			4f2: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:671

    // Free the Artifice map.
    vfree(context->afs_map);
     4f6:	48 8b bb 50 b0 03 00 	mov    0x3b050(%rbx),%rdi
     4fd:	e8 00 00 00 00       	callq  502 <afs_dtr+0x92>
			4fe: R_X86_64_PC32	vfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:674

    // Free the bit vector allocation.
    bit_vector_free(context->vector.vector);
     502:	48 8b bb 08 21 00 00 	mov    0x2108(%rbx),%rdi
     509:	e8 00 00 00 00       	callq  50e <afs_dtr+0x9e>
			50a: R_X86_64_PC32	bit_vector_free-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:677

    // Free the block list for the passive FS.
    vfree(context->passive_fs.block_list);
     50e:	48 8b bb 00 20 00 00 	mov    0x2000(%rbx),%rdi
     515:	e8 00 00 00 00       	callq  51a <afs_dtr+0xaa>
			516: R_X86_64_PC32	vfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:680

    // Put the device back.
    dm_put_device(ti, context->passive_dev);
     51a:	48 8b 33             	mov    (%rbx),%rsi
     51d:	4c 89 f7             	mov    %r14,%rdi
     520:	e8 00 00 00 00       	callq  525 <afs_dtr+0xb5>
			521: R_X86_64_PC32	dm_put_device-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:683

    // Destroy the workqueues.
    destroy_workqueue(context->flight_wq);
     525:	48 8b bb 08 b0 03 00 	mov    0x3b008(%rbx),%rdi
     52c:	e8 00 00 00 00       	callq  531 <afs_dtr+0xc1>
			52d: R_X86_64_PC32	destroy_workqueue-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:684
    destroy_workqueue(context->ground_wq);
     531:	48 8b bb 00 b0 03 00 	mov    0x3b000(%rbx),%rdi
     538:	e8 00 00 00 00       	callq  53d <afs_dtr+0xcd>
			539: R_X86_64_PC32	destroy_workqueue-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:687

    // Free storage used by context.
    kfree(context);
     53d:	48 89 df             	mov    %rbx,%rdi
     540:	e8 00 00 00 00       	callq  545 <afs_dtr+0xd5>
			541: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:688
    afs_debug("destructor completed");
     545:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 54b <afs_dtr+0xdb>
			547: R_X86_64_PC32	afs_debug_mode-0x4
     54b:	85 c0                	test   %eax,%eax
     54d:	75 2a                	jne    579 <afs_dtr+0x109>
/home/austen/programming/dm-afs/src/dm_afs.c:689
}
     54f:	5b                   	pop    %rbx
     550:	41 5c                	pop    %r12
     552:	41 5d                	pop    %r13
     554:	41 5e                	pop    %r14
     556:	5d                   	pop    %rbp
     557:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs.c:657
        afs_alert("could not create Artifice map blocks [%d]", err);
     558:	89 c1                	mov    %eax,%ecx
     55a:	ba 91 02 00 00       	mov    $0x291,%edx
     55f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			562: R_X86_64_32S	.rodata+0x48
     566:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			569: R_X86_64_32S	.rodata.str1.8+0xa0
     56d:	31 c0                	xor    %eax,%eax
     56f:	e8 00 00 00 00       	callq  574 <afs_dtr+0x104>
			570: R_X86_64_PC32	printk-0x4
     574:	e9 71 ff ff ff       	jmpq   4ea <afs_dtr+0x7a>
/home/austen/programming/dm-afs/src/dm_afs.c:688 (discriminator 1)
    afs_debug("destructor completed");
     579:	ba b0 02 00 00       	mov    $0x2b0,%edx
     57e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			581: R_X86_64_32S	.rodata+0x48
     585:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			588: R_X86_64_32S	.rodata.str1.8+0x130
     58c:	31 c0                	xor    %eax,%eax
     58e:	e8 00 00 00 00       	callq  593 <afs_dtr+0x123>
			58f: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:689 (discriminator 1)
}
     593:	eb ba                	jmp    54f <afs_dtr+0xdf>
/home/austen/programming/dm-afs/src/dm_afs.c:661
            afs_alert("could not update Artifice map on disk [%d]", err);
     595:	89 c1                	mov    %eax,%ecx
     597:	ba 95 02 00 00       	mov    $0x295,%edx
     59c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			59f: R_X86_64_32S	.rodata+0x48
     5a3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			5a6: R_X86_64_32S	.rodata.str1.8+0xe8
     5aa:	31 c0                	xor    %eax,%eax
     5ac:	e8 00 00 00 00       	callq  5b1 <afs_dtr+0x141>
			5ad: R_X86_64_PC32	printk-0x4
     5b1:	e9 28 ff ff ff       	jmpq   4de <afs_dtr+0x6e>
     5b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     5bd:	00 00 00 

00000000000005c0 <afs_flightq>:
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:162
{
     5c0:	e8 00 00 00 00       	callq  5c5 <afs_flightq+0x5>
			5c1: R_X86_64_PC32	__fentry__-0x4
     5c5:	55                   	push   %rbp
     5c6:	48 89 e5             	mov    %rsp,%rbp
     5c9:	41 54                	push   %r12
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
     5cb:	4c 8d a7 74 f0 ff ff 	lea    -0xf8c(%rdi),%r12
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:162
     5d2:	53                   	push   %rbx
     5d3:	48 89 fb             	mov    %rdi,%rbx
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
     5d6:	4c 89 e7             	mov    %r12,%rdi
     5d9:	e8 00 00 00 00       	callq  5de <afs_flightq+0x1e>
			5da: R_X86_64_PC32	_raw_spin_lock-0x4
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188
     5de:	8b 83 70 f0 ff ff    	mov    -0xf90(%rbx),%eax
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:171
    if(atomic_read(&req->pending) != 0){
     5e4:	85 c0                	test   %eax,%eax
     5e6:	74 13                	je     5fb <afs_flightq+0x3b>
/home/austen/programming/dm-afs/src/dm_afs.c:172
        afs_debug("already processing");
     5e8:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 5ee <afs_flightq+0x2e>
			5ea: R_X86_64_PC32	afs_debug_mode-0x4
     5ee:	85 d2                	test   %edx,%edx
     5f0:	0f 85 e4 00 00 00    	jne    6da <afs_flightq+0x11a>
/home/austen/programming/dm-afs/src/dm_afs.c:210
}
     5f6:	5b                   	pop    %rbx
     5f7:	41 5c                	pop    %r12
     5f9:	5d                   	pop    %rbp
     5fa:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs.c:176
    switch (bio_op(req->bio)) {
     5fb:	48 8b b3 08 f0 ff ff 	mov    -0xff8(%rbx),%rsi
/home/austen/programming/dm-afs/src/dm_afs.c:168
    req = &element->req;
     602:	48 8d bb 00 60 fe ff 	lea    -0x1a000(%rbx),%rdi
/home/austen/programming/dm-afs/src/dm_afs.c:176
    switch (bio_op(req->bio)) {
     609:	44 0f b6 46 10       	movzbl 0x10(%rsi),%r8d
     60e:	45 85 c0             	test   %r8d,%r8d
     611:	0f 84 b2 00 00 00    	je     6c9 <afs_flightq+0x109>
     617:	41 83 f8 01          	cmp    $0x1,%r8d
     61b:	74 7f                	je     69c <afs_flightq+0xdc>
/home/austen/programming/dm-afs/src/dm_afs.c:189
        afs_debug("This case should never be encountered!");
     61d:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 623 <afs_flightq+0x63>
			61f: R_X86_64_PC32	afs_debug_mode-0x4
     623:	85 c0                	test   %eax,%eax
     625:	0f 85 ce 00 00 00    	jne    6f9 <afs_flightq+0x139>
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188
     62b:	8b 83 70 f0 ff ff    	mov    -0xf90(%rbx),%eax
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:192
    if(atomic_read(&req->pending) == 2){
     631:	83 f8 02             	cmp    $0x2,%eax
     634:	74 28                	je     65e <afs_flightq+0x9e>
/home/austen/programming/dm-afs/src/dm_afs.c:188
        ret = -EINVAL;
     636:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:195 (discriminator 1)
    afs_assert(!ret, done, "could not perform operation [%d:%d]", ret, bio_op(req->bio));
     63b:	89 c1                	mov    %eax,%ecx
     63d:	ba c3 00 00 00       	mov    $0xc3,%edx
     642:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			645: R_X86_64_32S	.rodata+0x30
     649:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			64c: R_X86_64_32S	.rodata.str1.8+0x1d0
     650:	31 c0                	xor    %eax,%eax
     652:	e8 00 00 00 00       	callq  657 <afs_flightq+0x97>
			653: R_X86_64_PC32	printk-0x4
     657:	48 8b b3 08 f0 ff ff 	mov    -0xff8(%rbx),%rsi
/home/austen/programming/dm-afs/src/dm_afs.c:201
    bio_endio(req->bio);
     65e:	48 89 f7             	mov    %rsi,%rdi
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
     661:	48 c7 83 00 f0 ff ff 	movq   $0x4,-0x1000(%rbx)
     668:	04 00 00 00 
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:201
     66c:	e8 00 00 00 00       	callq  671 <afs_flightq+0xb1>
			66d: R_X86_64_PC32	bio_endio-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:205
    if (req->allocated_write_page) {
     671:	48 8b bb 38 f0 ff ff 	mov    -0xfc8(%rbx),%rdi
     678:	48 85 ff             	test   %rdi,%rdi
     67b:	74 05                	je     682 <afs_flightq+0xc2>
/home/austen/programming/dm-afs/src/dm_afs.c:206
        kfree(req->allocated_write_page);
     67d:	e8 00 00 00 00       	callq  682 <afs_flightq+0xc2>
			67e: R_X86_64_PC32	kfree-0x4
queue_work():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/workqueue.h:489
     682:	48 8b 53 20          	mov    0x20(%rbx),%rdx
     686:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 68d <afs_flightq+0xcd>
			689: R_X86_64_PC32	system_wq-0x4
     68d:	bf 00 20 00 00       	mov    $0x2000,%edi
     692:	e8 00 00 00 00       	callq  697 <afs_flightq+0xd7>
			693: R_X86_64_PC32	queue_work_on-0x4
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:210
}
     697:	5b                   	pop    %rbx
     698:	41 5c                	pop    %r12
     69a:	5d                   	pop    %rbp
     69b:	c3                   	retq   
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
     69c:	c7 83 70 f0 ff ff 01 	movl   $0x1,-0xf90(%rbx)
     6a3:	00 00 00 
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:184
        ret = afs_write_request(req, req->bio);
     6a6:	e8 00 00 00 00       	callq  6ab <afs_flightq+0xeb>
			6a7: R_X86_64_PC32	afs_write_request-0x4
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188
     6ab:	8b 93 70 f0 ff ff    	mov    -0xf90(%rbx),%edx
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:192
    if(atomic_read(&req->pending) == 2){
     6b1:	83 fa 02             	cmp    $0x2,%edx
     6b4:	74 a1                	je     657 <afs_flightq+0x97>
/home/austen/programming/dm-afs/src/dm_afs.c:195
    afs_assert(!ret, done, "could not perform operation [%d:%d]", ret, bio_op(req->bio));
     6b6:	85 c0                	test   %eax,%eax
     6b8:	75 79                	jne    733 <afs_flightq+0x173>
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
     6ba:	4c 89 e7             	mov    %r12,%rdi
     6bd:	ff 14 25 00 00 00 00 	callq  *0x0
			6c0: R_X86_64_32S	pv_lock_ops+0x8
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:210
}
     6c4:	5b                   	pop    %rbx
     6c5:	41 5c                	pop    %r12
     6c7:	5d                   	pop    %rbp
     6c8:	c3                   	retq   
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
     6c9:	c7 83 70 f0 ff ff 01 	movl   $0x1,-0xf90(%rbx)
     6d0:	00 00 00 
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:179
        ret = afs_read_request(req, req->bio);
     6d3:	e8 00 00 00 00       	callq  6d8 <afs_flightq+0x118>
			6d4: R_X86_64_PC32	afs_read_request-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:180
        break;
     6d8:	eb d1                	jmp    6ab <afs_flightq+0xeb>
/home/austen/programming/dm-afs/src/dm_afs.c:172 (discriminator 1)
        afs_debug("already processing");
     6da:	ba ac 00 00 00       	mov    $0xac,%edx
     6df:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			6e2: R_X86_64_32S	.rodata+0x30
     6e6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			6e9: R_X86_64_32S	.rodata.str1.8+0x160
     6ed:	31 c0                	xor    %eax,%eax
     6ef:	e8 00 00 00 00       	callq  6f4 <afs_flightq+0x134>
			6f0: R_X86_64_PC32	printk-0x4
     6f4:	e9 fd fe ff ff       	jmpq   5f6 <afs_flightq+0x36>
/home/austen/programming/dm-afs/src/dm_afs.c:189 (discriminator 1)
        afs_debug("This case should never be encountered!");
     6f9:	31 c0                	xor    %eax,%eax
     6fb:	ba bd 00 00 00       	mov    $0xbd,%edx
     700:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			703: R_X86_64_32S	.rodata+0x30
     707:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			70a: R_X86_64_32S	.rodata.str1.8+0x190
     70e:	e8 00 00 00 00       	callq  713 <afs_flightq+0x153>
			70f: R_X86_64_PC32	printk-0x4
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188 (discriminator 1)
     713:	8b 83 70 f0 ff ff    	mov    -0xf90(%rbx),%eax
afs_flightq():
/home/austen/programming/dm-afs/src/dm_afs.c:192 (discriminator 1)
    if(atomic_read(&req->pending) == 2){
     719:	83 f8 02             	cmp    $0x2,%eax
     71c:	0f 84 35 ff ff ff    	je     657 <afs_flightq+0x97>
     722:	48 8b 83 08 f0 ff ff 	mov    -0xff8(%rbx),%rax
     729:	44 0f b6 40 10       	movzbl 0x10(%rax),%r8d
     72e:	e9 03 ff ff ff       	jmpq   636 <afs_flightq+0x76>
     733:	48 8b 93 08 f0 ff ff 	mov    -0xff8(%rbx),%rdx
     73a:	44 0f b6 42 10       	movzbl 0x10(%rdx),%r8d
     73f:	e9 f7 fe ff ff       	jmpq   63b <afs_flightq+0x7b>
     744:	66 90                	xchg   %ax,%ax
     746:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     74d:	00 00 00 

0000000000000750 <afs_ctr>:
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:491
{
     750:	e8 00 00 00 00       	callq  755 <afs_ctr+0x5>
			751: R_X86_64_PC32	__fentry__-0x4
     755:	55                   	push   %rbp
     756:	48 89 e5             	mov    %rsp,%rbp
     759:	41 57                	push   %r15
     75b:	41 56                	push   %r14
     75d:	41 55                	push   %r13
     75f:	41 54                	push   %r12
     761:	53                   	push   %rbx
     762:	48 83 ec 18          	sub    $0x18,%rsp
/home/austen/programming/dm-afs/src/dm_afs.c:502
    instance_size = ti->len * AFS_SECTOR_SIZE;
     766:	48 8b 47 18          	mov    0x18(%rdi),%rax
/home/austen/programming/dm-afs/src/dm_afs.c:491
{
     76a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs.c:502
    instance_size = ti->len * AFS_SECTOR_SIZE;
     76e:	49 89 c6             	mov    %rax,%r14
     771:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     775:	49 c1 e6 09          	shl    $0x9,%r14
/home/austen/programming/dm-afs/src/dm_afs.c:503
    afs_action(instance_size >= AFS_MIN_SIZE, ret = -EINVAL, err, "instance too small [%llu]", instance_size);
     779:	49 81 fe ff ff 00 00 	cmp    $0xffff,%r14
     780:	0f 86 3f 07 00 00    	jbe    ec5 <afs_ctr+0x775>
     786:	41 89 f5             	mov    %esi,%r13d
     789:	48 89 d3             	mov    %rdx,%rbx
kmalloc_large():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:433
     78c:	be c0 00 40 01       	mov    $0x14000c0,%esi
     791:	ba 06 00 00 00       	mov    $0x6,%edx
     796:	bf 00 c0 03 00       	mov    $0x3c000,%edi
     79b:	e8 00 00 00 00       	callq  7a0 <afs_ctr+0x50>
			79c: R_X86_64_PC32	kmalloc_order_trace-0x4
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:510
    afs_action(context, ret = -ENOMEM, err, "kmalloc failure [%d]", ret);
     7a0:	48 85 c0             	test   %rax,%rax
kmalloc_large():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:433
     7a3:	49 89 c4             	mov    %rax,%r12
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:510
     7a6:	0f 84 f0 06 00 00    	je     e9c <afs_ctr+0x74c>
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
     7ac:	31 f6                	xor    %esi,%esi
     7ae:	ba 00 c0 03 00       	mov    $0x3c000,%edx
     7b3:	48 89 c7             	mov    %rax,%rdi
     7b6:	e8 00 00 00 00       	callq  7bb <afs_ctr+0x6b>
			7b7: R_X86_64_PC32	memset-0x4
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:75
    afs_assert(argc >= 3, err, "not enough arguments");
     7bb:	41 83 fd 02          	cmp    $0x2,%r13d
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:512
    context->config.instance_size = instance_size;
     7bf:	4d 89 74 24 28       	mov    %r14,0x28(%r12)
/home/austen/programming/dm-afs/src/dm_afs.c:515
    args = &context->args;
     7c4:	4d 8d b4 24 20 20 00 	lea    0x2020(%r12),%r14
     7cb:	00 
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:75
    afs_assert(argc >= 3, err, "not enough arguments");
     7cc:	0f 86 ae 06 00 00    	jbe    e80 <afs_ctr+0x730>
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
     7d2:	31 c0                	xor    %eax,%eax
     7d4:	b9 1c 00 00 00       	mov    $0x1c,%ecx
     7d9:	4c 89 f7             	mov    %r14,%rdi
     7dc:	f3 48 ab             	rep stos %rax,%es:(%rdi)
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:79
    afs_assert(!kstrtou8(argv[TYPE], BASE_10, &args->instance_type), err, "instance type not integer");
     7df:	49 8d 94 24 00 21 00 	lea    0x2100(%r12),%rdx
     7e6:	00 
     7e7:	be 0a 00 00 00       	mov    $0xa,%esi
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
     7ec:	c6 07 00             	movb   $0x0,(%rdi)
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:79
     7ef:	48 8b 3b             	mov    (%rbx),%rdi
     7f2:	e8 00 00 00 00       	callq  7f7 <afs_ctr+0xa7>
			7f3: R_X86_64_PC32	kstrtou8-0x4
     7f7:	85 c0                	test   %eax,%eax
     7f9:	0f 85 91 07 00 00    	jne    f90 <afs_ctr+0x840>
strncpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:245
     7ff:	48 8b 73 08          	mov    0x8(%rbx),%rsi
     803:	ba 3f 00 00 00       	mov    $0x3f,%edx
     808:	4c 89 f7             	mov    %r14,%rdi
     80b:	e8 00 00 00 00       	callq  810 <afs_ctr+0xc0>
			80c: R_X86_64_PC32	strncpy-0x4
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:81
    strncpy(args->passive_dev, argv[DISK], PASSIVE_DEV_SZ - 1);
     810:	49 8d 84 24 a0 20 00 	lea    0x20a0(%r12),%rax
     817:	00 
strncpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:245
     818:	48 8b 73 10          	mov    0x10(%rbx),%rsi
     81c:	ba 1f 00 00 00       	mov    $0x1f,%edx
     821:	48 89 c7             	mov    %rax,%rdi
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:81
     824:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
strncpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:245
     828:	e8 00 00 00 00       	callq  82d <afs_ctr+0xdd>
			829: R_X86_64_PC32	strncpy-0x4
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:82
    afs_debug("Type: %d", args->instance_type);
     82d:	44 8b 1d 00 00 00 00 	mov    0x0(%rip),%r11d        # 834 <afs_ctr+0xe4>
			830: R_X86_64_PC32	afs_debug_mode-0x4
     834:	45 85 db             	test   %r11d,%r11d
     837:	0f 85 72 07 00 00    	jne    faf <afs_ctr+0x85f>
/home/austen/programming/dm-afs/src/dm_afs.c:88
    for (i = DISK + 1; i < argc; i++) {
     83d:	41 83 fd 03          	cmp    $0x3,%r13d
     841:	0f 84 ab 00 00 00    	je     8f2 <afs_ctr+0x1a2>
     847:	41 8d 45 fc          	lea    -0x4(%r13),%eax
     84b:	41 be 04 00 00 00    	mov    $0x4,%r14d
     851:	d1 e8                	shr    %eax
     853:	44 8d 7c 00 06       	lea    0x6(%rax,%rax,1),%r15d
     858:	eb 2b                	jmp    885 <afs_ctr+0x135>
/home/austen/programming/dm-afs/src/dm_afs.c:90
            afs_assert(++i < argc, err, "missing value [entropy source]");
     85a:	45 39 f5             	cmp    %r14d,%r13d
     85d:	0f 86 e9 05 00 00    	jbe    e4c <afs_ctr+0x6fc>
/home/austen/programming/dm-afs/src/dm_afs.c:91
            strncpy(args->entropy_dir, argv[i], ENTROPY_DIR_SZ - 1);
     863:	49 63 c6             	movslq %r14d,%rax
strncpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:245
     866:	49 8d bc 24 c0 20 00 	lea    0x20c0(%r12),%rdi
     86d:	00 
     86e:	ba 3f 00 00 00       	mov    $0x3f,%edx
     873:	48 8b 34 c3          	mov    (%rbx,%rax,8),%rsi
     877:	41 83 c6 02          	add    $0x2,%r14d
     87b:	e8 00 00 00 00       	callq  880 <afs_ctr+0x130>
			87c: R_X86_64_PC32	strncpy-0x4
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:88
    for (i = DISK + 1; i < argc; i++) {
     880:	45 39 f7             	cmp    %r14d,%r15d
     883:	74 6d                	je     8f2 <afs_ctr+0x1a2>
/home/austen/programming/dm-afs/src/dm_afs.c:89
        if (!strcmp(argv[i], "--entropy")) {
     885:	41 8d 46 ff          	lea    -0x1(%r14),%eax
     889:	b9 0a 00 00 00       	mov    $0xa,%ecx
     88e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			891: R_X86_64_32S	.rodata.str1.1
     895:	48 98                	cltq   
     897:	48 8b 14 c3          	mov    (%rbx,%rax,8),%rdx
     89b:	48 89 d6             	mov    %rdx,%rsi
     89e:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     8a0:	0f 97 c0             	seta   %al
     8a3:	1c 00                	sbb    $0x0,%al
     8a5:	84 c0                	test   %al,%al
     8a7:	74 b1                	je     85a <afs_ctr+0x10a>
/home/austen/programming/dm-afs/src/dm_afs.c:92
        } else if (!strcmp(argv[i], "--shadow_passphrase")) {
     8a9:	b9 14 00 00 00       	mov    $0x14,%ecx
     8ae:	48 89 d6             	mov    %rdx,%rsi
     8b1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			8b4: R_X86_64_32S	.rodata.str1.1+0xa
     8b8:	f3 a6                	repz cmpsb %es:(%rdi),%ds:(%rsi)
     8ba:	0f 97 c0             	seta   %al
     8bd:	1c 00                	sbb    $0x0,%al
     8bf:	84 c0                	test   %al,%al
     8c1:	0f 85 47 05 00 00    	jne    e0e <afs_ctr+0x6be>
/home/austen/programming/dm-afs/src/dm_afs.c:93
            afs_assert(++i < argc, err, "missing value [shadow passphrase]");
     8c7:	45 39 f5             	cmp    %r14d,%r13d
     8ca:	0f 86 96 05 00 00    	jbe    e66 <afs_ctr+0x716>
/home/austen/programming/dm-afs/src/dm_afs.c:94
            strncpy(args->shadow_passphrase, argv[i], PASSPHRASE_SZ - 1);
     8d0:	49 63 c6             	movslq %r14d,%rax
strncpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:245
     8d3:	49 8d bc 24 60 20 00 	lea    0x2060(%r12),%rdi
     8da:	00 
     8db:	ba 3f 00 00 00       	mov    $0x3f,%edx
     8e0:	48 8b 34 c3          	mov    (%rbx,%rax,8),%rsi
     8e4:	41 83 c6 02          	add    $0x2,%r14d
     8e8:	e8 00 00 00 00       	callq  8ed <afs_ctr+0x19d>
			8e9: R_X86_64_PC32	strncpy-0x4
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:88
    for (i = DISK + 1; i < argc; i++) {
     8ed:	45 39 f7             	cmp    %r14d,%r15d
     8f0:	75 93                	jne    885 <afs_ctr+0x135>
/home/austen/programming/dm-afs/src/dm_afs.c:99
    afs_debug("Entropy: %s", args->entropy_dir);
     8f2:	44 8b 15 00 00 00 00 	mov    0x0(%rip),%r10d        # 8f9 <afs_ctr+0x1a9>
			8f5: R_X86_64_PC32	afs_debug_mode-0x4
     8f9:	45 85 d2             	test   %r10d,%r10d
     8fc:	0f 85 6a 07 00 00    	jne    106c <afs_ctr+0x91c>
/home/austen/programming/dm-afs/src/dm_afs.c:104
    switch (args->instance_type) {
     902:	41 0f b6 84 24 00 21 	movzbl 0x2100(%r12),%eax
     909:	00 00 
     90b:	3c 01                	cmp    $0x1,%al
     90d:	0f 84 69 03 00 00    	je     c7c <afs_ctr+0x52c>
     913:	0f 82 63 02 00 00    	jb     b7c <afs_ctr+0x42c>
     919:	3c 02                	cmp    $0x2,%al
     91b:	0f 85 cb 05 00 00    	jne    eec <afs_ctr+0x79c>
/home/austen/programming/dm-afs/src/dm_afs.c:116
        afs_assert(args->entropy_dir[0] != 0, err, "entropy source not provided");
     921:	41 80 bc 24 c0 20 00 	cmpb   $0x0,0x20c0(%r12)
     928:	00 00 
     92a:	0f 84 db 05 00 00    	je     f0b <afs_ctr+0x7bb>
/home/austen/programming/dm-afs/src/dm_afs.c:117
        afs_assert(args->shadow_passphrase[0] != 0, err, "shadow passphrase not provided");
     930:	41 80 bc 24 60 20 00 	cmpb   $0x0,0x2060(%r12)
     937:	00 00 
     939:	0f 84 eb 05 00 00    	je     f2a <afs_ctr+0x7da>
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:521
    ret = dm_get_device(ti, args->passive_dev, dm_table_get_mode(ti->table), &context->passive_dev);
     93f:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
     943:	48 8b 3b             	mov    (%rbx),%rdi
     946:	e8 00 00 00 00       	callq  94b <afs_ctr+0x1fb>
			947: R_X86_64_PC32	dm_table_get_mode-0x4
     94b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
     94f:	48 89 df             	mov    %rbx,%rdi
     952:	4c 89 e1             	mov    %r12,%rcx
     955:	89 c2                	mov    %eax,%edx
     957:	e8 00 00 00 00       	callq  95c <afs_ctr+0x20c>
			958: R_X86_64_PC32	dm_get_device-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:522
    afs_assert(!ret, args_err, "could not find given disk [%s]", args->passive_dev);
     95c:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:521
    ret = dm_get_device(ti, args->passive_dev, dm_table_get_mode(ti->table), &context->passive_dev);
     95e:	89 c3                	mov    %eax,%ebx
/home/austen/programming/dm-afs/src/dm_afs.c:522
    afs_assert(!ret, args_err, "could not find given disk [%s]", args->passive_dev);
     960:	0f 85 e3 05 00 00    	jne    f49 <afs_ctr+0x7f9>
/home/austen/programming/dm-afs/src/dm_afs.c:523
    context->bdev = context->passive_dev->bdev;
     966:	49 8b 04 24          	mov    (%r12),%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
     96a:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 971 <afs_ctr+0x221>
			96d: R_X86_64_PC32	kmalloc_caches+0x5c
     971:	ba 00 10 00 00       	mov    $0x1000,%edx
     976:	be c0 00 40 01       	mov    $0x14000c0,%esi
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:526
    fs = &context->passive_fs;
     97b:	4d 8d b4 24 00 20 00 	lea    0x2000(%r12),%r14
     982:	00 
/home/austen/programming/dm-afs/src/dm_afs.c:523
    context->bdev = context->passive_dev->bdev;
     983:	4c 8b 28             	mov    (%rax),%r13
     986:	4d 89 6c 24 08       	mov    %r13,0x8(%r12)
/home/austen/programming/dm-afs/src/dm_afs.c:524
    context->config.bdev_size = context->bdev->bd_part->nr_sects;
     98b:	49 8b 45 70          	mov    0x70(%r13),%rax
     98f:	48 8b 40 08          	mov    0x8(%rax),%rax
     993:	49 89 44 24 30       	mov    %rax,0x30(%r12)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
     998:	e8 00 00 00 00       	callq  99d <afs_ctr+0x24d>
			999: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
detect_fs():
/home/austen/programming/dm-afs/src/dm_afs.c:32
    afs_action(page, ret = -ENOMEM, alloc_err, "could not allocate page [%d]", ret);
     99d:	48 85 c0             	test   %rax,%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
     9a0:	48 89 c3             	mov    %rax,%rbx
detect_fs():
/home/austen/programming/dm-afs/src/dm_afs.c:32
     9a3:	0f 84 c3 05 00 00    	je     f6c <afs_ctr+0x81c>
/home/austen/programming/dm-afs/src/dm_afs.c:33
    ret = read_page(page, device, 0, 0, false);
     9a9:	45 31 c0             	xor    %r8d,%r8d
     9ac:	31 c9                	xor    %ecx,%ecx
     9ae:	31 d2                	xor    %edx,%edx
     9b0:	4c 89 ee             	mov    %r13,%rsi
     9b3:	48 89 c7             	mov    %rax,%rdi
     9b6:	e8 00 00 00 00       	callq  9bb <afs_ctr+0x26b>
			9b7: R_X86_64_PC32	read_page-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:34
    afs_assert(!ret, read_err, "could not read page [%d]", ret);
     9bb:	84 c0                	test   %al,%al
     9bd:	0f 85 ff 06 00 00    	jne    10c2 <afs_ctr+0x972>
/home/austen/programming/dm-afs/src/dm_afs.c:39
    if (afs_fat32_detect(page, device, fs)) {
     9c3:	4c 89 f2             	mov    %r14,%rdx
     9c6:	4c 89 ee             	mov    %r13,%rsi
     9c9:	48 89 df             	mov    %rbx,%rdi
     9cc:	e8 00 00 00 00       	callq  9d1 <afs_ctr+0x281>
			9cd: R_X86_64_PC32	afs_fat32_detect-0x4
     9d1:	84 c0                	test   %al,%al
     9d3:	0f 84 2b 02 00 00    	je     c04 <afs_ctr+0x4b4>
/home/austen/programming/dm-afs/src/dm_afs.c:48
    kfree(page);
     9d9:	48 89 df             	mov    %rbx,%rdi
     9dc:	e8 00 00 00 00       	callq  9e1 <afs_ctr+0x291>
			9dd: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:50
    afs_debug("detected %d", ret);
     9e1:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 9e7 <afs_ctr+0x297>
			9e3: R_X86_64_PC32	afs_debug_mode-0x4
     9e7:	85 f6                	test   %esi,%esi
     9e9:	0f 85 fd 06 00 00    	jne    10ec <afs_ctr+0x99c>
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:562
    context->vector.vector = bit_vector_create((uint64_t)U32_MAX);
     9ef:	bf ff ff ff ff       	mov    $0xffffffff,%edi
     9f4:	e8 00 00 00 00       	callq  9f9 <afs_ctr+0x2a9>
			9f5: R_X86_64_PC32	bit_vector_create-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:563
    afs_action(context->vector.vector, ret = -ENOMEM, vec_err, "could not allocate allocation vector");
     9f9:	48 85 c0             	test   %rax,%rax
/home/austen/programming/dm-afs/src/dm_afs.c:562
    context->vector.vector = bit_vector_create((uint64_t)U32_MAX);
     9fc:	49 89 84 24 08 21 00 	mov    %rax,0x2108(%r12)
     a03:	00 
/home/austen/programming/dm-afs/src/dm_afs.c:563
    afs_action(context->vector.vector, ret = -ENOMEM, vec_err, "could not allocate allocation vector");
     a04:	0f 84 2a 07 00 00    	je     1134 <afs_ctr+0x9e4>
/home/austen/programming/dm-afs/src/dm_afs.c:565
    allocation_set(&context->vector, AFS_INVALID_BLOCK);
     a0a:	49 8d bc 24 08 21 00 	lea    0x2108(%r12),%rdi
     a11:	00 
     a12:	be ff ff ff ff       	mov    $0xffffffff,%esi
/home/austen/programming/dm-afs/src/dm_afs.c:564
    spin_lock_init(&context->vector.lock);
     a17:	41 c7 84 24 10 21 00 	movl   $0x0,0x2110(%r12)
     a1e:	00 00 00 00 00 
/home/austen/programming/dm-afs/src/dm_afs.c:567
    sb = &context->super_block;
     a23:	49 8d 9c 24 00 10 00 	lea    0x1000(%r12),%rbx
     a2a:	00 
/home/austen/programming/dm-afs/src/dm_afs.c:565
    allocation_set(&context->vector, AFS_INVALID_BLOCK);
     a2b:	e8 00 00 00 00       	callq  a30 <afs_ctr+0x2e0>
			a2c: R_X86_64_PC32	allocation_set-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:568
    switch (args->instance_type) {
     a30:	41 0f b6 84 24 00 21 	movzbl 0x2100(%r12),%eax
     a37:	00 00 
     a39:	84 c0                	test   %al,%al
     a3b:	0f 84 78 01 00 00    	je     bb9 <afs_ctr+0x469>
     a41:	3c 01                	cmp    $0x1,%al
     a43:	75 15                	jne    a5a <afs_ctr+0x30a>
/home/austen/programming/dm-afs/src/dm_afs.c:577
        ret = find_super_block(sb, context);
     a45:	48 89 df             	mov    %rbx,%rdi
     a48:	4c 89 e6             	mov    %r12,%rsi
     a4b:	e8 00 00 00 00       	callq  a50 <afs_ctr+0x300>
			a4c: R_X86_64_PC32	find_super_block-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:578
        afs_assert(!ret, sb_err, "could not find super block [%d]", ret);
     a50:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:577
        ret = find_super_block(sb, context);
     a52:	89 c3                	mov    %eax,%ebx
/home/austen/programming/dm-afs/src/dm_afs.c:578
        afs_assert(!ret, sb_err, "could not find super block [%d]", ret);
     a54:	0f 85 3a 07 00 00    	jne    1194 <afs_ctr+0xa44>
/home/austen/programming/dm-afs/src/dm_afs.c:587
    context->ground_wq = alloc_workqueue("%s", WQ_UNBOUND | WQ_HIGHPRI, 1, "Artifice Ground WQ");
     a5a:	45 31 c0             	xor    %r8d,%r8d
     a5d:	31 c9                	xor    %ecx,%ecx
     a5f:	31 c0                	xor    %eax,%eax
     a61:	49 c7 c1 00 00 00 00 	mov    $0x0,%r9
			a64: R_X86_64_32S	.rodata.str1.1+0x1e
     a68:	ba 01 00 00 00       	mov    $0x1,%edx
     a6d:	be 12 00 00 00       	mov    $0x12,%esi
     a72:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a75: R_X86_64_32S	.rodata.str1.1+0x31
     a79:	e8 00 00 00 00       	callq  a7e <afs_ctr+0x32e>
			a7a: R_X86_64_PC32	__alloc_workqueue_key-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:588
    afs_action(!IS_ERR(context->ground_wq), ret = PTR_ERR(context->ground_wq), gwq_err, "could not create gwq [%d]", ret);
     a7e:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
/home/austen/programming/dm-afs/src/dm_afs.c:587
    context->ground_wq = alloc_workqueue("%s", WQ_UNBOUND | WQ_HIGHPRI, 1, "Artifice Ground WQ");
     a84:	49 89 84 24 00 b0 03 	mov    %rax,0x3b000(%r12)
     a8b:	00 
/home/austen/programming/dm-afs/src/dm_afs.c:588
    afs_action(!IS_ERR(context->ground_wq), ret = PTR_ERR(context->ground_wq), gwq_err, "could not create gwq [%d]", ret);
     a8c:	0f 87 77 02 00 00    	ja     d09 <afs_ctr+0x5b9>
/home/austen/programming/dm-afs/src/dm_afs.c:590
    context->flight_wq = alloc_workqueue("%s", WQ_UNBOUND | WQ_HIGHPRI | WQ_CPU_INTENSIVE, 1, "Artifice Flight WQ");
     a92:	45 31 c0             	xor    %r8d,%r8d
     a95:	31 c9                	xor    %ecx,%ecx
     a97:	31 c0                	xor    %eax,%eax
     a99:	49 c7 c1 00 00 00 00 	mov    $0x0,%r9
			a9c: R_X86_64_32S	.rodata.str1.1+0x34
     aa0:	ba 01 00 00 00       	mov    $0x1,%edx
     aa5:	be 32 00 00 00       	mov    $0x32,%esi
     aaa:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			aad: R_X86_64_32S	.rodata.str1.1+0x31
     ab1:	e8 00 00 00 00       	callq  ab6 <afs_ctr+0x366>
			ab2: R_X86_64_PC32	__alloc_workqueue_key-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:591
    afs_action(!IS_ERR(context->flight_wq), ret = PTR_ERR(context->flight_wq), fwq_err, "could not create fwq [%d]", ret);
     ab6:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
/home/austen/programming/dm-afs/src/dm_afs.c:590
    context->flight_wq = alloc_workqueue("%s", WQ_UNBOUND | WQ_HIGHPRI | WQ_CPU_INTENSIVE, 1, "Artifice Flight WQ");
     abc:	49 89 84 24 08 b0 03 	mov    %rax,0x3b008(%r12)
     ac3:	00 
/home/austen/programming/dm-afs/src/dm_afs.c:591
    afs_action(!IS_ERR(context->flight_wq), ret = PTR_ERR(context->flight_wq), fwq_err, "could not create fwq [%d]", ret);
     ac4:	0f 87 b3 02 00 00    	ja     d7d <afs_ctr+0x62d>
/home/austen/programming/dm-afs/src/dm_afs.c:593
    INIT_WORK(&context->ground_ws, afs_groundq);
     aca:	48 b8 e0 ff ff ff 0f 	movabs $0xfffffffe0,%rax
     ad1:	00 00 00 
     ad4:	49 8d 94 24 18 b0 03 	lea    0x3b018(%r12),%rdx
     adb:	00 
/home/austen/programming/dm-afs/src/dm_afs.c:596
    afs_eq_init(&context->ground_eq);
     adc:	49 8d bc 24 00 30 00 	lea    0x3000(%r12),%rdi
     ae3:	00 
/home/austen/programming/dm-afs/src/dm_afs.c:593
    INIT_WORK(&context->ground_ws, afs_groundq);
     ae4:	49 89 84 24 10 b0 03 	mov    %rax,0x3b010(%r12)
     aeb:	00 
/home/austen/programming/dm-afs/src/dm_afs.c:594
    INIT_WORK(&context->clean_ws, afs_cleanq);
     aec:	49 89 84 24 30 b0 03 	mov    %rax,0x3b030(%r12)
     af3:	00 
     af4:	49 8d 84 24 38 b0 03 	lea    0x3b038(%r12),%rax
     afb:	00 
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
     afc:	49 89 94 24 18 b0 03 	mov    %rdx,0x3b018(%r12)
     b03:	00 
INIT_LIST_HEAD():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:29
     b04:	49 89 94 24 20 b0 03 	mov    %rdx,0x3b020(%r12)
     b0b:	00 
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
     b0c:	49 89 84 24 38 b0 03 	mov    %rax,0x3b038(%r12)
     b13:	00 
INIT_LIST_HEAD():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:29
     b14:	49 89 84 24 40 b0 03 	mov    %rax,0x3b040(%r12)
     b1b:	00 
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:593
    INIT_WORK(&context->ground_ws, afs_groundq);
     b1c:	49 c7 84 24 28 b0 03 	movq   $0x0,0x3b028(%r12)
     b23:	00 00 00 00 00 
			b24: R_X86_64_32S	.text+0x2e0
/home/austen/programming/dm-afs/src/dm_afs.c:594
    INIT_WORK(&context->clean_ws, afs_cleanq);
     b28:	49 c7 84 24 48 b0 03 	movq   $0x0,0x3b048(%r12)
     b2f:	00 00 00 00 00 
			b30: R_X86_64_32S	.text
/home/austen/programming/dm-afs/src/dm_afs.c:596
    afs_eq_init(&context->ground_eq);
     b34:	e8 00 00 00 00       	callq  b39 <afs_ctr+0x3e9>
			b35: R_X86_64_PC32	afs_eq_init-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:597
    afs_eq_init(&context->flight_eq);
     b39:	49 8d bc 24 00 f0 01 	lea    0x1f000(%r12),%rdi
     b40:	00 
     b41:	e8 00 00 00 00       	callq  b46 <afs_ctr+0x3f6>
			b42: R_X86_64_PC32	afs_eq_init-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:600
    ret = cauchy_init();
     b46:	e8 00 00 00 00       	callq  b4b <afs_ctr+0x3fb>
			b47: R_X86_64_PC32	cauchy_init-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:601
    afs_assert(!ret, encode_err, "could not initialize encoding library [%d]", ret);
     b4b:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:600
    ret = cauchy_init();
     b4d:	89 c3                	mov    %eax,%ebx
/home/austen/programming/dm-afs/src/dm_afs.c:601
    afs_assert(!ret, encode_err, "could not initialize encoding library [%d]", ret);
     b4f:	0f 85 d7 04 00 00    	jne    102c <afs_ctr+0x8dc>
/home/austen/programming/dm-afs/src/dm_afs.c:606
    afs_debug("constructor completed");
     b55:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # b5b <afs_ctr+0x40b>
			b57: R_X86_64_PC32	afs_debug_mode-0x4
     b5b:	85 c9                	test   %ecx,%ecx
     b5d:	0f 85 f3 05 00 00    	jne    1156 <afs_ctr+0xa06>
/home/austen/programming/dm-afs/src/dm_afs.c:607
    ti->private = context;
     b63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
     b67:	4c 89 60 40          	mov    %r12,0x40(%rax)
/home/austen/programming/dm-afs/src/dm_afs.c:634
}
     b6b:	48 83 c4 18          	add    $0x18,%rsp
     b6f:	89 d8                	mov    %ebx,%eax
     b71:	5b                   	pop    %rbx
     b72:	41 5c                	pop    %r12
     b74:	41 5d                	pop    %r13
     b76:	41 5e                	pop    %r14
     b78:	41 5f                	pop    %r15
     b7a:	5d                   	pop    %rbp
     b7b:	c3                   	retq   
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:106
        afs_assert(args->entropy_dir[0] != 0, err, "entropy source not provided");
     b7c:	41 80 bc 24 c0 20 00 	cmpb   $0x0,0x20c0(%r12)
     b83:	00 00 
     b85:	0f 84 ea 05 00 00    	je     1175 <afs_ctr+0xa25>
/home/austen/programming/dm-afs/src/dm_afs.c:107
        afs_assert(args->shadow_passphrase[0] == 0, err, "shadow passphrase provided");
     b8b:	41 80 bc 24 60 20 00 	cmpb   $0x0,0x2060(%r12)
     b92:	00 00 
     b94:	0f 84 a5 fd ff ff    	je     93f <afs_ctr+0x1ef>
     b9a:	ba 6b 00 00 00       	mov    $0x6b,%edx
     b9f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			ba2: R_X86_64_32S	.rodata+0x20
     ba6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			ba9: R_X86_64_32S	.rodata.str1.8+0x490
     bad:	31 c0                	xor    %eax,%eax
     baf:	e8 00 00 00 00       	callq  bb4 <afs_ctr+0x464>
			bb0: R_X86_64_PC32	printk-0x4
     bb4:	e9 6f 02 00 00       	jmpq   e28 <afs_ctr+0x6d8>
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:571
        build_configuration(context, 4, 1);
     bb9:	ba 01 00 00 00       	mov    $0x1,%edx
     bbe:	be 04 00 00 00       	mov    $0x4,%esi
     bc3:	4c 89 e7             	mov    %r12,%rdi
     bc6:	e8 00 00 00 00       	callq  bcb <afs_ctr+0x47b>
			bc7: R_X86_64_PC32	build_configuration-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:572
        ret = write_super_block(sb, fs, context);
     bcb:	48 89 df             	mov    %rbx,%rdi
     bce:	4c 89 e2             	mov    %r12,%rdx
     bd1:	4c 89 f6             	mov    %r14,%rsi
     bd4:	e8 00 00 00 00       	callq  bd9 <afs_ctr+0x489>
			bd5: R_X86_64_PC32	write_super_block-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:573
        afs_assert(!ret, sb_err, "could not write super block [%d]", ret);
     bd9:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:572
        ret = write_super_block(sb, fs, context);
     bdb:	89 c3                	mov    %eax,%ebx
/home/austen/programming/dm-afs/src/dm_afs.c:573
        afs_assert(!ret, sb_err, "could not write super block [%d]", ret);
     bdd:	0f 84 77 fe ff ff    	je     a5a <afs_ctr+0x30a>
/home/austen/programming/dm-afs/src/dm_afs.c:573 (discriminator 1)
     be3:	89 c1                	mov    %eax,%ecx
     be5:	ba 3d 02 00 00       	mov    $0x23d,%edx
     bea:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			bed: R_X86_64_32S	.rodata+0x40
     bf1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			bf4: R_X86_64_32S	.rodata.str1.8+0x710
     bf8:	31 c0                	xor    %eax,%eax
     bfa:	e8 00 00 00 00       	callq  bff <afs_ctr+0x4af>
			bfb: R_X86_64_PC32	printk-0x4
     bff:	e9 3d 01 00 00       	jmpq   d41 <afs_ctr+0x5f1>
detect_fs():
/home/austen/programming/dm-afs/src/dm_afs.c:41
    } else if (afs_ext4_detect(page, device, fs)) {
     c04:	4c 89 f2             	mov    %r14,%rdx
     c07:	4c 89 ee             	mov    %r13,%rsi
     c0a:	48 89 df             	mov    %rbx,%rdi
     c0d:	e8 00 00 00 00       	callq  c12 <afs_ctr+0x4c2>
			c0e: R_X86_64_PC32	afs_ext4_detect-0x4
     c12:	84 c0                	test   %al,%al
     c14:	0f 84 9f 00 00 00    	je     cb9 <afs_ctr+0x569>
/home/austen/programming/dm-afs/src/dm_afs.c:48
    kfree(page);
     c1a:	48 89 df             	mov    %rbx,%rdi
     c1d:	e8 00 00 00 00       	callq  c22 <afs_ctr+0x4d2>
			c1e: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:50
    afs_debug("detected %d", ret);
     c22:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # c28 <afs_ctr+0x4d8>
			c24: R_X86_64_PC32	afs_debug_mode-0x4
     c28:	85 ff                	test   %edi,%edi
     c2a:	0f 84 bf fd ff ff    	je     9ef <afs_ctr+0x29f>
     c30:	ba 32 00 00 00       	mov    $0x32,%edx
     c35:	31 c0                	xor    %eax,%eax
     c37:	b9 01 00 00 00       	mov    $0x1,%ecx
     c3c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			c3f: R_X86_64_32S	.rodata+0x10
     c43:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			c46: R_X86_64_32S	.rodata.str1.8+0x878
     c4a:	e8 00 00 00 00       	callq  c4f <afs_ctr+0x4ff>
			c4b: R_X86_64_PC32	printk-0x4
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:538
        afs_debug("detected EXT4");
     c4f:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # c55 <afs_ctr+0x505>
			c51: R_X86_64_PC32	afs_debug_mode-0x4
     c55:	85 d2                	test   %edx,%edx
     c57:	0f 84 92 fd ff ff    	je     9ef <afs_ctr+0x29f>
/home/austen/programming/dm-afs/src/dm_afs.c:538 (discriminator 1)
     c5d:	ba 1a 02 00 00       	mov    $0x21a,%edx
     c62:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			c65: R_X86_64_32S	.rodata+0x40
     c69:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			c6c: R_X86_64_32S	.rodata.str1.8+0x6a8
     c70:	31 c0                	xor    %eax,%eax
     c72:	e8 00 00 00 00       	callq  c77 <afs_ctr+0x527>
			c73: R_X86_64_PC32	printk-0x4
     c77:	e9 73 fd ff ff       	jmpq   9ef <afs_ctr+0x29f>
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:111
        afs_assert(args->entropy_dir[0] == 0, err, "entropy source provided");
     c7c:	41 80 bc 24 c0 20 00 	cmpb   $0x0,0x20c0(%r12)
     c83:	00 00 
     c85:	0f 85 c2 03 00 00    	jne    104d <afs_ctr+0x8fd>
/home/austen/programming/dm-afs/src/dm_afs.c:112
        afs_assert(args->shadow_passphrase[0] == 0, err, "shadow passphrase provided");
     c8b:	41 80 bc 24 60 20 00 	cmpb   $0x0,0x2060(%r12)
     c92:	00 00 
     c94:	0f 84 a5 fc ff ff    	je     93f <afs_ctr+0x1ef>
     c9a:	ba 70 00 00 00       	mov    $0x70,%edx
     c9f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			ca2: R_X86_64_32S	.rodata+0x20
     ca6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			ca9: R_X86_64_32S	.rodata.str1.8+0x490
     cad:	31 c0                	xor    %eax,%eax
     caf:	e8 00 00 00 00       	callq  cb4 <afs_ctr+0x564>
			cb0: R_X86_64_PC32	printk-0x4
     cb4:	e9 6f 01 00 00       	jmpq   e28 <afs_ctr+0x6d8>
detect_fs():
/home/austen/programming/dm-afs/src/dm_afs.c:43
    } else if (afs_ntfs_detect(page, device, fs)) {
     cb9:	48 89 df             	mov    %rbx,%rdi
     cbc:	4c 89 f2             	mov    %r14,%rdx
     cbf:	4c 89 ee             	mov    %r13,%rsi
     cc2:	e8 00 00 00 00       	callq  cc7 <afs_ctr+0x577>
			cc3: R_X86_64_PC32	afs_ntfs_detect-0x4
     cc7:	84 c0                	test   %al,%al
/home/austen/programming/dm-afs/src/dm_afs.c:48
    kfree(page);
     cc9:	48 89 df             	mov    %rbx,%rdi
/home/austen/programming/dm-afs/src/dm_afs.c:43
    } else if (afs_ntfs_detect(page, device, fs)) {
     ccc:	0f 85 db 00 00 00    	jne    dad <afs_ctr+0x65d>
/home/austen/programming/dm-afs/src/dm_afs.c:48
    kfree(page);
     cd2:	e8 00 00 00 00       	callq  cd7 <afs_ctr+0x587>
			cd3: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:50
    afs_debug("detected %d", ret);
     cd7:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # cde <afs_ctr+0x58e>
			cda: R_X86_64_PC32	afs_debug_mode-0x4
     cde:	45 85 c9             	test   %r9d,%r9d
     ce1:	0f 84 08 fd ff ff    	je     9ef <afs_ctr+0x29f>
     ce7:	83 c9 ff             	or     $0xffffffff,%ecx
     cea:	ba 32 00 00 00       	mov    $0x32,%edx
     cef:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			cf2: R_X86_64_32S	.rodata+0x10
     cf6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			cf9: R_X86_64_32S	.rodata.str1.8+0x878
     cfd:	31 c0                	xor    %eax,%eax
     cff:	e8 00 00 00 00       	callq  d04 <afs_ctr+0x5b4>
			d00: R_X86_64_PC32	printk-0x4
     d04:	e9 e6 fc ff ff       	jmpq   9ef <afs_ctr+0x29f>
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:588 (discriminator 1)
    afs_action(!IS_ERR(context->ground_wq), ret = PTR_ERR(context->ground_wq), gwq_err, "could not create gwq [%d]", ret);
     d09:	89 c3                	mov    %eax,%ebx
     d0b:	89 c1                	mov    %eax,%ecx
     d0d:	ba 4c 02 00 00       	mov    $0x24c,%edx
     d12:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			d15: R_X86_64_32S	.rodata+0x40
     d19:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			d1c: R_X86_64_32S	.rodata.str1.8+0x790
     d20:	31 c0                	xor    %eax,%eax
     d22:	e8 00 00 00 00       	callq  d27 <afs_ctr+0x5d7>
			d23: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:614
    kfree(context->afs_ptr_blocks);
     d27:	49 8b bc 24 60 b0 03 	mov    0x3b060(%r12),%rdi
     d2e:	00 
     d2f:	e8 00 00 00 00       	callq  d34 <afs_ctr+0x5e4>
			d30: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:615
    vfree(context->afs_map);
     d34:	49 8b bc 24 50 b0 03 	mov    0x3b050(%r12),%rdi
     d3b:	00 
     d3c:	e8 00 00 00 00       	callq  d41 <afs_ctr+0x5f1>
			d3d: R_X86_64_PC32	vfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:618
    bit_vector_free(context->vector.vector);
     d41:	49 8b bc 24 08 21 00 	mov    0x2108(%r12),%rdi
     d48:	00 
     d49:	e8 00 00 00 00       	callq  d4e <afs_ctr+0x5fe>
			d4a: R_X86_64_PC32	bit_vector_free-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:621
    vfree(fs->block_list);
     d4e:	49 8b bc 24 00 20 00 	mov    0x2000(%r12),%rdi
     d55:	00 
     d56:	e8 00 00 00 00       	callq  d5b <afs_ctr+0x60b>
			d57: R_X86_64_PC32	vfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:624
    dm_put_device(ti, context->passive_dev);
     d5b:	49 8b 34 24          	mov    (%r12),%rsi
     d5f:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
     d63:	e8 00 00 00 00       	callq  d68 <afs_ctr+0x618>
			d64: R_X86_64_PC32	dm_put_device-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:627
    kfree(context);
     d68:	4c 89 e7             	mov    %r12,%rdi
     d6b:	e8 00 00 00 00       	callq  d70 <afs_ctr+0x620>
			d6c: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:630
    kfree(context);
     d70:	4c 89 e7             	mov    %r12,%rdi
     d73:	e8 00 00 00 00       	callq  d78 <afs_ctr+0x628>
			d74: R_X86_64_PC32	kfree-0x4
     d78:	e9 ee fd ff ff       	jmpq   b6b <afs_ctr+0x41b>
/home/austen/programming/dm-afs/src/dm_afs.c:591 (discriminator 1)
    afs_action(!IS_ERR(context->flight_wq), ret = PTR_ERR(context->flight_wq), fwq_err, "could not create fwq [%d]", ret);
     d7d:	89 c1                	mov    %eax,%ecx
     d7f:	89 c3                	mov    %eax,%ebx
     d81:	ba 4f 02 00 00       	mov    $0x24f,%edx
     d86:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			d89: R_X86_64_32S	.rodata+0x40
     d8d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			d90: R_X86_64_32S	.rodata.str1.8+0x7c8
     d94:	31 c0                	xor    %eax,%eax
     d96:	e8 00 00 00 00       	callq  d9b <afs_ctr+0x64b>
			d97: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:611 (discriminator 1)
    destroy_workqueue(context->ground_wq);
     d9b:	49 8b bc 24 00 b0 03 	mov    0x3b000(%r12),%rdi
     da2:	00 
     da3:	e8 00 00 00 00       	callq  da8 <afs_ctr+0x658>
			da4: R_X86_64_PC32	destroy_workqueue-0x4
     da8:	e9 7a ff ff ff       	jmpq   d27 <afs_ctr+0x5d7>
detect_fs():
/home/austen/programming/dm-afs/src/dm_afs.c:48
    kfree(page);
     dad:	e8 00 00 00 00       	callq  db2 <afs_ctr+0x662>
			dae: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:50
    afs_debug("detected %d", ret);
     db2:	44 8b 05 00 00 00 00 	mov    0x0(%rip),%r8d        # db9 <afs_ctr+0x669>
			db5: R_X86_64_PC32	afs_debug_mode-0x4
     db9:	45 85 c0             	test   %r8d,%r8d
     dbc:	0f 84 2d fc ff ff    	je     9ef <afs_ctr+0x29f>
     dc2:	31 c0                	xor    %eax,%eax
     dc4:	b9 02 00 00 00       	mov    $0x2,%ecx
     dc9:	ba 32 00 00 00       	mov    $0x32,%edx
     dce:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			dd1: R_X86_64_32S	.rodata+0x10
     dd5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			dd8: R_X86_64_32S	.rodata.str1.8+0x878
     ddc:	e8 00 00 00 00       	callq  de1 <afs_ctr+0x691>
			ddd: R_X86_64_PC32	printk-0x4
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:534
        afs_debug("detected NTFS");
     de1:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # de7 <afs_ctr+0x697>
			de3: R_X86_64_PC32	afs_debug_mode-0x4
     de7:	85 c0                	test   %eax,%eax
     de9:	0f 84 00 fc ff ff    	je     9ef <afs_ctr+0x29f>
/home/austen/programming/dm-afs/src/dm_afs.c:534 (discriminator 1)
     def:	ba 16 02 00 00       	mov    $0x216,%edx
     df4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			df7: R_X86_64_32S	.rodata+0x40
     dfb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			dfe: R_X86_64_32S	.rodata.str1.8+0x680
     e02:	31 c0                	xor    %eax,%eax
     e04:	e8 00 00 00 00       	callq  e09 <afs_ctr+0x6b9>
			e05: R_X86_64_PC32	printk-0x4
     e09:	e9 e1 fb ff ff       	jmpq   9ef <afs_ctr+0x29f>
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:96
            afs_assert(0, err, "unknown argument");
     e0e:	ba 60 00 00 00       	mov    $0x60,%edx
     e13:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			e16: R_X86_64_32S	.rodata+0x20
     e1a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			e1d: R_X86_64_32S	.rodata.str1.8+0x3d0
     e21:	31 c0                	xor    %eax,%eax
     e23:	e8 00 00 00 00       	callq  e28 <afs_ctr+0x6d8>
			e24: R_X86_64_PC32	printk-0x4
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:517 (discriminator 1)
    afs_assert(!ret, args_err, "unable to parse arguments");
     e28:	ba 05 02 00 00       	mov    $0x205,%edx
     e2d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			e30: R_X86_64_32S	.rodata+0x40
     e34:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			e37: R_X86_64_32S	.rodata.str1.8+0x578
     e3b:	31 c0                	xor    %eax,%eax
     e3d:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
     e42:	e8 00 00 00 00       	callq  e47 <afs_ctr+0x6f7>
			e43: R_X86_64_PC32	printk-0x4
     e47:	e9 1c ff ff ff       	jmpq   d68 <afs_ctr+0x618>
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:90
            afs_assert(++i < argc, err, "missing value [entropy source]");
     e4c:	ba 5a 00 00 00       	mov    $0x5a,%edx
     e51:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			e54: R_X86_64_32S	.rodata+0x20
     e58:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			e5b: R_X86_64_32S	.rodata.str1.8+0x358
     e5f:	e8 00 00 00 00       	callq  e64 <afs_ctr+0x714>
			e60: R_X86_64_PC32	printk-0x4
     e64:	eb c2                	jmp    e28 <afs_ctr+0x6d8>
/home/austen/programming/dm-afs/src/dm_afs.c:93
            afs_assert(++i < argc, err, "missing value [shadow passphrase]");
     e66:	ba 5d 00 00 00       	mov    $0x5d,%edx
     e6b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			e6e: R_X86_64_32S	.rodata+0x20
     e72:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			e75: R_X86_64_32S	.rodata.str1.8+0x390
     e79:	e8 00 00 00 00       	callq  e7e <afs_ctr+0x72e>
			e7a: R_X86_64_PC32	printk-0x4
     e7e:	eb a8                	jmp    e28 <afs_ctr+0x6d8>
/home/austen/programming/dm-afs/src/dm_afs.c:75
    afs_assert(argc >= 3, err, "not enough arguments");
     e80:	ba 4b 00 00 00       	mov    $0x4b,%edx
     e85:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			e88: R_X86_64_32S	.rodata+0x20
     e8c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			e8f: R_X86_64_32S	.rodata.str1.8+0x278
     e93:	31 c0                	xor    %eax,%eax
     e95:	e8 00 00 00 00       	callq  e9a <afs_ctr+0x74a>
			e96: R_X86_64_PC32	printk-0x4
     e9a:	eb 8c                	jmp    e28 <afs_ctr+0x6d8>
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:510 (discriminator 1)
    afs_action(context, ret = -ENOMEM, err, "kmalloc failure [%d]", ret);
     e9c:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
     ea1:	ba fe 01 00 00       	mov    $0x1fe,%edx
     ea6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			ea9: R_X86_64_32S	.rodata+0x40
     ead:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			eb0: R_X86_64_32S	.rodata.str1.8+0x248
     eb4:	31 c0                	xor    %eax,%eax
     eb6:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
     ebb:	e8 00 00 00 00       	callq  ec0 <afs_ctr+0x770>
			ebc: R_X86_64_PC32	printk-0x4
     ec0:	e9 a6 fc ff ff       	jmpq   b6b <afs_ctr+0x41b>
/home/austen/programming/dm-afs/src/dm_afs.c:503 (discriminator 1)
    afs_action(instance_size >= AFS_MIN_SIZE, ret = -EINVAL, err, "instance too small [%llu]", instance_size);
     ec5:	4c 89 f1             	mov    %r14,%rcx
     ec8:	ba f7 01 00 00       	mov    $0x1f7,%edx
     ecd:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			ed0: R_X86_64_32S	.rodata+0x40
     ed4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			ed7: R_X86_64_32S	.rodata.str1.8+0x210
     edb:	31 c0                	xor    %eax,%eax
     edd:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
     ee2:	e8 00 00 00 00       	callq  ee7 <afs_ctr+0x797>
			ee3: R_X86_64_PC32	printk-0x4
     ee7:	e9 7f fc ff ff       	jmpq   b6b <afs_ctr+0x41b>
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:121
        afs_assert(0, err, "unknown type of instance chosen");
     eec:	ba 79 00 00 00       	mov    $0x79,%edx
     ef1:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			ef4: R_X86_64_32S	.rodata+0x20
     ef8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			efb: R_X86_64_32S	.rodata.str1.8+0x538
     eff:	31 c0                	xor    %eax,%eax
     f01:	e8 00 00 00 00       	callq  f06 <afs_ctr+0x7b6>
			f02: R_X86_64_PC32	printk-0x4
     f06:	e9 1d ff ff ff       	jmpq   e28 <afs_ctr+0x6d8>
/home/austen/programming/dm-afs/src/dm_afs.c:116
        afs_assert(args->entropy_dir[0] != 0, err, "entropy source not provided");
     f0b:	ba 74 00 00 00       	mov    $0x74,%edx
     f10:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			f13: R_X86_64_32S	.rodata+0x20
     f17:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			f1a: R_X86_64_32S	.rodata.str1.8+0x458
     f1e:	31 c0                	xor    %eax,%eax
     f20:	e8 00 00 00 00       	callq  f25 <afs_ctr+0x7d5>
			f21: R_X86_64_PC32	printk-0x4
     f25:	e9 fe fe ff ff       	jmpq   e28 <afs_ctr+0x6d8>
/home/austen/programming/dm-afs/src/dm_afs.c:117
        afs_assert(args->shadow_passphrase[0] != 0, err, "shadow passphrase not provided");
     f2a:	ba 75 00 00 00       	mov    $0x75,%edx
     f2f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			f32: R_X86_64_32S	.rodata+0x20
     f36:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			f39: R_X86_64_32S	.rodata.str1.8+0x500
     f3d:	31 c0                	xor    %eax,%eax
     f3f:	e8 00 00 00 00       	callq  f44 <afs_ctr+0x7f4>
			f40: R_X86_64_PC32	printk-0x4
     f44:	e9 df fe ff ff       	jmpq   e28 <afs_ctr+0x6d8>
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:522 (discriminator 1)
    afs_assert(!ret, args_err, "could not find given disk [%s]", args->passive_dev);
     f49:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
     f4d:	ba 0a 02 00 00       	mov    $0x20a,%edx
     f52:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			f55: R_X86_64_32S	.rodata+0x40
     f59:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			f5c: R_X86_64_32S	.rodata.str1.8+0x5b0
     f60:	31 c0                	xor    %eax,%eax
     f62:	e8 00 00 00 00       	callq  f67 <afs_ctr+0x817>
			f63: R_X86_64_PC32	printk-0x4
     f67:	e9 fc fd ff ff       	jmpq   d68 <afs_ctr+0x618>
detect_fs():
/home/austen/programming/dm-afs/src/dm_afs.c:32
    afs_action(page, ret = -ENOMEM, alloc_err, "could not allocate page [%d]", ret);
     f6c:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
     f71:	ba 20 00 00 00       	mov    $0x20,%edx
     f76:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			f79: R_X86_64_32S	.rodata+0x10
     f7d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			f80: R_X86_64_32S	.rodata.str1.8+0x5e8
     f84:	31 c0                	xor    %eax,%eax
     f86:	e8 00 00 00 00       	callq  f8b <afs_ctr+0x83b>
			f87: R_X86_64_PC32	printk-0x4
     f8b:	e9 5f fa ff ff       	jmpq   9ef <afs_ctr+0x29f>
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:79
    afs_assert(!kstrtou8(argv[TYPE], BASE_10, &args->instance_type), err, "instance type not integer");
     f90:	ba 4f 00 00 00       	mov    $0x4f,%edx
     f95:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			f98: R_X86_64_32S	.rodata+0x20
     f9c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			f9f: R_X86_64_32S	.rodata.str1.8+0x2a8
     fa3:	31 c0                	xor    %eax,%eax
     fa5:	e8 00 00 00 00       	callq  faa <afs_ctr+0x85a>
			fa6: R_X86_64_PC32	printk-0x4
     faa:	e9 79 fe ff ff       	jmpq   e28 <afs_ctr+0x6d8>
/home/austen/programming/dm-afs/src/dm_afs.c:82
    afs_debug("Type: %d", args->instance_type);
     faf:	41 0f b6 8c 24 00 21 	movzbl 0x2100(%r12),%ecx
     fb6:	00 00 
     fb8:	31 c0                	xor    %eax,%eax
     fba:	ba 52 00 00 00       	mov    $0x52,%edx
     fbf:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			fc2: R_X86_64_32S	.rodata+0x20
     fc6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			fc9: R_X86_64_32S	.rodata.str1.8+0x2e0
     fcd:	e8 00 00 00 00       	callq  fd2 <afs_ctr+0x882>
			fce: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:83
    afs_debug("Passphrase: %s", args->passphrase);
     fd2:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # fd9 <afs_ctr+0x889>
			fd4: R_X86_64_PC32	afs_debug_mode-0x5
     fd9:	0f 84 5e f8 ff ff    	je     83d <afs_ctr+0xed>
     fdf:	31 c0                	xor    %eax,%eax
     fe1:	4c 89 f1             	mov    %r14,%rcx
     fe4:	ba 53 00 00 00       	mov    $0x53,%edx
     fe9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			fec: R_X86_64_32S	.rodata+0x20
     ff0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			ff3: R_X86_64_32S	.rodata.str1.8+0x308
     ff7:	e8 00 00 00 00       	callq  ffc <afs_ctr+0x8ac>
			ff8: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:84
    afs_debug("Device: %s", args->passive_dev);
     ffc:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1003 <afs_ctr+0x8b3>
			ffe: R_X86_64_PC32	afs_debug_mode-0x5
    1003:	0f 84 34 f8 ff ff    	je     83d <afs_ctr+0xed>
    1009:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
    100d:	ba 54 00 00 00       	mov    $0x54,%edx
    1012:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1015: R_X86_64_32S	.rodata+0x20
    1019:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			101c: R_X86_64_32S	.rodata.str1.8+0x330
    1020:	31 c0                	xor    %eax,%eax
    1022:	e8 00 00 00 00       	callq  1027 <afs_ctr+0x8d7>
			1023: R_X86_64_PC32	printk-0x4
    1027:	e9 11 f8 ff ff       	jmpq   83d <afs_ctr+0xed>
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:601 (discriminator 1)
    afs_assert(!ret, encode_err, "could not initialize encoding library [%d]", ret);
    102c:	89 c1                	mov    %eax,%ecx
    102e:	ba 59 02 00 00       	mov    $0x259,%edx
    1033:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1036: R_X86_64_32S	.rodata+0x40
    103a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			103d: R_X86_64_32S	.rodata.str1.8+0x800
    1041:	31 c0                	xor    %eax,%eax
    1043:	e8 00 00 00 00       	callq  1048 <afs_ctr+0x8f8>
			1044: R_X86_64_PC32	printk-0x4
    1048:	e9 23 fd ff ff       	jmpq   d70 <afs_ctr+0x620>
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:111
        afs_assert(args->entropy_dir[0] == 0, err, "entropy source provided");
    104d:	ba 6f 00 00 00       	mov    $0x6f,%edx
    1052:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1055: R_X86_64_32S	.rodata+0x20
    1059:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			105c: R_X86_64_32S	.rodata.str1.8+0x4c8
    1060:	31 c0                	xor    %eax,%eax
    1062:	e8 00 00 00 00       	callq  1067 <afs_ctr+0x917>
			1063: R_X86_64_PC32	printk-0x4
    1067:	e9 bc fd ff ff       	jmpq   e28 <afs_ctr+0x6d8>
/home/austen/programming/dm-afs/src/dm_afs.c:99
    afs_debug("Entropy: %s", args->entropy_dir);
    106c:	49 8d 8c 24 c0 20 00 	lea    0x20c0(%r12),%rcx
    1073:	00 
    1074:	31 c0                	xor    %eax,%eax
    1076:	ba 63 00 00 00       	mov    $0x63,%edx
    107b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			107e: R_X86_64_32S	.rodata+0x20
    1082:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1085: R_X86_64_32S	.rodata.str1.8+0x400
    1089:	e8 00 00 00 00       	callq  108e <afs_ctr+0x93e>
			108a: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:100
    afs_debug("Shadow Passphrase: %s", args->shadow_passphrase);
    108e:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1095 <afs_ctr+0x945>
			1090: R_X86_64_PC32	afs_debug_mode-0x5
    1095:	0f 84 67 f8 ff ff    	je     902 <afs_ctr+0x1b2>
    109b:	49 8d 8c 24 60 20 00 	lea    0x2060(%r12),%rcx
    10a2:	00 
    10a3:	ba 64 00 00 00       	mov    $0x64,%edx
    10a8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			10ab: R_X86_64_32S	.rodata+0x20
    10af:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			10b2: R_X86_64_32S	.rodata.str1.8+0x428
    10b6:	31 c0                	xor    %eax,%eax
    10b8:	e8 00 00 00 00       	callq  10bd <afs_ctr+0x96d>
			10b9: R_X86_64_PC32	printk-0x4
    10bd:	e9 40 f8 ff ff       	jmpq   902 <afs_ctr+0x1b2>
detect_fs():
/home/austen/programming/dm-afs/src/dm_afs.c:34
    afs_assert(!ret, read_err, "could not read page [%d]", ret);
    10c2:	0f be c8             	movsbl %al,%ecx
    10c5:	ba 22 00 00 00       	mov    $0x22,%edx
    10ca:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			10cd: R_X86_64_32S	.rodata+0x10
    10d1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			10d4: R_X86_64_32S	.rodata.str1.8+0x620
    10d8:	31 c0                	xor    %eax,%eax
    10da:	e8 00 00 00 00       	callq  10df <afs_ctr+0x98f>
			10db: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:54
    kfree(page);
    10df:	48 89 df             	mov    %rbx,%rdi
    10e2:	e8 00 00 00 00       	callq  10e7 <afs_ctr+0x997>
			10e3: R_X86_64_PC32	kfree-0x4
    10e7:	e9 03 f9 ff ff       	jmpq   9ef <afs_ctr+0x29f>
/home/austen/programming/dm-afs/src/dm_afs.c:50
    afs_debug("detected %d", ret);
    10ec:	31 c9                	xor    %ecx,%ecx
    10ee:	31 c0                	xor    %eax,%eax
    10f0:	ba 32 00 00 00       	mov    $0x32,%edx
    10f5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			10f8: R_X86_64_32S	.rodata+0x10
    10fc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			10ff: R_X86_64_32S	.rodata.str1.8+0x878
    1103:	e8 00 00 00 00       	callq  1108 <afs_ctr+0x9b8>
			1104: R_X86_64_PC32	printk-0x4
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:530
        afs_debug("detected FAT32");
    1108:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 110f <afs_ctr+0x9bf>
			110a: R_X86_64_PC32	afs_debug_mode-0x5
    110f:	0f 84 da f8 ff ff    	je     9ef <afs_ctr+0x29f>
/home/austen/programming/dm-afs/src/dm_afs.c:530 (discriminator 1)
    1115:	ba 12 02 00 00       	mov    $0x212,%edx
    111a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			111d: R_X86_64_32S	.rodata+0x40
    1121:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1124: R_X86_64_32S	.rodata.str1.8+0x658
    1128:	31 c0                	xor    %eax,%eax
    112a:	e8 00 00 00 00       	callq  112f <afs_ctr+0x9df>
			112b: R_X86_64_PC32	printk-0x4
    112f:	e9 bb f8 ff ff       	jmpq   9ef <afs_ctr+0x29f>
/home/austen/programming/dm-afs/src/dm_afs.c:563 (discriminator 1)
    afs_action(context->vector.vector, ret = -ENOMEM, vec_err, "could not allocate allocation vector");
    1134:	ba 33 02 00 00       	mov    $0x233,%edx
    1139:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			113c: R_X86_64_32S	.rodata+0x40
    1140:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1143: R_X86_64_32S	.rodata.str1.8+0x6d0
    1147:	e8 00 00 00 00       	callq  114c <afs_ctr+0x9fc>
			1148: R_X86_64_PC32	printk-0x4
    114c:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
    1151:	e9 f8 fb ff ff       	jmpq   d4e <afs_ctr+0x5fe>
/home/austen/programming/dm-afs/src/dm_afs.c:606 (discriminator 1)
    afs_debug("constructor completed");
    1156:	ba 5e 02 00 00       	mov    $0x25e,%edx
    115b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			115e: R_X86_64_32S	.rodata+0x40
    1162:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1165: R_X86_64_32S	.rodata.str1.8+0x848
    1169:	31 c0                	xor    %eax,%eax
    116b:	e8 00 00 00 00       	callq  1170 <afs_ctr+0xa20>
			116c: R_X86_64_PC32	printk-0x4
    1170:	e9 ee f9 ff ff       	jmpq   b63 <afs_ctr+0x413>
parse_afs_args():
/home/austen/programming/dm-afs/src/dm_afs.c:106
        afs_assert(args->entropy_dir[0] != 0, err, "entropy source not provided");
    1175:	ba 6a 00 00 00       	mov    $0x6a,%edx
    117a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			117d: R_X86_64_32S	.rodata+0x20
    1181:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1184: R_X86_64_32S	.rodata.str1.8+0x458
    1188:	31 c0                	xor    %eax,%eax
    118a:	e8 00 00 00 00       	callq  118f <afs_ctr+0xa3f>
			118b: R_X86_64_PC32	printk-0x4
    118f:	e9 94 fc ff ff       	jmpq   e28 <afs_ctr+0x6d8>
afs_ctr():
/home/austen/programming/dm-afs/src/dm_afs.c:578 (discriminator 1)
        afs_assert(!ret, sb_err, "could not find super block [%d]", ret);
    1194:	89 c1                	mov    %eax,%ecx
    1196:	ba 42 02 00 00       	mov    $0x242,%edx
    119b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			119e: R_X86_64_32S	.rodata+0x40
    11a2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			11a5: R_X86_64_32S	.rodata.str1.8+0x750
    11a9:	31 c0                	xor    %eax,%eax
    11ab:	e8 00 00 00 00       	callq  11b0 <afs_ctr+0xa60>
			11ac: R_X86_64_PC32	printk-0x4
    11b0:	e9 8c fb ff ff       	jmpq   d41 <afs_ctr+0x5f1>
    11b5:	90                   	nop
    11b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    11bd:	00 00 00 

00000000000011c0 <cleanup_module>:
afs_exit():
/home/austen/programming/dm-afs/src/dm_afs.c:733
 * Unregisters the dm_afs target from the device-mapper
 * tree.
 */
static void
afs_exit(void)
{
    11c0:	e8 00 00 00 00       	callq  11c5 <cleanup_module+0x5>
			11c1: R_X86_64_PC32	__fentry__-0x4
    11c5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs.c:734
    dm_unregister_target(&afs_target);
    11c6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			11c9: R_X86_64_32S	.data+0x20
/home/austen/programming/dm-afs/src/dm_afs.c:733
{
    11cd:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs.c:734
    dm_unregister_target(&afs_target);
    11d0:	e8 00 00 00 00       	callq  11d5 <cleanup_module+0x15>
			11d1: R_X86_64_PC32	dm_unregister_target-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:735
    afs_debug("unregistered dm_afs");
    11d5:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 11db <cleanup_module+0x1b>
			11d7: R_X86_64_PC32	afs_debug_mode-0x4
    11db:	85 c0                	test   %eax,%eax
    11dd:	75 02                	jne    11e1 <cleanup_module+0x21>
/home/austen/programming/dm-afs/src/dm_afs.c:736
}
    11df:	5d                   	pop    %rbp
    11e0:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs.c:735
    afs_debug("unregistered dm_afs");
    11e1:	ba df 02 00 00       	mov    $0x2df,%edx
    11e6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			11e9: R_X86_64_32S	.rodata
    11ed:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			11f0: R_X86_64_32S	.rodata.str1.8+0x910
    11f4:	31 c0                	xor    %eax,%eax
    11f6:	e8 00 00 00 00       	callq  11fb <cleanup_module+0x3b>
			11f7: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:736
}
    11fb:	5d                   	pop    %rbp
    11fc:	c3                   	retq   
    11fd:	0f 1f 00             	nopl   (%rax)

0000000000001200 <build_configuration>:
build_configuration():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:48
 * Build the configuration for an instance.
 * TODO build config for everything
 */
void
build_configuration(struct afs_private *context, uint8_t num_carrier_blocks, uint8_t num_entropy_blocks)
{
    1200:	e8 00 00 00 00       	callq  1205 <build_configuration+0x5>
			1201: R_X86_64_PC32	__fentry__-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:53
    struct afs_config *config = &context->config;

    config->num_carrier_blocks = num_carrier_blocks;
    config->num_entropy_blocks = num_entropy_blocks;
    config->map_entry_sz = SHA128_SZ + ENTROPY_HASH_SZ + (sizeof(struct afs_map_tuple) * config->num_carrier_blocks);
    1205:	44 8d 04 b6          	lea    (%rsi,%rsi,4),%r8d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:54
    config->unused_space_per_block = (AFS_BLOCK_SIZE - SHA512_SZ) % config->map_entry_sz;
    1209:	b9 c0 0f 00 00       	mov    $0xfc0,%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:52
    config->num_entropy_blocks = num_entropy_blocks;
    120e:	88 57 11             	mov    %dl,0x11(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:54
    config->unused_space_per_block = (AFS_BLOCK_SIZE - SHA512_SZ) % config->map_entry_sz;
    1211:	89 c8                	mov    %ecx,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:51
    config->num_carrier_blocks = num_carrier_blocks;
    1213:	40 88 77 10          	mov    %sil,0x10(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:53
    config->map_entry_sz = SHA128_SZ + ENTROPY_HASH_SZ + (sizeof(struct afs_map_tuple) * config->num_carrier_blocks);
    1217:	47 8d 44 00 18       	lea    0x18(%r8,%r8,1),%r8d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:54
    config->unused_space_per_block = (AFS_BLOCK_SIZE - SHA512_SZ) % config->map_entry_sz;
    121c:	99                   	cltd   
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:53
    config->map_entry_sz = SHA128_SZ + ENTROPY_HASH_SZ + (sizeof(struct afs_map_tuple) * config->num_carrier_blocks);
    121d:	44 88 47 12          	mov    %r8b,0x12(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:54
    config->unused_space_per_block = (AFS_BLOCK_SIZE - SHA512_SZ) % config->map_entry_sz;
    1221:	45 0f b6 c0          	movzbl %r8b,%r8d
    1225:	41 f7 f8             	idiv   %r8d
    1228:	89 c1                	mov    %eax,%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:55
    config->num_map_entries_per_block = (AFS_BLOCK_SIZE - SHA512_SZ) / config->map_entry_sz;
    122a:	88 47 14             	mov    %al,0x14(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:56
    config->num_blocks = config->instance_size / AFS_BLOCK_SIZE;
    122d:	48 8b 47 28          	mov    0x28(%rdi),%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:54
    config->unused_space_per_block = (AFS_BLOCK_SIZE - SHA512_SZ) % config->map_entry_sz;
    1231:	88 57 13             	mov    %dl,0x13(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:59

    // Kernel doesn't support floating point math. We need to round up.
    config->num_map_blocks = config->num_blocks / config->num_map_entries_per_block;
    1234:	0f b6 c9             	movzbl %cl,%ecx
    1237:	31 d2                	xor    %edx,%edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:56
    config->num_blocks = config->instance_size / AFS_BLOCK_SIZE;
    1239:	48 c1 e8 0c          	shr    $0xc,%rax
    123d:	89 47 18             	mov    %eax,0x18(%rdi)
    1240:	f7 f1                	div    %ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:60
    config->num_map_blocks += (config->num_blocks % config->num_map_entries_per_block) ? 1 : 0;
    1242:	85 d2                	test   %edx,%edx
    1244:	0f 95 c2             	setne  %dl
    1247:	0f b6 d2             	movzbl %dl,%edx
    124a:	01 d0                	add    %edx,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:65

    // We store a certain amount of pointers to map blocks in the SB itself.
    // So we need to adjust for that when calculating num_ptr_blocks. We also
    // exploit unsigned math.
    if ((config->num_map_blocks - NUM_MAP_BLKS_IN_SB) > config->num_map_blocks) {
    124c:	3d ce 03 00 00       	cmp    $0x3ce,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:60
    config->num_map_blocks += (config->num_blocks % config->num_map_entries_per_block) ? 1 : 0;
    1251:	89 47 1c             	mov    %eax,0x1c(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:65
    if ((config->num_map_blocks - NUM_MAP_BLKS_IN_SB) > config->num_map_blocks) {
    1254:	77 13                	ja     1269 <build_configuration+0x69>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:67
        // We can store everything in the SB itself.
        config->num_ptr_blocks = 0;
    1256:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:73
    } else {
        config->num_ptr_blocks = (config->num_map_blocks - NUM_MAP_BLKS_IN_SB) / NUM_MAP_BLKS_IN_PB;
        config->num_ptr_blocks += ((config->num_map_blocks - NUM_MAP_BLKS_IN_SB) % NUM_MAP_BLKS_IN_PB) ? 1 : 0;
    }
   
    afs_debug("Number carrier blocks per tuple: %u", config->num_carrier_blocks);
    125d:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 1263 <build_configuration+0x63>
			125f: R_X86_64_PC32	afs_debug_mode-0x4
    1263:	85 c9                	test   %ecx,%ecx
    1265:	75 31                	jne    1298 <build_configuration+0x98>
    1267:	f3 c3                	repz retq 
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:69
        config->num_ptr_blocks = (config->num_map_blocks - NUM_MAP_BLKS_IN_SB) / NUM_MAP_BLKS_IN_PB;
    1269:	8d 88 31 fc ff ff    	lea    -0x3cf(%rax),%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:70
        config->num_ptr_blocks += ((config->num_map_blocks - NUM_MAP_BLKS_IN_SB) % NUM_MAP_BLKS_IN_PB) ? 1 : 0;
    126f:	ba f7 91 41 01       	mov    $0x14191f7,%edx
    1274:	89 c8                	mov    %ecx,%eax
    1276:	f7 e2                	mul    %edx
    1278:	89 c8                	mov    %ecx,%eax
    127a:	29 d0                	sub    %edx,%eax
    127c:	d1 e8                	shr    %eax
    127e:	01 c2                	add    %eax,%edx
    1280:	c1 ea 09             	shr    $0x9,%edx
    1283:	69 c2 fb 03 00 00    	imul   $0x3fb,%edx,%eax
    1289:	39 c1                	cmp    %eax,%ecx
    128b:	0f 95 c0             	setne  %al
    128e:	0f b6 c0             	movzbl %al,%eax
    1291:	01 c2                	add    %eax,%edx
    1293:	89 57 20             	mov    %edx,0x20(%rdi)
    1296:	eb c5                	jmp    125d <build_configuration+0x5d>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:48 (discriminator 1)
{
    1298:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:73 (discriminator 1)
    afs_debug("Number carrier blocks per tuple: %u", config->num_carrier_blocks);
    1299:	40 0f b6 ce          	movzbl %sil,%ecx
    129d:	31 c0                	xor    %eax,%eax
    129f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			12a2: R_X86_64_32S	.rodata+0x160
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:48 (discriminator 1)
{
    12a6:	48 89 e5             	mov    %rsp,%rbp
    12a9:	53                   	push   %rbx
    12aa:	52                   	push   %rdx
    12ab:	48 89 fb             	mov    %rdi,%rbx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:73 (discriminator 1)
    afs_debug("Number carrier blocks per tuple: %u", config->num_carrier_blocks);
    12ae:	ba 49 00 00 00       	mov    $0x49,%edx
    12b3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			12b6: R_X86_64_32S	.rodata.str1.8+0x940
    12ba:	e8 00 00 00 00       	callq  12bf <build_configuration+0xbf>
			12bb: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:74 (discriminator 1)
    afs_debug("Number entropy blocks per tuple: %u", config->num_entropy_blocks); 
    12bf:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 12c6 <build_configuration+0xc6>
			12c1: R_X86_64_PC32	afs_debug_mode-0x5
    12c6:	0f 84 9b 00 00 00    	je     1367 <build_configuration+0x167>
    12cc:	0f b6 4b 11          	movzbl 0x11(%rbx),%ecx
    12d0:	31 c0                	xor    %eax,%eax
    12d2:	ba 4a 00 00 00       	mov    $0x4a,%edx
    12d7:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			12da: R_X86_64_32S	.rodata+0x160
    12de:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			12e1: R_X86_64_32S	.rodata.str1.8+0x980
    12e5:	e8 00 00 00 00       	callq  12ea <build_configuration+0xea>
			12e6: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:75 (discriminator 1)
    afs_debug("Map entry size: %u", config->map_entry_sz);
    12ea:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 12f1 <build_configuration+0xf1>
			12ec: R_X86_64_PC32	afs_debug_mode-0x5
    12f1:	74 53                	je     1346 <build_configuration+0x146>
    12f3:	0f b6 4b 12          	movzbl 0x12(%rbx),%ecx
    12f7:	31 c0                	xor    %eax,%eax
    12f9:	ba 4b 00 00 00       	mov    $0x4b,%edx
    12fe:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1301: R_X86_64_32S	.rodata+0x160
    1305:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1308: R_X86_64_32S	.rodata.str1.8+0x9c0
    130c:	e8 00 00 00 00       	callq  1311 <build_configuration+0x111>
			130d: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:76 (discriminator 1)
    afs_debug("Unused: %u | Entries per block: %u", config->unused_space_per_block, config->num_map_entries_per_block);
    1311:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1318 <build_configuration+0x118>
			1313: R_X86_64_PC32	afs_debug_mode-0x5
    1318:	74 2c                	je     1346 <build_configuration+0x146>
    131a:	0f b6 4b 13          	movzbl 0x13(%rbx),%ecx
    131e:	44 0f b6 43 14       	movzbl 0x14(%rbx),%r8d
    1323:	31 c0                	xor    %eax,%eax
    1325:	ba 4c 00 00 00       	mov    $0x4c,%edx
    132a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			132d: R_X86_64_32S	.rodata+0x160
    1331:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1334: R_X86_64_32S	.rodata.str1.8+0x9f0
    1338:	e8 00 00 00 00       	callq  133d <build_configuration+0x13d>
			1339: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:77 (discriminator 1)
    afs_debug("Blocks: %u", config->num_blocks);
    133d:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1344 <build_configuration+0x144>
			133f: R_X86_64_PC32	afs_debug_mode-0x5
    1344:	75 04                	jne    134a <build_configuration+0x14a>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:80
    afs_debug("Map blocks: %u", config->num_map_blocks);
    afs_debug("Ptr blocks: %u", config->num_ptr_blocks);
}
    1346:	58                   	pop    %rax
    1347:	5b                   	pop    %rbx
    1348:	5d                   	pop    %rbp
    1349:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:77 (discriminator 1)
    afs_debug("Blocks: %u", config->num_blocks);
    134a:	8b 4b 18             	mov    0x18(%rbx),%ecx
    134d:	ba 4d 00 00 00       	mov    $0x4d,%edx
    1352:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1355: R_X86_64_32S	.rodata+0x160
    1359:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			135c: R_X86_64_32S	.rodata.str1.8+0xa30
    1360:	31 c0                	xor    %eax,%eax
    1362:	e8 00 00 00 00       	callq  1367 <build_configuration+0x167>
			1363: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:78
    afs_debug("Map blocks: %u", config->num_map_blocks);
    1367:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 136e <build_configuration+0x16e>
			1369: R_X86_64_PC32	afs_debug_mode-0x5
    136e:	74 d6                	je     1346 <build_configuration+0x146>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:78 (discriminator 1)
    1370:	8b 4b 1c             	mov    0x1c(%rbx),%ecx
    1373:	31 c0                	xor    %eax,%eax
    1375:	ba 4e 00 00 00       	mov    $0x4e,%edx
    137a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			137d: R_X86_64_32S	.rodata+0x160
    1381:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1384: R_X86_64_32S	.rodata.str1.8+0xa58
    1388:	e8 00 00 00 00       	callq  138d <build_configuration+0x18d>
			1389: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:79 (discriminator 1)
    afs_debug("Ptr blocks: %u", config->num_ptr_blocks);
    138d:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 1394 <build_configuration+0x194>
			138f: R_X86_64_PC32	afs_debug_mode-0x5
    1394:	74 b0                	je     1346 <build_configuration+0x146>
    1396:	8b 4b 20             	mov    0x20(%rbx),%ecx
    1399:	ba 4f 00 00 00       	mov    $0x4f,%edx
    139e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			13a1: R_X86_64_32S	.rodata+0x160
    13a5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			13a8: R_X86_64_32S	.rodata.str1.8+0xa80
    13ac:	31 c0                	xor    %eax,%eax
    13ae:	e8 00 00 00 00       	callq  13b3 <build_configuration+0x1b3>
			13af: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:80 (discriminator 1)
}
    13b3:	eb 91                	jmp    1346 <build_configuration+0x146>
    13b5:	90                   	nop
    13b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    13bd:	00 00 00 

00000000000013c0 <afs_create_map>:
afs_create_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:88
 * Create the Artifice map and initialize it to
 * invalids.
 */
int
afs_create_map(struct afs_private *context)
{
    13c0:	e8 00 00 00 00       	callq  13c5 <afs_create_map+0x5>
			13c1: R_X86_64_PC32	__fentry__-0x4
    13c5:	55                   	push   %rbp
    13c6:	48 89 e5             	mov    %rsp,%rbp
    13c9:	41 57                	push   %r15
    13cb:	41 56                	push   %r14
    13cd:	41 55                	push   %r13
    13cf:	41 54                	push   %r12
    13d1:	49 89 ff             	mov    %rdi,%r15
    13d4:	53                   	push   %rbx
    13d5:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:103
    map_entry_sz = config->map_entry_sz;
    num_blocks = config->num_blocks;
    num_carrier_blocks = config->num_carrier_blocks;

    // Allocate all required map_entries.
    map_entries = vmalloc(num_blocks * map_entry_sz);
    13d9:	44 0f b6 6f 12       	movzbl 0x12(%rdi),%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:99
    num_blocks = config->num_blocks;
    13de:	8b 5f 18             	mov    0x18(%rdi),%ebx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:100
    num_carrier_blocks = config->num_carrier_blocks;
    13e1:	44 0f b6 77 10       	movzbl 0x10(%rdi),%r14d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:103
    map_entries = vmalloc(num_blocks * map_entry_sz);
    13e6:	44 89 ef             	mov    %r13d,%edi
    13e9:	0f af fb             	imul   %ebx,%edi
    13ec:	e8 00 00 00 00       	callq  13f1 <afs_create_map+0x31>
			13ed: R_X86_64_PC32	vmalloc-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:104
    afs_action(map_entries, ret = -ENOMEM, done, "could not allocate map entries [%d]", ret);
    13f1:	48 85 c0             	test   %rax,%rax
    13f4:	0f 84 8f 00 00 00    	je     1489 <afs_create_map+0xc9>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:105
    afs_debug("allocated Artifice map");
    13fa:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 1401 <afs_create_map+0x41>
			13fd: R_X86_64_PC32	afs_debug_mode-0x4
    1401:	49 89 c4             	mov    %rax,%r12
    1404:	45 85 c9             	test   %r9d,%r9d
    1407:	0f 85 be 00 00 00    	jne    14cb <afs_create_map+0x10b>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:107

    for (i = 0; i < num_blocks; i++) {
    140d:	85 db                	test   %ebx,%ebx
    140f:	74 60                	je     1471 <afs_create_map+0xb1>
    1411:	41 8d 46 ff          	lea    -0x1(%r14),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:88
{
    1415:	31 f6                	xor    %esi,%esi
    1417:	31 c9                	xor    %ecx,%ecx
    1419:	48 8d 7c 80 05       	lea    0x5(%rax,%rax,4),%rdi
    141e:	48 01 ff             	add    %rdi,%rdi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:108
        map_tuple = (struct afs_map_tuple *)(map_entries + (i * map_entry_sz));
    1421:	89 f0                	mov    %esi,%eax
    1423:	4c 01 e0             	add    %r12,%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:109
        for (j = 0; j < num_carrier_blocks; j++) {
    1426:	45 85 f6             	test   %r14d,%r14d
    1429:	74 22                	je     144d <afs_create_map+0x8d>
    142b:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:112 (discriminator 3)
            map_tuple->carrier_block_ptr = AFS_INVALID_BLOCK;
            map_tuple->entropy_block_ptr = AFS_INVALID_BLOCK;
            map_tuple->checksum = 0;
    142f:	45 31 c0             	xor    %r8d,%r8d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:110 (discriminator 3)
            map_tuple->carrier_block_ptr = AFS_INVALID_BLOCK;
    1432:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:111 (discriminator 3)
            map_tuple->entropy_block_ptr = AFS_INVALID_BLOCK;
    1438:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:112 (discriminator 3)
            map_tuple->checksum = 0;
    143f:	66 44 89 40 08       	mov    %r8w,0x8(%rax)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:113 (discriminator 3)
            map_tuple += 1;
    1444:	48 83 c0 0a          	add    $0xa,%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:109 (discriminator 3)
        for (j = 0; j < num_carrier_blocks; j++) {
    1448:	48 39 d0             	cmp    %rdx,%rax
    144b:	75 e2                	jne    142f <afs_create_map+0x6f>
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    144d:	c5 f9 ef c0          	vpxor  %xmm0,%xmm0,%xmm0
afs_create_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:107
    for (i = 0; i < num_blocks; i++) {
    1451:	83 c1 01             	add    $0x1,%ecx
    1454:	44 01 ee             	add    %r13d,%esi
    1457:	39 cb                	cmp    %ecx,%ebx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    1459:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
    1460:	00 
    1461:	c5 f8 11 00          	vmovups %xmm0,(%rax)
afs_create_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:107
    1465:	77 ba                	ja     1421 <afs_create_map+0x61>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:118
        }
        // map_tuple now points to the beginning of the hash and the entropy.
        memset(map_tuple, 0, SHA128_SZ + ENTROPY_HASH_SZ);
    }
    afs_debug("initialized Artifice map");
    1467:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 146d <afs_create_map+0xad>
			1469: R_X86_64_PC32	afs_debug_mode-0x4
    146d:	85 c0                	test   %eax,%eax
    146f:	75 3e                	jne    14af <afs_create_map+0xef>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:119
    context->afs_map = map_entries;
    1471:	4d 89 a7 50 b0 03 00 	mov    %r12,0x3b050(%r15)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:120
    ret = 0;
    1478:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:124

done:
    return ret;
}
    147a:	48 83 c4 08          	add    $0x8,%rsp
    147e:	5b                   	pop    %rbx
    147f:	41 5c                	pop    %r12
    1481:	41 5d                	pop    %r13
    1483:	41 5e                	pop    %r14
    1485:	41 5f                	pop    %r15
    1487:	5d                   	pop    %rbp
    1488:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:104 (discriminator 1)
    afs_action(map_entries, ret = -ENOMEM, done, "could not allocate map entries [%d]", ret);
    1489:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    148e:	ba 68 00 00 00       	mov    $0x68,%edx
    1493:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1496: R_X86_64_32S	.rodata+0x148
    149a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			149d: R_X86_64_32S	.rodata.str1.8+0xaa8
    14a1:	31 c0                	xor    %eax,%eax
    14a3:	e8 00 00 00 00       	callq  14a8 <afs_create_map+0xe8>
			14a4: R_X86_64_PC32	printk-0x4
    14a8:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    14ad:	eb cb                	jmp    147a <afs_create_map+0xba>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:118 (discriminator 1)
    afs_debug("initialized Artifice map");
    14af:	ba 76 00 00 00       	mov    $0x76,%edx
    14b4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			14b7: R_X86_64_32S	.rodata+0x148
    14bb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			14be: R_X86_64_32S	.rodata.str1.8+0xb18
    14c2:	31 c0                	xor    %eax,%eax
    14c4:	e8 00 00 00 00       	callq  14c9 <afs_create_map+0x109>
			14c5: R_X86_64_PC32	printk-0x4
    14c9:	eb a6                	jmp    1471 <afs_create_map+0xb1>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:105 (discriminator 1)
    afs_debug("allocated Artifice map");
    14cb:	31 c0                	xor    %eax,%eax
    14cd:	ba 69 00 00 00       	mov    $0x69,%edx
    14d2:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			14d5: R_X86_64_32S	.rodata+0x148
    14d9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			14dc: R_X86_64_32S	.rodata.str1.8+0xae8
    14e0:	e8 00 00 00 00       	callq  14e5 <afs_create_map+0x125>
			14e1: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:107 (discriminator 1)
    for (i = 0; i < num_blocks; i++) {
    14e5:	85 db                	test   %ebx,%ebx
    14e7:	0f 85 24 ff ff ff    	jne    1411 <afs_create_map+0x51>
    14ed:	e9 75 ff ff ff       	jmpq   1467 <afs_create_map+0xa7>
    14f2:	0f 1f 40 00          	nopl   0x0(%rax)
    14f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    14fd:	00 00 00 

0000000000001500 <afs_fill_map>:
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:132
 * Fill an Artifice map with values from the
 * metadata.
 */
int
afs_fill_map(struct afs_super_block *sb, struct afs_private *context)
{
    1500:	e8 00 00 00 00       	callq  1505 <afs_fill_map+0x5>
			1501: R_X86_64_PC32	__fentry__-0x4
    1505:	55                   	push   %rbp
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    1506:	ba 00 10 00 00       	mov    $0x1000,%edx
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:132
    150b:	48 89 e5             	mov    %rsp,%rbp
    150e:	41 57                	push   %r15
    1510:	41 56                	push   %r14
    1512:	41 55                	push   %r13
    1514:	41 54                	push   %r12
    1516:	53                   	push   %rbx
    1517:	48 89 f3             	mov    %rsi,%rbx
    151a:	48 83 ec 58          	sub    $0x58,%rsp
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:147
    uint32_t next_block;
    uint32_t entries_read;
    uint32_t entries_left;
    uint32_t i, j;
    int ret = 0;
    uint32_t data_sector_offset = context->passive_fs.data_start_off;
    151e:	8b 86 14 20 00 00    	mov    0x2014(%rsi),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:132
{
    1524:	48 89 7d 90          	mov    %rdi,-0x70(%rbp)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    1528:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 152f <afs_fill_map+0x2f>
			152b: R_X86_64_PC32	kmalloc_caches+0x5c
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:152

    // Acquire the map.
    afs_map = context->afs_map;

    map_entry_sz = config->map_entry_sz;
    152f:	44 0f b6 6e 12       	movzbl 0x12(%rsi),%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:153
    num_map_entries_per_block = config->num_map_entries_per_block;
    1534:	44 0f b6 66 14       	movzbl 0x14(%rsi),%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:147
    uint32_t data_sector_offset = context->passive_fs.data_start_off;
    1539:	89 45 c8             	mov    %eax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:150
    afs_map = context->afs_map;
    153c:	48 8b 86 50 b0 03 00 	mov    0x3b050(%rsi),%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    1543:	be c0 00 40 01       	mov    $0x14000c0,%esi
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:150
    1548:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    154c:	e8 00 00 00 00       	callq  1551 <afs_fill_map+0x51>
			154d: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
    1551:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1558 <afs_fill_map+0x58>
			1554: R_X86_64_PC32	kmalloc_caches+0x5c
    1558:	49 89 c6             	mov    %rax,%r14
    155b:	ba 00 10 00 00       	mov    $0x1000,%edx
    1560:	be c0 00 40 01       	mov    $0x14000c0,%esi
    1565:	e8 00 00 00 00       	callq  156a <afs_fill_map+0x6a>
			1566: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:157

    map_block = kmalloc(AFS_BLOCK_SIZE, GFP_KERNEL);
    ptr_block = kmalloc(sizeof(*ptr_block), GFP_KERNEL);
    afs_action(map_block && ptr_block, ret = -ENOMEM, err, "could not allocate memory for map data [%d]", ret);
    156a:	4d 85 f6             	test   %r14,%r14
    156d:	0f 84 12 03 00 00    	je     1885 <afs_fill_map+0x385>
    1573:	48 85 c0             	test   %rax,%rax
    1576:	49 89 c7             	mov    %rax,%r15
    1579:	0f 84 06 03 00 00    	je     1885 <afs_fill_map+0x385>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:179
        if (entries_left <= num_map_entries_per_block) {
            memcpy(afs_map + (entries_read * map_entry_sz), map_block_entries, entries_left * map_entry_sz);
            entries_read += entries_left;
            break;
        } else {
            memcpy(afs_map + (entries_read * map_entry_sz), map_block_entries, num_map_entries_per_block * map_entry_sz);
    157f:	41 0f b6 cd          	movzbl %r13b,%ecx
    1583:	41 0f b6 c4          	movzbl %r12b,%eax
    1587:	31 ff                	xor    %edi,%edi
    1589:	89 45 cc             	mov    %eax,-0x34(%rbp)
    158c:	89 4d a8             	mov    %ecx,-0x58(%rbp)
    158f:	0f af c1             	imul   %ecx,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:160
    entries_read = 0;
    1592:	31 c9                	xor    %ecx,%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:165
        allocation_set(&context->vector, sb->map_block_ptrs[i]);
    1594:	4c 89 7d 88          	mov    %r15,-0x78(%rbp)
    1598:	4c 89 75 c0          	mov    %r14,-0x40(%rbp)
    159c:	41 89 cf             	mov    %ecx,%r15d
    159f:	41 89 fe             	mov    %edi,%r14d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:179
            memcpy(afs_map + (entries_read * map_entry_sz), map_block_entries, num_map_entries_per_block * map_entry_sz);
    15a2:	89 45 ac             	mov    %eax,-0x54(%rbp)
    15a5:	48 98                	cltq   
    15a7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    15ab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    15af:	4c 8d a8 c0 00 00 00 	lea    0xc0(%rax),%r13
    15b6:	48 05 fc 0f 00 00    	add    $0xffc,%rax
    15bc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:165
        allocation_set(&context->vector, sb->map_block_ptrs[i]);
    15c0:	48 8d 83 08 21 00 00 	lea    0x2108(%rbx),%rax
    15c7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    15cb:	eb 1f                	jmp    15ec <afs_fill_map+0xec>
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344 (discriminator 2)
    15cd:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    15d1:	49 83 c5 04          	add    $0x4,%r13
    15d5:	e8 00 00 00 00       	callq  15da <afs_fill_map+0xda>
			15d6: R_X86_64_PC32	memcpy-0x4
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:180 (discriminator 2)
            entries_read += num_map_entries_per_block;
    15da:	44 03 7d cc          	add    -0x34(%rbp),%r15d
    15de:	44 03 75 ac          	add    -0x54(%rbp),%r14d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:161 (discriminator 2)
    for (i = 0; i < NUM_MAP_BLKS_IN_SB; i++) {
    15e2:	4c 3b 6d 98          	cmp    -0x68(%rbp),%r13
    15e6:	0f 84 93 01 00 00    	je     177f <afs_fill_map+0x27f>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:163
        ret = read_page(map_block, context->bdev, sb->map_block_ptrs[i], data_sector_offset, false);
    15ec:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    15f0:	8b 4d c8             	mov    -0x38(%rbp),%ecx
    15f3:	45 31 c0             	xor    %r8d,%r8d
    15f6:	41 8b 55 00          	mov    0x0(%r13),%edx
    15fa:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    15fe:	e8 00 00 00 00       	callq  1603 <afs_fill_map+0x103>
			15ff: R_X86_64_PC32	read_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:164
        afs_assert(!ret, read_err, "could not read map block [%d:%u]", ret, entries_read % config->num_map_blocks);
    1603:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:163
        ret = read_page(map_block, context->bdev, sb->map_block_ptrs[i], data_sector_offset, false);
    1605:	41 89 c4             	mov    %eax,%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:164
        afs_assert(!ret, read_err, "could not read map block [%d:%u]", ret, entries_read % config->num_map_blocks);
    1608:	0f 85 3e 02 00 00    	jne    184c <afs_fill_map+0x34c>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:165
        allocation_set(&context->vector, sb->map_block_ptrs[i]);
    160e:	41 8b 75 00          	mov    0x0(%r13),%esi
    1612:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    1616:	e8 00 00 00 00       	callq  161b <afs_fill_map+0x11b>
			1617: R_X86_64_PC32	allocation_set-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:170
        map_block_entries = map_block_unused + config->unused_space_per_block;
    161b:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    161f:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
    1623:	44 89 f7             	mov    %r14d,%edi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:173
        entries_left = config->num_blocks - entries_read;
    1626:	8b 53 18             	mov    0x18(%rbx),%edx
    1629:	48 03 7d b0          	add    -0x50(%rbp),%rdi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:170
        map_block_entries = map_block_unused + config->unused_space_per_block;
    162d:	48 8d 74 01 40       	lea    0x40(%rcx,%rax,1),%rsi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:173
        entries_left = config->num_blocks - entries_read;
    1632:	89 d0                	mov    %edx,%eax
    1634:	44 29 f8             	sub    %r15d,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:174
        if (entries_left <= num_map_entries_per_block) {
    1637:	3b 45 cc             	cmp    -0x34(%rbp),%eax
    163a:	77 91                	ja     15cd <afs_fill_map+0xcd>
    163c:	44 89 65 98          	mov    %r12d,-0x68(%rbp)
    1640:	41 89 d4             	mov    %edx,%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:175
            memcpy(afs_map + (entries_read * map_entry_sz), map_block_entries, entries_left * map_entry_sz);
    1643:	89 c2                	mov    %eax,%edx
    1645:	0f af 55 a8          	imul   -0x58(%rbp),%edx
    1649:	4c 8b 7d 88          	mov    -0x78(%rbp),%r15
    164d:	49 89 ce             	mov    %rcx,%r14
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    1650:	e8 00 00 00 00       	callq  1655 <afs_fill_map+0x155>
			1651: R_X86_64_PC32	memcpy-0x4
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:183
        }
    }
    afs_debug("super block's map blocks read");
    1655:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 165b <afs_fill_map+0x15b>
			1657: R_X86_64_PC32	afs_debug_mode-0x4
    165b:	85 f6                	test   %esi,%esi
    165d:	0f 85 ca 01 00 00    	jne    182d <afs_fill_map+0x32d>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:186 (discriminator 1)

    // Begin reading from pointer blocks.
    for (i = 0; i < config->num_ptr_blocks; i++) {
    1663:	8b 4b 20             	mov    0x20(%rbx),%ecx
    1666:	85 c9                	test   %ecx,%ecx
    1668:	0f 84 61 01 00 00    	je     17cf <afs_fill_map+0x2cf>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:186
    166e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:187
        next_block = (i == 0) ? sb->first_ptr_block : ptr_block->next_ptr_block;
    1675:	8b 55 c0             	mov    -0x40(%rbp),%edx
    1678:	85 d2                	test   %edx,%edx
    167a:	0f 85 f3 00 00 00    	jne    1773 <afs_fill_map+0x273>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:187 (discriminator 1)
    1680:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    1684:	44 8b a8 fc 0f 00 00 	mov    0xffc(%rax),%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:188 (discriminator 4)
        ret = read_page(ptr_block, context->bdev, next_block, data_sector_offset, false);
    168b:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    168f:	8b 4d c8             	mov    -0x38(%rbp),%ecx
    1692:	45 31 c0             	xor    %r8d,%r8d
    1695:	44 89 ea             	mov    %r13d,%edx
    1698:	4c 89 ff             	mov    %r15,%rdi
    169b:	e8 00 00 00 00       	callq  16a0 <afs_fill_map+0x1a0>
			169c: R_X86_64_PC32	read_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:189 (discriminator 4)
        afs_assert(!ret, read_err, "could not read pointer block [%d:%u]", ret, i);
    16a0:	85 c0                	test   %eax,%eax
    16a2:	0f 85 55 01 00 00    	jne    17fd <afs_fill_map+0x2fd>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:190
        allocation_set(&context->vector, next_block);
    16a8:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    16ac:	44 89 ee             	mov    %r13d,%esi
    16af:	e8 00 00 00 00       	callq  16b4 <afs_fill_map+0x1b4>
			16b0: R_X86_64_PC32	allocation_set-0x4
    16b4:	44 8b 6d a8          	mov    -0x58(%rbp),%r13d
    16b8:	45 0f af ec          	imul   %r12d,%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:193
        // TODO: Calculate and verify hash of ptr_block.

        for (j = 0; j < NUM_MAP_BLKS_IN_PB; i++) {
    16bc:	eb 0d                	jmp    16cb <afs_fill_map+0x1cb>
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344 (discriminator 2)
    16be:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    16c2:	e8 00 00 00 00       	callq  16c7 <afs_fill_map+0x1c7>
			16c3: R_X86_64_PC32	memcpy-0x4
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:212 (discriminator 2)
                memcpy(afs_map + (entries_read * map_entry_sz), map_block_entries, entries_left * map_entry_sz);
                entries_read += entries_left;
                break;
            } else {
                memcpy(afs_map + (entries_read * map_entry_sz), map_block_entries, num_map_entries_per_block * map_entry_sz);
                entries_read += num_map_entries_per_block;
    16c7:	44 03 65 cc          	add    -0x34(%rbp),%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:195 (discriminator 1)
            ret = read_page(map_block, context->bdev, ptr_block->map_block_ptrs[j], data_sector_offset, false);
    16cb:	41 8b 57 10          	mov    0x10(%r15),%edx
    16cf:	48 8b 73 08          	mov    0x8(%rbx),%rsi
    16d3:	45 31 c0             	xor    %r8d,%r8d
    16d6:	8b 4d c8             	mov    -0x38(%rbp),%ecx
    16d9:	4c 89 f7             	mov    %r14,%rdi
    16dc:	e8 00 00 00 00       	callq  16e1 <afs_fill_map+0x1e1>
			16dd: R_X86_64_PC32	read_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:196 (discriminator 1)
            afs_assert(!ret, read_err, "could not read map block [%d:%u]", ret, entries_read % config->num_map_blocks);
    16e1:	85 c0                	test   %eax,%eax
    16e3:	0f 85 ad 00 00 00    	jne    1796 <afs_fill_map+0x296>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:197
            allocation_set(&context->vector, ptr_block->map_block_ptrs[j]);
    16e9:	41 8b 77 10          	mov    0x10(%r15),%esi
    16ed:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    16f1:	e8 00 00 00 00       	callq  16f6 <afs_fill_map+0x1f6>
			16f2: R_X86_64_PC32	allocation_set-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:205
            entries_left = config->num_blocks - entries_read;
    16f6:	8b 4b 18             	mov    0x18(%rbx),%ecx
    16f9:	44 89 ef             	mov    %r13d,%edi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:202
            map_block_entries = map_block_unused + config->unused_space_per_block;
    16fc:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    1700:	48 03 7d b0          	add    -0x50(%rbp),%rdi
    1704:	83 45 c0 01          	addl   $0x1,-0x40(%rbp)
    1708:	44 03 6d ac          	add    -0x54(%rbp),%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:205
            entries_left = config->num_blocks - entries_read;
    170c:	89 ca                	mov    %ecx,%edx
    170e:	44 29 e2             	sub    %r12d,%edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:206
            if (entries_left <= num_map_entries_per_block) {
    1711:	3b 55 cc             	cmp    -0x34(%rbp),%edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:202
            map_block_entries = map_block_unused + config->unused_space_per_block;
    1714:	49 8d 74 06 40       	lea    0x40(%r14,%rax,1),%rsi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:206
            if (entries_left <= num_map_entries_per_block) {
    1719:	77 a3                	ja     16be <afs_fill_map+0x1be>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:207
                memcpy(afs_map + (entries_read * map_entry_sz), map_block_entries, entries_left * map_entry_sz);
    171b:	0f af 55 a8          	imul   -0x58(%rbp),%edx
    171f:	41 89 cc             	mov    %ecx,%r12d
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    1722:	e8 00 00 00 00       	callq  1727 <afs_fill_map+0x227>
			1723: R_X86_64_PC32	memcpy-0x4
afs_fill_map():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:186
    for (i = 0; i < config->num_ptr_blocks; i++) {
    1727:	8b 45 c0             	mov    -0x40(%rbp),%eax
    172a:	39 43 20             	cmp    %eax,0x20(%rbx)
    172d:	0f 87 42 ff ff ff    	ja     1675 <afs_fill_map+0x175>
    1733:	44 89 e1             	mov    %r12d,%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:220

        // If we break into here because no more entries were left,
        // then clearly we shouldn't even have any more pointer blocks
        // left.
    }
    afs_action(entries_read == config->num_blocks, ret = -EIO, read_err,
    1736:	44 8b 43 18          	mov    0x18(%rbx),%r8d
    173a:	41 39 c8             	cmp    %ecx,%r8d
    173d:	0f 85 94 00 00 00    	jne    17d7 <afs_fill_map+0x2d7>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:222
        "read incorrect amount [%u:%u]", entries_read, config->num_blocks);
    afs_debug("pointer blocks' map blocks read");
    1743:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1749 <afs_fill_map+0x249>
			1745: R_X86_64_PC32	afs_debug_mode-0x4
    1749:	85 c0                	test   %eax,%eax
    174b:	0f 85 5f 01 00 00    	jne    18b0 <afs_fill_map+0x3b0>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:230
    kfree(map_block);
    return 0;

read_err:
    if (ptr_block)
        kfree(ptr_block);
    1751:	4c 89 ff             	mov    %r15,%rdi
    1754:	e8 00 00 00 00       	callq  1759 <afs_fill_map+0x259>
			1755: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:232
    if (map_block)
        kfree(map_block);
    1759:	4c 89 f7             	mov    %r14,%rdi
    175c:	e8 00 00 00 00       	callq  1761 <afs_fill_map+0x261>
			175d: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:236

err:
    return ret;
}
    1761:	8b 45 98             	mov    -0x68(%rbp),%eax
    1764:	48 83 c4 58          	add    $0x58,%rsp
    1768:	5b                   	pop    %rbx
    1769:	41 5c                	pop    %r12
    176b:	41 5d                	pop    %r13
    176d:	41 5e                	pop    %r14
    176f:	41 5f                	pop    %r15
    1771:	5d                   	pop    %rbp
    1772:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:187 (discriminator 2)
        next_block = (i == 0) ? sb->first_ptr_block : ptr_block->next_ptr_block;
    1773:	45 8b af fc 0f 00 00 	mov    0xffc(%r15),%r13d
    177a:	e9 0c ff ff ff       	jmpq   168b <afs_fill_map+0x18b>
    177f:	44 89 f8             	mov    %r15d,%eax
    1782:	44 89 65 98          	mov    %r12d,-0x68(%rbp)
    1786:	4c 8b 7d 88          	mov    -0x78(%rbp),%r15
    178a:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:180
            entries_read += num_map_entries_per_block;
    178e:	41 89 c4             	mov    %eax,%r12d
    1791:	e9 bf fe ff ff       	jmpq   1655 <afs_fill_map+0x155>
    1796:	41 89 c1             	mov    %eax,%r9d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:196
            afs_assert(!ret, read_err, "could not read map block [%d:%u]", ret, entries_read % config->num_map_blocks);
    1799:	31 d2                	xor    %edx,%edx
    179b:	44 89 e0             	mov    %r12d,%eax
    179e:	f7 73 1c             	divl   0x1c(%rbx)
    17a1:	44 89 c9             	mov    %r9d,%ecx
    17a4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			17a7: R_X86_64_32S	.rodata+0x138
    17ab:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			17ae: R_X86_64_32S	.rodata.str1.8+0xb98
    17b2:	31 c0                	xor    %eax,%eax
    17b4:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
    17b8:	41 89 d0             	mov    %edx,%r8d
    17bb:	ba c4 00 00 00       	mov    $0xc4,%edx
    17c0:	e8 00 00 00 00       	callq  17c5 <afs_fill_map+0x2c5>
			17c1: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:195
            ret = read_page(map_block, context->bdev, ptr_block->map_block_ptrs[j], data_sector_offset, false);
    17c5:	44 8b 4d cc          	mov    -0x34(%rbp),%r9d
    17c9:	44 89 4d 98          	mov    %r9d,-0x68(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:196
            afs_assert(!ret, read_err, "could not read map block [%d:%u]", ret, entries_read % config->num_map_blocks);
    17cd:	eb 82                	jmp    1751 <afs_fill_map+0x251>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:186
    for (i = 0; i < config->num_ptr_blocks; i++) {
    17cf:	44 89 e1             	mov    %r12d,%ecx
    17d2:	e9 5f ff ff ff       	jmpq   1736 <afs_fill_map+0x236>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:220 (discriminator 1)
    afs_action(entries_read == config->num_blocks, ret = -EIO, read_err,
    17d7:	ba dd 00 00 00       	mov    $0xdd,%edx
    17dc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			17df: R_X86_64_32S	.rodata+0x138
    17e3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			17e6: R_X86_64_32S	.rodata.str1.8+0xc50
    17ea:	31 c0                	xor    %eax,%eax
    17ec:	e8 00 00 00 00       	callq  17f1 <afs_fill_map+0x2f1>
			17ed: R_X86_64_PC32	printk-0x4
    17f1:	c7 45 98 fb ff ff ff 	movl   $0xfffffffb,-0x68(%rbp)
    17f8:	e9 54 ff ff ff       	jmpq   1751 <afs_fill_map+0x251>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:189 (discriminator 1)
        afs_assert(!ret, read_err, "could not read pointer block [%d:%u]", ret, i);
    17fd:	44 8b 45 c0          	mov    -0x40(%rbp),%r8d
    1801:	89 c1                	mov    %eax,%ecx
    1803:	89 45 cc             	mov    %eax,-0x34(%rbp)
    1806:	ba bd 00 00 00       	mov    $0xbd,%edx
    180b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			180e: R_X86_64_32S	.rodata+0x138
    1812:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1815: R_X86_64_32S	.rodata.str1.8+0xc10
    1819:	31 c0                	xor    %eax,%eax
    181b:	e8 00 00 00 00       	callq  1820 <afs_fill_map+0x320>
			181c: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:188 (discriminator 1)
        ret = read_page(ptr_block, context->bdev, next_block, data_sector_offset, false);
    1820:	44 8b 4d cc          	mov    -0x34(%rbp),%r9d
    1824:	44 89 4d 98          	mov    %r9d,-0x68(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:189 (discriminator 1)
        afs_assert(!ret, read_err, "could not read pointer block [%d:%u]", ret, i);
    1828:	e9 24 ff ff ff       	jmpq   1751 <afs_fill_map+0x251>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:183 (discriminator 1)
    afs_debug("super block's map blocks read");
    182d:	ba b7 00 00 00       	mov    $0xb7,%edx
    1832:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1835: R_X86_64_32S	.rodata+0x138
    1839:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			183c: R_X86_64_32S	.rodata.str1.8+0xbd8
    1840:	31 c0                	xor    %eax,%eax
    1842:	e8 00 00 00 00       	callq  1847 <afs_fill_map+0x347>
			1843: R_X86_64_PC32	printk-0x4
    1847:	e9 17 fe ff ff       	jmpq   1663 <afs_fill_map+0x163>
    184c:	44 89 f8             	mov    %r15d,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:164 (discriminator 1)
        afs_assert(!ret, read_err, "could not read map block [%d:%u]", ret, entries_read % config->num_map_blocks);
    184f:	31 d2                	xor    %edx,%edx
    1851:	44 89 e1             	mov    %r12d,%ecx
    1854:	f7 73 1c             	divl   0x1c(%rbx)
    1857:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			185a: R_X86_64_32S	.rodata+0x138
    185e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1861: R_X86_64_32S	.rodata.str1.8+0xb98
    1865:	31 c0                	xor    %eax,%eax
    1867:	4c 8b 7d 88          	mov    -0x78(%rbp),%r15
    186b:	4c 8b 75 c0          	mov    -0x40(%rbp),%r14
    186f:	44 89 65 98          	mov    %r12d,-0x68(%rbp)
    1873:	41 89 d0             	mov    %edx,%r8d
    1876:	ba a4 00 00 00       	mov    $0xa4,%edx
    187b:	e8 00 00 00 00       	callq  1880 <afs_fill_map+0x380>
			187c: R_X86_64_PC32	printk-0x4
    1880:	e9 cc fe ff ff       	jmpq   1751 <afs_fill_map+0x251>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:157 (discriminator 1)
    afs_action(map_block && ptr_block, ret = -ENOMEM, err, "could not allocate memory for map data [%d]", ret);
    1885:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    188a:	ba 9d 00 00 00       	mov    $0x9d,%edx
    188f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1892: R_X86_64_32S	.rodata+0x138
    1896:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1899: R_X86_64_32S	.rodata.str1.8+0xb50
    189d:	31 c0                	xor    %eax,%eax
    189f:	e8 00 00 00 00       	callq  18a4 <afs_fill_map+0x3a4>
			18a0: R_X86_64_PC32	printk-0x4
    18a4:	c7 45 98 f4 ff ff ff 	movl   $0xfffffff4,-0x68(%rbp)
    18ab:	e9 b1 fe ff ff       	jmpq   1761 <afs_fill_map+0x261>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:222 (discriminator 1)
    afs_debug("pointer blocks' map blocks read");
    18b0:	ba de 00 00 00       	mov    $0xde,%edx
    18b5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			18b8: R_X86_64_32S	.rodata+0x138
    18bc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			18bf: R_X86_64_32S	.rodata.str1.8+0xc88
    18c3:	31 c0                	xor    %eax,%eax
    18c5:	e8 00 00 00 00       	callq  18ca <afs_fill_map+0x3ca>
			18c6: R_X86_64_PC32	printk-0x4
    18ca:	e9 82 fe ff ff       	jmpq   1751 <afs_fill_map+0x251>
    18cf:	90                   	nop

00000000000018d0 <afs_create_map_blocks>:
afs_create_map_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:243
/**
 * Create the Artifice map blocks.
 */
int
afs_create_map_blocks(struct afs_private *context)
{
    18d0:	e8 00 00 00 00       	callq  18d5 <afs_create_map_blocks+0x5>
			18d1: R_X86_64_PC32	__fentry__-0x4
    18d5:	55                   	push   %rbp
    18d6:	48 89 e5             	mov    %rsp,%rbp
    18d9:	41 57                	push   %r15
    18db:	41 56                	push   %r14
    18dd:	41 55                	push   %r13
    18df:	41 54                	push   %r12
    18e1:	53                   	push   %rbx
    18e2:	48 89 fb             	mov    %rdi,%rbx
    18e5:	48 83 ec 38          	sub    $0x38,%rsp
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:260
    uint32_t entries_written;
    uint32_t entries_left;
    uint32_t i;
    int ret = 0;

    afs_map = context->afs_map;
    18e9:	48 8b 87 50 b0 03 00 	mov    0x3b050(%rdi),%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:263
    map_entry_sz = config->map_entry_sz;
    num_map_entries_per_block = config->num_map_entries_per_block;
    num_map_blocks = config->num_map_blocks;
    18f0:	44 8b 7f 1c          	mov    0x1c(%rdi),%r15d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:262
    num_map_entries_per_block = config->num_map_entries_per_block;
    18f4:	44 0f b6 6f 14       	movzbl 0x14(%rdi),%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:264
    num_blocks = config->num_blocks;
    18f9:	44 8b 77 18          	mov    0x18(%rdi),%r14d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:260
    afs_map = context->afs_map;
    18fd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:267

    // Allocate all required map_blocks.
    map_blocks = vmalloc(AFS_BLOCK_SIZE * num_map_blocks);
    1901:	45 89 f8             	mov    %r15d,%r8d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:261
    map_entry_sz = config->map_entry_sz;
    1904:	0f b6 47 12          	movzbl 0x12(%rdi),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:267
    map_blocks = vmalloc(AFS_BLOCK_SIZE * num_map_blocks);
    1908:	41 c1 e0 0c          	shl    $0xc,%r8d
    190c:	45 89 c4             	mov    %r8d,%r12d
    190f:	4c 89 e7             	mov    %r12,%rdi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:261
    map_entry_sz = config->map_entry_sz;
    1912:	88 45 c0             	mov    %al,-0x40(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:267
    map_blocks = vmalloc(AFS_BLOCK_SIZE * num_map_blocks);
    1915:	e8 00 00 00 00       	callq  191a <afs_create_map_blocks+0x4a>
			1916: R_X86_64_PC32	vmalloc-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:268
    afs_action(map_blocks, ret = -ENOMEM, block_err, "could not allocate map blocks [%d]", ret);
    191a:	48 85 c0             	test   %rax,%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:267
    map_blocks = vmalloc(AFS_BLOCK_SIZE * num_map_blocks);
    191d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:268
    afs_action(map_blocks, ret = -ENOMEM, block_err, "could not allocate map blocks [%d]", ret);
    1921:	0f 84 e5 00 00 00    	je     1a0c <afs_create_map_blocks+0x13c>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:269
    afs_debug("allocated Artifice map blocks");
    1927:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 192d <afs_create_map_blocks+0x5d>
			1929: R_X86_64_PC32	afs_debug_mode-0x4
    192d:	85 d2                	test   %edx,%edx
    192f:	0f 85 47 01 00 00    	jne    1a7c <afs_create_map_blocks+0x1ac>
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    1935:	4c 89 e2             	mov    %r12,%rdx
    1938:	4c 8b 65 a8          	mov    -0x58(%rbp),%r12
    193c:	31 f6                	xor    %esi,%esi
    193e:	4c 89 e7             	mov    %r12,%rdi
    1941:	e8 00 00 00 00       	callq  1946 <afs_create_map_blocks+0x76>
			1942: R_X86_64_PC32	memset-0x4
afs_create_map_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:275

    memset(map_blocks, 0, AFS_BLOCK_SIZE * num_map_blocks);
    entries_written = 0;

    ptr = map_blocks;
    for (i = 0; i < num_map_blocks; i++) {
    1946:	45 85 ff             	test   %r15d,%r15d
    1949:	0f 84 92 00 00 00    	je     19e1 <afs_create_map_blocks+0x111>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:285
        entries_left = num_blocks - entries_written;
        if (entries_left <= num_map_entries_per_block) {
            memcpy(entries_start, afs_map + (entries_written * map_entry_sz), entries_left * map_entry_sz);
            entries_written += entries_left;
        } else {
            memcpy(entries_start, afs_map + (entries_written * map_entry_sz), num_map_entries_per_block * map_entry_sz);
    194f:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
    1953:	89 45 bc             	mov    %eax,-0x44(%rbp)
    1956:	41 0f af c5          	imul   %r13d,%eax
    195a:	48 98                	cltq   
    195c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    1960:	41 8d 47 ff          	lea    -0x1(%r15),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:272
    entries_written = 0;
    1964:	45 31 ff             	xor    %r15d,%r15d
    1967:	48 83 c0 01          	add    $0x1,%rax
    196b:	48 c1 e0 0c          	shl    $0xc,%rax
    196f:	4c 01 e0             	add    %r12,%rax
    1972:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    1976:	eb 34                	jmp    19ac <afs_create_map_blocks+0xdc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:282
            memcpy(entries_start, afs_map + (entries_written * map_entry_sz), entries_left * map_entry_sz);
    1978:	0f af d0             	imul   %eax,%edx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    197b:	4c 89 c7             	mov    %r8,%rdi
afs_create_map_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:264
    num_blocks = config->num_blocks;
    197e:	45 89 f7             	mov    %r14d,%r15d
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    1981:	e8 00 00 00 00       	callq  1986 <afs_create_map_blocks+0xb6>
			1982: R_X86_64_PC32	memcpy-0x4
    1986:	49 89 c0             	mov    %rax,%r8
afs_create_map_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:289 (discriminator 2)
            entries_written += num_map_entries_per_block;
        }

        hash_sha512(entries_start, AFS_BLOCK_SIZE - SHA512_SZ - config->unused_space_per_block, hash);
    1989:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
    198d:	be c0 0f 00 00       	mov    $0xfc0,%esi
    1992:	4c 89 e2             	mov    %r12,%rdx
    1995:	4c 89 c7             	mov    %r8,%rdi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:290 (discriminator 2)
        ptr += AFS_BLOCK_SIZE;
    1998:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:289 (discriminator 2)
        hash_sha512(entries_start, AFS_BLOCK_SIZE - SHA512_SZ - config->unused_space_per_block, hash);
    199f:	29 c6                	sub    %eax,%esi
    19a1:	e8 00 00 00 00       	callq  19a6 <afs_create_map_blocks+0xd6>
			19a2: R_X86_64_PC32	hash_sha512-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:275 (discriminator 2)
    for (i = 0; i < num_map_blocks; i++) {
    19a6:	4c 3b 65 c0          	cmp    -0x40(%rbp),%r12
    19aa:	74 35                	je     19e1 <afs_create_map_blocks+0x111>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:278
        entries_start = unused_space + config->unused_space_per_block;
    19ac:	0f b6 43 13          	movzbl 0x13(%rbx),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:280
        entries_left = num_blocks - entries_written;
    19b0:	44 89 f2             	mov    %r14d,%edx
    19b3:	44 29 fa             	sub    %r15d,%edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:278
        entries_start = unused_space + config->unused_space_per_block;
    19b6:	4d 8d 44 04 40       	lea    0x40(%r12,%rax,1),%r8
    19bb:	8b 45 bc             	mov    -0x44(%rbp),%eax
    19be:	89 c6                	mov    %eax,%esi
    19c0:	41 0f af f7          	imul   %r15d,%esi
    19c4:	48 03 75 c8          	add    -0x38(%rbp),%rsi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:281
        if (entries_left <= num_map_entries_per_block) {
    19c8:	44 39 ea             	cmp    %r13d,%edx
    19cb:	76 ab                	jbe    1978 <afs_create_map_blocks+0xa8>
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    19cd:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    19d1:	4c 89 c7             	mov    %r8,%rdi
afs_create_map_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:286
            entries_written += num_map_entries_per_block;
    19d4:	45 01 ef             	add    %r13d,%r15d
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    19d7:	e8 00 00 00 00       	callq  19dc <afs_create_map_blocks+0x10c>
			19d8: R_X86_64_PC32	memcpy-0x4
    19dc:	49 89 c0             	mov    %rax,%r8
    19df:	eb a8                	jmp    1989 <afs_create_map_blocks+0xb9>
afs_create_map_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:292
    }
    afs_action(entries_written == num_blocks, ret = -EIO, write_err,
    19e1:	45 39 fe             	cmp    %r15d,%r14d
    19e4:	75 66                	jne    1a4c <afs_create_map_blocks+0x17c>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:294
        "wrote incorrect amount [%u:%u]", entries_written, num_blocks);
    afs_debug("initialized Artifice map blocks");
    19e6:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 19ec <afs_create_map_blocks+0x11c>
			19e8: R_X86_64_PC32	afs_debug_mode-0x4
    19ec:	85 c0                	test   %eax,%eax
    19ee:	75 40                	jne    1a30 <afs_create_map_blocks+0x160>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:296

    context->afs_map_blocks = map_blocks;
    19f0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    19f4:	48 89 83 58 b0 03 00 	mov    %rax,0x3b058(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:297
    return 0;
    19fb:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:304
write_err:
    vfree(map_blocks);

block_err:
    return ret;
}
    19fd:	48 83 c4 38          	add    $0x38,%rsp
    1a01:	5b                   	pop    %rbx
    1a02:	41 5c                	pop    %r12
    1a04:	41 5d                	pop    %r13
    1a06:	41 5e                	pop    %r14
    1a08:	41 5f                	pop    %r15
    1a0a:	5d                   	pop    %rbp
    1a0b:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:268 (discriminator 1)
    afs_action(map_blocks, ret = -ENOMEM, block_err, "could not allocate map blocks [%d]", ret);
    1a0c:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    1a11:	ba 0c 01 00 00       	mov    $0x10c,%edx
    1a16:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1a19: R_X86_64_32S	.rodata+0x120
    1a1d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1a20: R_X86_64_32S	.rodata.str1.8+0xcc8
    1a24:	e8 00 00 00 00       	callq  1a29 <afs_create_map_blocks+0x159>
			1a25: R_X86_64_PC32	printk-0x4
    1a29:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    1a2e:	eb cd                	jmp    19fd <afs_create_map_blocks+0x12d>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:294 (discriminator 1)
    afs_debug("initialized Artifice map blocks");
    1a30:	ba 26 01 00 00       	mov    $0x126,%edx
    1a35:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1a38: R_X86_64_32S	.rodata+0x120
    1a3c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1a3f: R_X86_64_32S	.rodata.str1.8+0xd78
    1a43:	31 c0                	xor    %eax,%eax
    1a45:	e8 00 00 00 00       	callq  1a4a <afs_create_map_blocks+0x17a>
			1a46: R_X86_64_PC32	printk-0x4
    1a4a:	eb a4                	jmp    19f0 <afs_create_map_blocks+0x120>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:292 (discriminator 1)
    afs_action(entries_written == num_blocks, ret = -EIO, write_err,
    1a4c:	45 89 f0             	mov    %r14d,%r8d
    1a4f:	44 89 f9             	mov    %r15d,%ecx
    1a52:	ba 25 01 00 00       	mov    $0x125,%edx
    1a57:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1a5a: R_X86_64_32S	.rodata+0x120
    1a5e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1a61: R_X86_64_32S	.rodata.str1.8+0xd40
    1a65:	31 c0                	xor    %eax,%eax
    1a67:	e8 00 00 00 00       	callq  1a6c <afs_create_map_blocks+0x19c>
			1a68: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:300 (discriminator 1)
    vfree(map_blocks);
    1a6c:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    1a70:	e8 00 00 00 00       	callq  1a75 <afs_create_map_blocks+0x1a5>
			1a71: R_X86_64_PC32	vfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:292 (discriminator 1)
    afs_action(entries_written == num_blocks, ret = -EIO, write_err,
    1a75:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    1a7a:	eb 81                	jmp    19fd <afs_create_map_blocks+0x12d>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:269 (discriminator 1)
    afs_debug("allocated Artifice map blocks");
    1a7c:	ba 0d 01 00 00       	mov    $0x10d,%edx
    1a81:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1a84: R_X86_64_32S	.rodata+0x120
    1a88:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1a8b: R_X86_64_32S	.rodata.str1.8+0xd08
    1a8f:	31 c0                	xor    %eax,%eax
    1a91:	e8 00 00 00 00       	callq  1a96 <afs_create_map_blocks+0x1c6>
			1a92: R_X86_64_PC32	printk-0x4
    1a96:	e9 9a fe ff ff       	jmpq   1935 <afs_create_map_blocks+0x65>
    1a9b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000001aa0 <write_map_blocks>:
write_map_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:311
/**
 * Write map blocks to pointer blocks.
 */
int
write_map_blocks(struct afs_private *context, bool update)
{
    1aa0:	e8 00 00 00 00       	callq  1aa5 <write_map_blocks+0x5>
			1aa1: R_X86_64_PC32	__fentry__-0x4
    1aa5:	55                   	push   %rbp
    1aa6:	48 89 e5             	mov    %rsp,%rbp
    1aa9:	41 57                	push   %r15
    1aab:	41 56                	push   %r14
    1aad:	41 55                	push   %r13
    1aaf:	41 54                	push   %r12
    1ab1:	53                   	push   %rbx
    1ab2:	48 83 ec 58          	sub    $0x58,%rsp
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:323
    uint32_t num_ptr_blocks;
    uint32_t blocks_written;
    uint32_t blocks_left;
    uint32_t block_num;
    int64_t i, j;
    uint32_t data_sector_offset = context->passive_fs.data_start_off;
    1ab6:	8b 87 14 20 00 00    	mov    0x2014(%rdi),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:331
    sb = &context->super_block;
    fs = &context->passive_fs;
    afs_map_blocks = context->afs_map_blocks;

    num_map_blocks = config->num_map_blocks;
    num_ptr_blocks = config->num_ptr_blocks;
    1abc:	8b 4f 20             	mov    0x20(%rdi),%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:323
    uint32_t data_sector_offset = context->passive_fs.data_start_off;
    1abf:	89 45 cc             	mov    %eax,-0x34(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:327
    fs = &context->passive_fs;
    1ac2:	48 8d 87 00 20 00 00 	lea    0x2000(%rdi),%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:331
    num_ptr_blocks = config->num_ptr_blocks;
    1ac9:	89 4d a0             	mov    %ecx,-0x60(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:327
    fs = &context->passive_fs;
    1acc:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:328
    afs_map_blocks = context->afs_map_blocks;
    1ad0:	48 8b 87 58 b0 03 00 	mov    0x3b058(%rdi),%rax
    1ad7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:330
    num_map_blocks = config->num_map_blocks;
    1adb:	8b 47 1c             	mov    0x1c(%rdi),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:337

    // First utilize all the map block pointers from the super block.
    blocks_written = 0;
    for (i = 0; i < NUM_MAP_BLKS_IN_SB; i++) {
        blocks_left = num_map_blocks - blocks_written;
        if (!blocks_left) {
    1ade:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:330
    num_map_blocks = config->num_map_blocks;
    1ae0:	89 45 c8             	mov    %eax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:337
        if (!blocks_left) {
    1ae3:	0f 84 9c 00 00 00    	je     1b85 <write_map_blocks+0xe5>
    1ae9:	8b 45 c8             	mov    -0x38(%rbp),%eax
    1aec:	41 89 f6             	mov    %esi,%r14d
    1aef:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
    1af3:	44 8d 78 ff          	lea    -0x1(%rax),%r15d
    1af7:	49 8d 47 01          	lea    0x1(%r15),%rax
    1afb:	44 89 7d 94          	mov    %r15d,-0x6c(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:335
    for (i = 0; i < NUM_MAP_BLKS_IN_SB; i++) {
    1aff:	45 31 ff             	xor    %r15d,%r15d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:343
            afs_debug("super block map block pointers filled");
            return 0;
        }

        if (!update) {
            block_num = acquire_block(fs, &context->vector);
    1b02:	4d 89 fd             	mov    %r15,%r13
    1b05:	49 89 ff             	mov    %rdi,%r15
    1b08:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    1b0c:	48 8d 87 08 21 00 00 	lea    0x2108(%rdi),%rax
    1b13:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    1b17:	eb 42                	jmp    1b5b <write_map_blocks+0xbb>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:347
            afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
            sb->map_block_ptrs[i] = block_num;
        } else {
            block_num = sb->map_block_ptrs[i];
    1b19:	43 8b 94 af c0 10 00 	mov    0x10c0(%r15,%r13,4),%edx
    1b20:	00 
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:349
        }
        ret = write_page(afs_map_blocks + (blocks_written * AFS_BLOCK_SIZE), context->bdev, block_num, data_sector_offset, true);
    1b21:	49 8b 77 08          	mov    0x8(%r15),%rsi
    1b25:	8b 4d cc             	mov    -0x34(%rbp),%ecx
    1b28:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    1b2e:	4c 89 e7             	mov    %r12,%rdi
    1b31:	e8 00 00 00 00       	callq  1b36 <write_map_blocks+0x96>
			1b32: R_X86_64_PC32	write_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:350
        afs_assert(!ret, done, "could not write blocks [%d:%u]", ret, blocks_written);
    1b36:	85 c0                	test   %eax,%eax
    1b38:	0f 85 d0 01 00 00    	jne    1d0e <write_map_blocks+0x26e>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:335 (discriminator 2)
    for (i = 0; i < NUM_MAP_BLKS_IN_SB; i++) {
    1b3e:	49 83 c5 01          	add    $0x1,%r13
    1b42:	83 c3 01             	add    $0x1,%ebx
    1b45:	49 81 fd cf 03 00 00 	cmp    $0x3cf,%r13
    1b4c:	74 5a                	je     1ba8 <write_map_blocks+0x108>
    1b4e:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:337
        if (!blocks_left) {
    1b55:	4c 3b 6d c0          	cmp    -0x40(%rbp),%r13
    1b59:	74 2a                	je     1b85 <write_map_blocks+0xe5>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:342
        if (!update) {
    1b5b:	45 84 f6             	test   %r14b,%r14b
    1b5e:	44 89 eb             	mov    %r13d,%ebx
    1b61:	75 b6                	jne    1b19 <write_map_blocks+0x79>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:343
            block_num = acquire_block(fs, &context->vector);
    1b63:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    1b67:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    1b6b:	e8 00 00 00 00       	callq  1b70 <write_map_blocks+0xd0>
			1b6c: R_X86_64_PC32	acquire_block-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:344
            afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1b70:	83 f8 ff             	cmp    $0xffffffff,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:343
            block_num = acquire_block(fs, &context->vector);
    1b73:	89 c2                	mov    %eax,%edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:344
            afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1b75:	0f 84 e3 01 00 00    	je     1d5e <write_map_blocks+0x2be>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:345
            sb->map_block_ptrs[i] = block_num;
    1b7b:	43 89 84 af c0 10 00 	mov    %eax,0x10c0(%r15,%r13,4)
    1b82:	00 
    1b83:	eb 9c                	jmp    1b21 <write_map_blocks+0x81>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:338
            afs_debug("super block map block pointers filled");
    1b85:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 1b8b <write_map_blocks+0xeb>
			1b87: R_X86_64_PC32	afs_debug_mode-0x4
    1b8b:	85 c9                	test   %ecx,%ecx
    1b8d:	0f 85 d2 01 00 00    	jne    1d65 <write_map_blocks+0x2c5>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:377 (discriminator 1)
            afs_assert(!ret, done, "could not write block [%d:%u]", ret, blocks_written);
            blocks_written += 1;
        }
    }
    afs_debug("pointer blocks map block pointers filled");
    ret = 0;
    1b93:	45 31 d2             	xor    %r10d,%r10d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:381

done:
    return ret;
}
    1b96:	48 83 c4 58          	add    $0x58,%rsp
    1b9a:	44 89 d0             	mov    %r10d,%eax
    1b9d:	5b                   	pop    %rbx
    1b9e:	41 5c                	pop    %r12
    1ba0:	41 5d                	pop    %r13
    1ba2:	41 5e                	pop    %r14
    1ba4:	41 5f                	pop    %r15
    1ba6:	5d                   	pop    %rbp
    1ba7:	c3                   	retq   
    1ba8:	8b 45 a0             	mov    -0x60(%rbp),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:353
    afs_debug("super block map block pointers filled");
    1bab:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 1bb1 <write_map_blocks+0x111>
			1bad: R_X86_64_PC32	afs_debug_mode-0x4
    1bb1:	4d 89 fd             	mov    %r15,%r13
    1bb4:	85 d2                	test   %edx,%edx
    1bb6:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    1bba:	0f 85 ca 00 00 00    	jne    1c8a <write_map_blocks+0x1ea>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:357
    for (i = 0; i < num_ptr_blocks; i++) {
    1bc0:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:356
    afs_ptr_blocks = context->afs_ptr_blocks;
    1bc5:	49 8b 87 60 b0 03 00 	mov    0x3b060(%r15),%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:357
    for (i = 0; i < num_ptr_blocks; i++) {
    1bcc:	74 c5                	je     1b93 <write_map_blocks+0xf3>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:365
                block_num = acquire_block(fs, &context->vector);
    1bce:	49 8d 8d 08 21 00 00 	lea    0x2108(%r13),%rcx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:335
    for (i = 0; i < NUM_MAP_BLKS_IN_SB; i++) {
    1bd5:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
    1bdc:	00 
    1bdd:	49 89 c7             	mov    %rax,%r15
    1be0:	44 88 75 b0          	mov    %r14b,-0x50(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:365
                block_num = acquire_block(fs, &context->vector);
    1be4:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:360
            if (!blocks_left) {
    1be8:	3b 5d c8             	cmp    -0x38(%rbp),%ebx
    1beb:	74 7b                	je     1c68 <write_map_blocks+0x1c8>
    1bed:	8b 45 94             	mov    -0x6c(%rbp),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:369
                block_num = afs_ptr_blocks[i].map_block_ptrs[j];
    1bf0:	41 89 dc             	mov    %ebx,%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:358
        for (j = 0; j < NUM_MAP_BLKS_IN_PB; j++) {
    1bf3:	45 31 f6             	xor    %r14d,%r14d
    1bf6:	29 d8                	sub    %ebx,%eax
    1bf8:	48 83 c0 01          	add    $0x1,%rax
    1bfc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    1c00:	eb 41                	jmp    1c43 <write_map_blocks+0x1a3>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:369
                block_num = afs_ptr_blocks[i].map_block_ptrs[j];
    1c02:	43 8b 54 b7 10       	mov    0x10(%r15,%r14,4),%edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:371
            ret = write_page(afs_map_blocks + (blocks_written * AFS_BLOCK_SIZE), context->bdev, block_num, data_sector_offset, true);
    1c07:	42 8d 3c 33          	lea    (%rbx,%r14,1),%edi
    1c0b:	49 8b 75 08          	mov    0x8(%r13),%rsi
    1c0f:	8b 4d cc             	mov    -0x34(%rbp),%ecx
    1c12:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    1c18:	c1 e7 0c             	shl    $0xc,%edi
    1c1b:	48 03 7d b8          	add    -0x48(%rbp),%rdi
    1c1f:	e8 00 00 00 00       	callq  1c24 <write_map_blocks+0x184>
			1c20: R_X86_64_PC32	write_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:372
            afs_assert(!ret, done, "could not write block [%d:%u]", ret, blocks_written);
    1c24:	85 c0                	test   %eax,%eax
    1c26:	0f 85 b7 00 00 00    	jne    1ce3 <write_map_blocks+0x243>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:358 (discriminator 2)
        for (j = 0; j < NUM_MAP_BLKS_IN_PB; j++) {
    1c2c:	49 83 c6 01          	add    $0x1,%r14
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:373 (discriminator 2)
            blocks_written += 1;
    1c30:	41 83 c4 01          	add    $0x1,%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:358 (discriminator 2)
        for (j = 0; j < NUM_MAP_BLKS_IN_PB; j++) {
    1c34:	49 81 fe fb 03 00 00 	cmp    $0x3fb,%r14
    1c3b:	74 2f                	je     1c6c <write_map_blocks+0x1cc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:360
            if (!blocks_left) {
    1c3d:	4c 39 75 c0          	cmp    %r14,-0x40(%rbp)
    1c41:	74 29                	je     1c6c <write_map_blocks+0x1cc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:364
            if (!update) {
    1c43:	80 7d b0 00          	cmpb   $0x0,-0x50(%rbp)
    1c47:	75 b9                	jne    1c02 <write_map_blocks+0x162>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:365
                block_num = acquire_block(fs, &context->vector);
    1c49:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    1c4d:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    1c51:	e8 00 00 00 00       	callq  1c56 <write_map_blocks+0x1b6>
			1c52: R_X86_64_PC32	acquire_block-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:366
                afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1c56:	83 f8 ff             	cmp    $0xffffffff,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:365
                block_num = acquire_block(fs, &context->vector);
    1c59:	89 c2                	mov    %eax,%edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:366
                afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1c5b:	0f 84 d8 00 00 00    	je     1d39 <write_map_blocks+0x299>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:367
                afs_ptr_blocks[i].map_block_ptrs[j] = block_num;
    1c61:	43 89 44 b7 10       	mov    %eax,0x10(%r15,%r14,4)
    1c66:	eb 9f                	jmp    1c07 <write_map_blocks+0x167>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:360
            if (!blocks_left) {
    1c68:	44 8b 65 c8          	mov    -0x38(%rbp),%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:357 (discriminator 2)
    for (i = 0; i < num_ptr_blocks; i++) {
    1c6c:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
    1c71:	49 81 c7 00 10 00 00 	add    $0x1000,%r15
    1c78:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    1c7c:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
    1c80:	7d 34                	jge    1cb6 <write_map_blocks+0x216>
    1c82:	44 89 e3             	mov    %r12d,%ebx
    1c85:	e9 5e ff ff ff       	jmpq   1be8 <write_map_blocks+0x148>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:353 (discriminator 1)
    afs_debug("super block map block pointers filled");
    1c8a:	31 c0                	xor    %eax,%eax
    1c8c:	ba 61 01 00 00       	mov    $0x161,%edx
    1c91:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1c94: R_X86_64_32S	.rodata+0x100
    1c98:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1c9b: R_X86_64_32S	.rodata.str1.8+0xdb8
    1c9f:	e8 00 00 00 00       	callq  1ca4 <write_map_blocks+0x204>
			1ca0: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:357 (discriminator 1)
    for (i = 0; i < num_ptr_blocks; i++) {
    1ca4:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:356 (discriminator 1)
    afs_ptr_blocks = context->afs_ptr_blocks;
    1ca9:	49 8b 87 60 b0 03 00 	mov    0x3b060(%r15),%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:357 (discriminator 1)
    for (i = 0; i < num_ptr_blocks; i++) {
    1cb0:	0f 85 18 ff ff ff    	jne    1bce <write_map_blocks+0x12e>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:376
    afs_debug("pointer blocks map block pointers filled");
    1cb6:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1cbc <write_map_blocks+0x21c>
			1cb8: R_X86_64_PC32	afs_debug_mode-0x4
    1cbc:	85 c0                	test   %eax,%eax
    1cbe:	0f 84 cf fe ff ff    	je     1b93 <write_map_blocks+0xf3>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:376 (discriminator 1)
    1cc4:	ba 78 01 00 00       	mov    $0x178,%edx
    1cc9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1ccc: R_X86_64_32S	.rodata+0x100
    1cd0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1cd3: R_X86_64_32S	.rodata.str1.8+0xe98
    1cd7:	31 c0                	xor    %eax,%eax
    1cd9:	e8 00 00 00 00       	callq  1cde <write_map_blocks+0x23e>
			1cda: R_X86_64_PC32	printk-0x4
    1cde:	e9 b0 fe ff ff       	jmpq   1b93 <write_map_blocks+0xf3>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:372 (discriminator 1)
            afs_assert(!ret, done, "could not write block [%d:%u]", ret, blocks_written);
    1ce3:	89 c1                	mov    %eax,%ecx
    1ce5:	89 45 cc             	mov    %eax,-0x34(%rbp)
    1ce8:	45 89 e0             	mov    %r12d,%r8d
    1ceb:	ba 74 01 00 00       	mov    $0x174,%edx
    1cf0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1cf3: R_X86_64_32S	.rodata+0x100
    1cf7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1cfa: R_X86_64_32S	.rodata.str1.8+0xe60
    1cfe:	31 c0                	xor    %eax,%eax
    1d00:	e8 00 00 00 00       	callq  1d05 <write_map_blocks+0x265>
			1d01: R_X86_64_PC32	printk-0x4
    1d05:	44 8b 55 cc          	mov    -0x34(%rbp),%r10d
    1d09:	e9 88 fe ff ff       	jmpq   1b96 <write_map_blocks+0xf6>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:350 (discriminator 1)
        afs_assert(!ret, done, "could not write blocks [%d:%u]", ret, blocks_written);
    1d0e:	89 c1                	mov    %eax,%ecx
    1d10:	89 45 cc             	mov    %eax,-0x34(%rbp)
    1d13:	41 89 d8             	mov    %ebx,%r8d
    1d16:	ba 5e 01 00 00       	mov    $0x15e,%edx
    1d1b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1d1e: R_X86_64_32S	.rodata+0x100
    1d22:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1d25: R_X86_64_32S	.rodata.str1.8+0xe28
    1d29:	31 c0                	xor    %eax,%eax
    1d2b:	e8 00 00 00 00       	callq  1d30 <write_map_blocks+0x290>
			1d2c: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:349 (discriminator 1)
        ret = write_page(afs_map_blocks + (blocks_written * AFS_BLOCK_SIZE), context->bdev, block_num, data_sector_offset, true);
    1d30:	44 8b 55 cc          	mov    -0x34(%rbp),%r10d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:350 (discriminator 1)
        afs_assert(!ret, done, "could not write blocks [%d:%u]", ret, blocks_written);
    1d34:	e9 5d fe ff ff       	jmpq   1b96 <write_map_blocks+0xf6>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:366 (discriminator 1)
                afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1d39:	ba 6e 01 00 00       	mov    $0x16e,%edx
    1d3e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1d41: R_X86_64_32S	.rodata+0x100
    1d45:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1d48: R_X86_64_32S	.rodata.str1.8+0xdf8
    1d4c:	31 c0                	xor    %eax,%eax
    1d4e:	e8 00 00 00 00       	callq  1d53 <write_map_blocks+0x2b3>
			1d4f: R_X86_64_PC32	printk-0x4
    1d53:	41 ba e4 ff ff ff    	mov    $0xffffffe4,%r10d
    1d59:	e9 38 fe ff ff       	jmpq   1b96 <write_map_blocks+0xf6>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:344 (discriminator 1)
            afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1d5e:	ba 58 01 00 00       	mov    $0x158,%edx
    1d63:	eb d9                	jmp    1d3e <write_map_blocks+0x29e>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:338 (discriminator 1)
            afs_debug("super block map block pointers filled");
    1d65:	ba 52 01 00 00       	mov    $0x152,%edx
    1d6a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1d6d: R_X86_64_32S	.rodata+0x100
    1d71:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1d74: R_X86_64_32S	.rodata.str1.8+0xdb8
    1d78:	31 c0                	xor    %eax,%eax
    1d7a:	e8 00 00 00 00       	callq  1d7f <write_map_blocks+0x2df>
			1d7b: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:339 (discriminator 1)
            return 0;
    1d7f:	45 31 d2             	xor    %r10d,%r10d
    1d82:	e9 0f fe ff ff       	jmpq   1b96 <write_map_blocks+0xf6>
    1d87:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    1d8e:	00 00 

0000000000001d90 <write_ptr_blocks>:
write_ptr_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:388
/**
 * Write out the ptr blocks to disk.
 */
int
write_ptr_blocks(struct afs_super_block *sb, struct afs_passive_fs *fs, struct afs_private *context)
{
    1d90:	e8 00 00 00 00       	callq  1d95 <write_ptr_blocks+0x5>
			1d91: R_X86_64_PC32	__fentry__-0x4
    1d95:	55                   	push   %rbp
    1d96:	48 89 e5             	mov    %rsp,%rbp
    1d99:	41 57                	push   %r15
    1d9b:	41 56                	push   %r14
    1d9d:	41 55                	push   %r13
    1d9f:	41 54                	push   %r12
    1da1:	49 89 d6             	mov    %rdx,%r14
    1da4:	53                   	push   %rbx
    1da5:	48 83 ec 58          	sub    $0x58,%rsp
    1da9:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
    1dad:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
    1db1:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1db8:	00 00 
    1dba:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    1dbe:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:395
    struct afs_ptr_block *ptr_blocks = NULL;
    uint8_t ptr_block_digest[SHA1_SZ];
    uint32_t num_ptr_blocks;
    uint32_t block_num;
    int64_t i;
    uint32_t data_sector_offset = context->passive_fs.data_start_off;
    1dc0:	8b 82 14 20 00 00    	mov    0x2014(%rdx),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:399
    int ret = 0;

    // Write all the map blocks.
    ret = write_map_blocks(context, false);
    1dc6:	31 f6                	xor    %esi,%esi
    1dc8:	48 89 d7             	mov    %rdx,%rdi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:395
    uint32_t data_sector_offset = context->passive_fs.data_start_off;
    1dcb:	89 45 a4             	mov    %eax,-0x5c(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:399
    ret = write_map_blocks(context, false);
    1dce:	e8 00 00 00 00       	callq  1dd3 <write_ptr_blocks+0x43>
			1dcf: R_X86_64_PC32	write_map_blocks-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:400
    afs_assert(!ret, done, "could not write Artifice map blocks [%d]", ret);
    1dd3:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:399
    ret = write_map_blocks(context, false);
    1dd5:	89 45 a0             	mov    %eax,-0x60(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:400
    afs_assert(!ret, done, "could not write Artifice map blocks [%d]", ret);
    1dd8:	0f 85 58 01 00 00    	jne    1f36 <write_ptr_blocks+0x1a6>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:402

    num_ptr_blocks = config->num_ptr_blocks;
    1dde:	41 8b 46 20          	mov    0x20(%r14),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:403
    if (!num_ptr_blocks) {
    1de2:	85 c0                	test   %eax,%eax
    1de4:	0f 84 a7 00 00 00    	je     1e91 <write_ptr_blocks+0x101>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:410
    }

    // Write out the ptr blocks themselves to disk. Needs to be done in reverse
    // as ptr blocks themselves hold pointers to other ptr blocks.
    ptr_blocks = context->afs_ptr_blocks;
    for (i = num_ptr_blocks - 1; i >= 0; i--) {
    1dea:	44 8d 60 ff          	lea    -0x1(%rax),%r12d
    1dee:	49 8d 86 08 21 00 00 	lea    0x2108(%r14),%rax
    1df5:	49 8b 96 60 b0 03 00 	mov    0x3b060(%r14),%rdx
    1dfc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    1e00:	4c 89 e0             	mov    %r12,%rax
    1e03:	4c 89 65 90          	mov    %r12,-0x70(%rbp)
    1e07:	48 c1 e0 0c          	shl    $0xc,%rax
    1e0b:	48 8d 5c 02 10       	lea    0x10(%rdx,%rax,1),%rbx
    1e10:	eb 0f                	jmp    1e21 <write_ptr_blocks+0x91>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:430
        afs_assert(!ret, done, "could not write ptr block [%d:%llu]", ret, i);

        if (i == 0) {
            sb->first_ptr_block = block_num;
        } else {
            ptr_blocks[i - 1].next_ptr_block = block_num;
    1e12:	44 89 7b ec          	mov    %r15d,-0x14(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:410
    for (i = num_ptr_blocks - 1; i >= 0; i--) {
    1e16:	49 83 ec 01          	sub    $0x1,%r12
    1e1a:	48 81 eb 00 10 00 00 	sub    $0x1000,%rbx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:413
        if (i == num_ptr_blocks - 1) {
    1e21:	4c 39 65 90          	cmp    %r12,-0x70(%rbp)
    1e25:	4c 8d 6b f0          	lea    -0x10(%rbx),%r13
    1e29:	0f 84 87 00 00 00    	je     1eb6 <write_ptr_blocks+0x126>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:418
        hash_sha1((uint8_t *)(ptr_blocks + i) + SHA128_SZ, sizeof(*ptr_blocks) - SHA128_SZ, ptr_block_digest);
    1e2f:	48 8d 55 b0          	lea    -0x50(%rbp),%rdx
    1e33:	be f0 0f 00 00       	mov    $0xff0,%esi
    1e38:	48 89 df             	mov    %rbx,%rdi
    1e3b:	e8 00 00 00 00       	callq  1e40 <write_ptr_blocks+0xb0>
			1e3c: R_X86_64_PC32	hash_sha1-0x4
    1e40:	c5 f9 6f 45 b0       	vmovdqa -0x50(%rbp),%xmm0
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:422
        block_num = acquire_block(fs, &context->vector);
    1e45:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    1e49:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    1e4d:	c5 f8 11 43 f0       	vmovups %xmm0,-0x10(%rbx)
    1e52:	e8 00 00 00 00       	callq  1e57 <write_ptr_blocks+0xc7>
			1e53: R_X86_64_PC32	acquire_block-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:423
        afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1e57:	83 f8 ff             	cmp    $0xffffffff,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:422
        block_num = acquire_block(fs, &context->vector);
    1e5a:	41 89 c7             	mov    %eax,%r15d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:423
        afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1e5d:	74 66                	je     1ec5 <write_ptr_blocks+0x135>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:424
        ret = write_page(ptr_blocks + i, context->bdev, block_num, data_sector_offset, false);
    1e5f:	49 8b 76 08          	mov    0x8(%r14),%rsi
    1e63:	8b 4d a4             	mov    -0x5c(%rbp),%ecx
    1e66:	45 31 c0             	xor    %r8d,%r8d
    1e69:	89 c2                	mov    %eax,%edx
    1e6b:	4c 89 ef             	mov    %r13,%rdi
    1e6e:	e8 00 00 00 00       	callq  1e73 <write_ptr_blocks+0xe3>
			1e6f: R_X86_64_PC32	write_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:425
        afs_assert(!ret, done, "could not write ptr block [%d:%llu]", ret, i);
    1e73:	85 c0                	test   %eax,%eax
    1e75:	75 71                	jne    1ee8 <write_ptr_blocks+0x158>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:427
        if (i == 0) {
    1e77:	4d 85 e4             	test   %r12,%r12
    1e7a:	75 96                	jne    1e12 <write_ptr_blocks+0x82>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:428
            sb->first_ptr_block = block_num;
    1e7c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    1e80:	44 89 b8 fc 0f 00 00 	mov    %r15d,0xffc(%rax)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:433
        }
    }
    afs_debug("pointer blocks written");
    1e87:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 1e8d <write_ptr_blocks+0xfd>
			1e89: R_X86_64_PC32	afs_debug_mode-0x4
    1e8d:	85 c0                	test   %eax,%eax
    1e8f:	75 7f                	jne    1f10 <write_ptr_blocks+0x180>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:438
    ret = 0;

done:
    return ret;
}
    1e91:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    1e95:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    1e9c:	00 00 
    1e9e:	8b 45 a0             	mov    -0x60(%rbp),%eax
    1ea1:	0f 85 b0 00 00 00    	jne    1f57 <write_ptr_blocks+0x1c7>
    1ea7:	48 83 c4 58          	add    $0x58,%rsp
    1eab:	5b                   	pop    %rbx
    1eac:	41 5c                	pop    %r12
    1eae:	41 5d                	pop    %r13
    1eb0:	41 5e                	pop    %r14
    1eb2:	41 5f                	pop    %r15
    1eb4:	5d                   	pop    %rbp
    1eb5:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:414
            ptr_blocks[i].next_ptr_block = AFS_INVALID_BLOCK;
    1eb6:	c7 83 ec 0f 00 00 ff 	movl   $0xffffffff,0xfec(%rbx)
    1ebd:	ff ff ff 
    1ec0:	e9 6a ff ff ff       	jmpq   1e2f <write_ptr_blocks+0x9f>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:423 (discriminator 1)
        afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, done, "no more free blocks");
    1ec5:	ba a7 01 00 00       	mov    $0x1a7,%edx
    1eca:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1ecd: R_X86_64_32S	.rodata+0xe0
    1ed1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1ed4: R_X86_64_32S	.rodata.str1.8+0xdf8
    1ed8:	31 c0                	xor    %eax,%eax
    1eda:	e8 00 00 00 00       	callq  1edf <write_ptr_blocks+0x14f>
			1edb: R_X86_64_PC32	printk-0x4
    1edf:	c7 45 a0 e4 ff ff ff 	movl   $0xffffffe4,-0x60(%rbp)
    1ee6:	eb a9                	jmp    1e91 <write_ptr_blocks+0x101>
    1ee8:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:425 (discriminator 1)
        afs_assert(!ret, done, "could not write ptr block [%d:%llu]", ret, i);
    1eeb:	89 c1                	mov    %eax,%ecx
    1eed:	4d 89 e0             	mov    %r12,%r8
    1ef0:	ba a9 01 00 00       	mov    $0x1a9,%edx
    1ef5:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1ef8: R_X86_64_32S	.rodata+0xe0
    1efc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1eff: R_X86_64_32S	.rodata.str1.8+0xf28
    1f03:	31 c0                	xor    %eax,%eax
    1f05:	e8 00 00 00 00       	callq  1f0a <write_ptr_blocks+0x17a>
			1f06: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:424 (discriminator 1)
        ret = write_page(ptr_blocks + i, context->bdev, block_num, data_sector_offset, false);
    1f0a:	44 89 6d a0          	mov    %r13d,-0x60(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:425 (discriminator 1)
        afs_assert(!ret, done, "could not write ptr block [%d:%llu]", ret, i);
    1f0e:	eb 81                	jmp    1e91 <write_ptr_blocks+0x101>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:433 (discriminator 1)
    afs_debug("pointer blocks written");
    1f10:	ba b1 01 00 00       	mov    $0x1b1,%edx
    1f15:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1f18: R_X86_64_32S	.rodata+0xe0
    1f1c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1f1f: R_X86_64_32S	.rodata.str1.8+0xf68
    1f23:	31 c0                	xor    %eax,%eax
    1f25:	e8 00 00 00 00       	callq  1f2a <write_ptr_blocks+0x19a>
			1f26: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:434 (discriminator 1)
    ret = 0;
    1f2a:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%rbp)
    1f31:	e9 5b ff ff ff       	jmpq   1e91 <write_ptr_blocks+0x101>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:400 (discriminator 1)
    afs_assert(!ret, done, "could not write Artifice map blocks [%d]", ret);
    1f36:	89 c1                	mov    %eax,%ecx
    1f38:	ba 90 01 00 00       	mov    $0x190,%edx
    1f3d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			1f40: R_X86_64_32S	.rodata+0xe0
    1f44:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			1f47: R_X86_64_32S	.rodata.str1.8+0xee0
    1f4b:	31 c0                	xor    %eax,%eax
    1f4d:	e8 00 00 00 00       	callq  1f52 <write_ptr_blocks+0x1c2>
			1f4e: R_X86_64_PC32	printk-0x4
    1f52:	e9 3a ff ff ff       	jmpq   1e91 <write_ptr_blocks+0x101>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:438
}
    1f57:	e8 00 00 00 00       	callq  1f5c <write_ptr_blocks+0x1cc>
			1f58: R_X86_64_PC32	__stack_chk_fail-0x4
    1f5c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000001f60 <chain_hash_superblock>:
chain_hash_superblock():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:440

int chain_hash_superblock(uint32_t *pass_hash[SHA1_SZ], uint32_t *sb_block, uint32_t block_device_size, struct afs_passive_fs *fs){
    1f60:	e8 00 00 00 00       	callq  1f65 <chain_hash_superblock+0x5>
			1f61: R_X86_64_PC32	__fentry__-0x4
    1f65:	55                   	push   %rbp
    1f66:	44 8b 49 08          	mov    0x8(%rcx),%r9d
    1f6a:	44 8b 06             	mov    (%rsi),%r8d
    1f6d:	48 8b 39             	mov    (%rcx),%rdi
    1f70:	48 89 e5             	mov    %rsp,%rbp
    1f73:	41 83 e9 01          	sub    $0x1,%r9d
    1f77:	45 89 ca             	mov    %r9d,%r10d
    1f7a:	41 c1 ea 1f          	shr    $0x1f,%r10d
    1f7e:	45 01 ca             	add    %r9d,%r10d
    1f81:	41 d1 fa             	sar    %r10d
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26 (discriminator 1)
    while (first <= last){
    1f84:	45 85 c9             	test   %r9d,%r9d
    1f87:	78 fb                	js     1f84 <chain_hash_superblock+0x24>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    1f89:	44 89 ce             	mov    %r9d,%esi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:24
    middle = (first + last) / 2;
    1f8c:	44 89 d0             	mov    %r10d,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:22
    first = 0;
    1f8f:	31 c9                	xor    %ecx,%ecx
    1f91:	eb 13                	jmp    1fa6 <chain_hash_superblock+0x46>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:28
            first = middle + 1;
    1f93:	8d 48 01             	lea    0x1(%rax),%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:35
        middle = (first + last)/2;
    1f96:	8d 14 31             	lea    (%rcx,%rsi,1),%edx
    1f99:	89 d0                	mov    %edx,%eax
    1f9b:	c1 e8 1f             	shr    $0x1f,%eax
    1f9e:	01 d0                	add    %edx,%eax
    1fa0:	d1 f8                	sar    %eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    1fa2:	39 f1                	cmp    %esi,%ecx
    1fa4:	7f de                	jg     1f84 <chain_hash_superblock+0x24>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:27
        if(array[middle] < value){
    1fa6:	48 63 d0             	movslq %eax,%rdx
    1fa9:	44 39 04 97          	cmp    %r8d,(%rdi,%rdx,4)
    1fad:	72 e4                	jb     1f93 <chain_hash_superblock+0x33>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:29
        } else if (array[middle] == value){
    1faf:	74 05                	je     1fb6 <chain_hash_superblock+0x56>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:33
            last = middle - 1;
    1fb1:	8d 70 ff             	lea    -0x1(%rax),%esi
    1fb4:	eb e0                	jmp    1f96 <chain_hash_superblock+0x36>
chain_hash_superblock():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:441
    while(binary_search(fs->block_list, *sb_block, fs->list_len) == -1){
    1fb6:	83 f8 ff             	cmp    $0xffffffff,%eax
    1fb9:	74 c9                	je     1f84 <chain_hash_superblock+0x24>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:445
        
    }
    return 0;
}
    1fbb:	31 c0                	xor    %eax,%eax
    1fbd:	5d                   	pop    %rbp
    1fbe:	c3                   	retq   
    1fbf:	90                   	nop

0000000000001fc0 <write_super_block>:
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:452
/**
 * Write the super block onto the disk.
 */
int
write_super_block(struct afs_super_block *sb, struct afs_passive_fs *fs, struct afs_private *context)
{
    1fc0:	e8 00 00 00 00       	callq  1fc5 <write_super_block+0x5>
			1fc1: R_X86_64_PC32	__fentry__-0x4
    1fc5:	55                   	push   %rbp
    1fc6:	48 89 e5             	mov    %rsp,%rbp
    1fc9:	41 57                	push   %r15
    1fcb:	41 56                	push   %r14
    1fcd:	41 55                	push   %r13
    1fcf:	41 54                	push   %r12
    1fd1:	49 89 f6             	mov    %rsi,%r14
    1fd4:	53                   	push   %rbx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:462
    int i = 0;
    uint8_t pass_hash[NUM_SUPERBLOCK_REPLICAS][SHA1_SZ];
    uint32_t block_device_size = config->bdev_size / AFS_SECTORS_PER_BLOCK;

    //hash passphrase and determine location of first superblock
    hash_sha1(context->args.passphrase, PASSPHRASE_SZ, pass_hash[0]);
    1fd5:	be 40 00 00 00       	mov    $0x40,%esi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:452
{
    1fda:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
    1fe1:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
    1fe8:	48 89 95 f0 fe ff ff 	mov    %rdx,-0x110(%rbp)
    1fef:	65 48 8b 1c 25 28 00 	mov    %gs:0x28,%rbx
    1ff6:	00 00 
    1ff8:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
    1ffc:	31 db                	xor    %ebx,%ebx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:459
    uint32_t block_device_size = config->bdev_size / AFS_SECTORS_PER_BLOCK;
    1ffe:	48 8b 5a 30          	mov    0x30(%rdx),%rbx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:462
    hash_sha1(context->args.passphrase, PASSPHRASE_SZ, pass_hash[0]);
    2002:	48 8d ba 20 20 00 00 	lea    0x2020(%rdx),%rdi
    2009:	48 8d 95 20 ff ff ff 	lea    -0xe0(%rbp),%rdx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:459
    uint32_t block_device_size = config->bdev_size / AFS_SECTORS_PER_BLOCK;
    2010:	48 89 9d e8 fe ff ff 	mov    %rbx,-0x118(%rbp)
    2017:	48 c1 eb 03          	shr    $0x3,%rbx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:469
    sb_block[0] = sb_block[0] % block_device_size;

    // Reserve space for the super block location.
    // if the hashed block is available, rehash and try again if it is not
    while(binary_search(fs->block_list, sb_block[0], fs->list_len) == -1){
        hash_sha1(pass_hash[0], SHA1_SZ, pass_hash[0]);
    201b:	e8 00 00 00 00       	callq  2020 <write_super_block+0x60>
			201c: R_X86_64_PC32	hash_sha1-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:471
        memcpy(&sb_block[0] , pass_hash[0], sizeof(uint32_t));
        sb_block[0] = sb_block[0] % block_device_size; 
    2020:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
    2026:	31 d2                	xor    %edx,%edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:468
    while(binary_search(fs->block_list, sb_block[0], fs->list_len) == -1){
    2028:	4d 8b 06             	mov    (%r14),%r8
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:471
        sb_block[0] = sb_block[0] % block_device_size; 
    202b:	f7 f3                	div    %ebx
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:23
    last = length - 1;
    202d:	41 8b 46 08          	mov    0x8(%r14),%eax
    2031:	8d 48 ff             	lea    -0x1(%rax),%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:24
    middle = (first + last) / 2;
    2034:	89 c8                	mov    %ecx,%eax
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:471
        sb_block[0] = sb_block[0] % block_device_size; 
    2036:	89 95 00 ff ff ff    	mov    %edx,-0x100(%rbp)
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:24
    middle = (first + last) / 2;
    203c:	c1 e8 1f             	shr    $0x1f,%eax
    203f:	01 c8                	add    %ecx,%eax
    2041:	d1 f8                	sar    %eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    2043:	85 c9                	test   %ecx,%ecx
    2045:	78 35                	js     207c <write_super_block+0xbc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:22
    first = 0;
    2047:	31 ff                	xor    %edi,%edi
    2049:	eb 13                	jmp    205e <write_super_block+0x9e>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:28
            first = middle + 1;
    204b:	8d 78 01             	lea    0x1(%rax),%edi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:35
        middle = (first + last)/2;
    204e:	8d 34 0f             	lea    (%rdi,%rcx,1),%esi
    2051:	89 f0                	mov    %esi,%eax
    2053:	c1 e8 1f             	shr    $0x1f,%eax
    2056:	01 f0                	add    %esi,%eax
    2058:	d1 f8                	sar    %eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    205a:	39 cf                	cmp    %ecx,%edi
    205c:	7f 1e                	jg     207c <write_super_block+0xbc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:27
        if(array[middle] < value){
    205e:	48 63 f0             	movslq %eax,%rsi
    2061:	41 3b 14 b0          	cmp    (%r8,%rsi,4),%edx
    2065:	77 e4                	ja     204b <write_super_block+0x8b>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:29
        } else if (array[middle] == value){
    2067:	74 24                	je     208d <write_super_block+0xcd>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:33
            last = middle - 1;
    2069:	8d 48 ff             	lea    -0x1(%rax),%ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:35
        middle = (first + last)/2;
    206c:	8d 34 0f             	lea    (%rdi,%rcx,1),%esi
    206f:	89 f0                	mov    %esi,%eax
    2071:	c1 e8 1f             	shr    $0x1f,%eax
    2074:	01 f0                	add    %esi,%eax
    2076:	d1 f8                	sar    %eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    2078:	39 cf                	cmp    %ecx,%edi
    207a:	7e e2                	jle    205e <write_super_block+0x9e>
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:469
        hash_sha1(pass_hash[0], SHA1_SZ, pass_hash[0]);
    207c:	48 8d 95 20 ff ff ff 	lea    -0xe0(%rbp),%rdx
    2083:	be 14 00 00 00       	mov    $0x14,%esi
    2088:	48 89 d7             	mov    %rdx,%rdi
    208b:	eb 8e                	jmp    201b <write_super_block+0x5b>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:468
    while(binary_search(fs->block_list, sb_block[0], fs->list_len) == -1){
    208d:	83 f8 ff             	cmp    $0xffffffff,%eax
    2090:	74 ea                	je     207c <write_super_block+0xbc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:473
    }
    allocation_set(&context->vector, sb_block[0]);
    2092:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
    2099:	4c 8d bd 20 ff ff ff 	lea    -0xe0(%rbp),%r15
    20a0:	89 d6                	mov    %edx,%esi
    20a2:	4c 8d ad 00 ff ff ff 	lea    -0x100(%rbp),%r13
    20a9:	48 05 08 21 00 00    	add    $0x2108,%rax
    20af:	48 89 c7             	mov    %rax,%rdi
    20b2:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
    20b9:	e8 00 00 00 00       	callq  20be <write_super_block+0xfe>
			20ba: R_X86_64_PC32	allocation_set-0x4
    20be:	49 8d 87 8c 00 00 00 	lea    0x8c(%r15),%rax
    20c5:	4c 89 ad d8 fe ff ff 	mov    %r13,-0x128(%rbp)
    20cc:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
    20d3:	4c 89 f0             	mov    %r14,%rax
    20d6:	4d 89 fe             	mov    %r15,%r14
    20d9:	49 89 c7             	mov    %rax,%r15
    20dc:	4d 8d 66 14          	lea    0x14(%r14),%r12
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:478

    //generate list of additional superblock locations
    //Iteratively hash like before
    for(i = 1; i < NUM_SUPERBLOCK_REPLICAS; i++){
        hash_sha1(pass_hash[i-1], SHA1_SZ, pass_hash[i]);
    20e0:	be 14 00 00 00       	mov    $0x14,%esi
    20e5:	4c 89 f7             	mov    %r14,%rdi
    20e8:	4c 89 e2             	mov    %r12,%rdx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:482
        memcpy(&sb_block[i], pass_hash[i], sizeof(uint32_t));
        sb_block[i] = sb_block[i] % block_device_size;
        while(binary_search(fs->block_list, sb_block[i], fs->list_len) == -1){
            hash_sha1(pass_hash[i], SHA1_SZ, pass_hash[i]);   
    20eb:	e8 00 00 00 00       	callq  20f0 <write_super_block+0x130>
			20ec: R_X86_64_PC32	hash_sha1-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:484
            memcpy(&sb_block[i] , pass_hash[i], sizeof(uint32_t));
            sb_block[i] = sb_block[i] % block_device_size;
    20f0:	41 8b 46 14          	mov    0x14(%r14),%eax
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:23
    last = length - 1;
    20f4:	41 8b 7f 08          	mov    0x8(%r15),%edi
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:484
            sb_block[i] = sb_block[i] % block_device_size;
    20f8:	31 d2                	xor    %edx,%edx
    20fa:	f7 f3                	div    %ebx
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:23
    last = length - 1;
    20fc:	83 ef 01             	sub    $0x1,%edi
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:481
        while(binary_search(fs->block_list, sb_block[i], fs->list_len) == -1){
    20ff:	49 8b 07             	mov    (%r15),%rax
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:24
    middle = (first + last) / 2;
    2102:	89 f9                	mov    %edi,%ecx
    2104:	c1 e9 1f             	shr    $0x1f,%ecx
    2107:	01 f9                	add    %edi,%ecx
    2109:	d1 f9                	sar    %ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    210b:	85 ff                	test   %edi,%edi
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:484
            sb_block[i] = sb_block[i] % block_device_size;
    210d:	41 89 55 04          	mov    %edx,0x4(%r13)
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    2111:	78 2f                	js     2142 <write_super_block+0x182>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:22
    first = 0;
    2113:	45 31 c0             	xor    %r8d,%r8d
    2116:	eb 16                	jmp    212e <write_super_block+0x16e>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:28
            first = middle + 1;
    2118:	44 8d 41 01          	lea    0x1(%rcx),%r8d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:35
        middle = (first + last)/2;
    211c:	41 8d 34 38          	lea    (%r8,%rdi,1),%esi
    2120:	89 f1                	mov    %esi,%ecx
    2122:	c1 e9 1f             	shr    $0x1f,%ecx
    2125:	01 f1                	add    %esi,%ecx
    2127:	d1 f9                	sar    %ecx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    2129:	41 39 f8             	cmp    %edi,%r8d
    212c:	7f 14                	jg     2142 <write_super_block+0x182>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:27
        if(array[middle] < value){
    212e:	48 63 f1             	movslq %ecx,%rsi
    2131:	39 14 b0             	cmp    %edx,(%rax,%rsi,4)
    2134:	72 e2                	jb     2118 <write_super_block+0x158>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:29
        } else if (array[middle] == value){
    2136:	74 05                	je     213d <write_super_block+0x17d>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:33
            last = middle - 1;
    2138:	8d 79 ff             	lea    -0x1(%rcx),%edi
    213b:	eb df                	jmp    211c <write_super_block+0x15c>
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:481
        while(binary_search(fs->block_list, sb_block[i], fs->list_len) == -1){
    213d:	83 f9 ff             	cmp    $0xffffffff,%ecx
    2140:	75 0d                	jne    214f <write_super_block+0x18f>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:482
            hash_sha1(pass_hash[i], SHA1_SZ, pass_hash[i]);   
    2142:	4c 89 e2             	mov    %r12,%rdx
    2145:	be 14 00 00 00       	mov    $0x14,%esi
    214a:	4c 89 e7             	mov    %r12,%rdi
    214d:	eb 9c                	jmp    20eb <write_super_block+0x12b>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:486 (discriminator 2)
        }
        allocation_set(&context->vector, sb_block[i]);
    214f:	48 8b bd e8 fe ff ff 	mov    -0x118(%rbp),%rdi
    2156:	89 d6                	mov    %edx,%esi
    2158:	49 83 c5 04          	add    $0x4,%r13
    215c:	4d 89 e6             	mov    %r12,%r14
    215f:	e8 00 00 00 00       	callq  2164 <write_super_block+0x1a4>
			2160: R_X86_64_PC32	allocation_set-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:477 (discriminator 2)
    for(i = 1; i < NUM_SUPERBLOCK_REPLICAS; i++){
    2164:	4c 39 a5 e0 fe ff ff 	cmp    %r12,-0x120(%rbp)
    216b:	0f 85 6b ff ff ff    	jne    20dc <write_super_block+0x11c>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:490
    }

    // Build the Artifice Map.
    ret = afs_create_map(context);
    2171:	48 8b bd f0 fe ff ff 	mov    -0x110(%rbp),%rdi
    2178:	4d 89 fe             	mov    %r15,%r14
    217b:	e8 00 00 00 00       	callq  2180 <write_super_block+0x1c0>
			217c: R_X86_64_PC32	afs_create_map-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:491
    afs_assert(!ret, map_err, "could not create Artifice map [%d]", ret);
    2180:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:490
    ret = afs_create_map(context);
    2182:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:491
    afs_assert(!ret, map_err, "could not create Artifice map [%d]", ret);
    2185:	0f 85 5f 01 00 00    	jne    22ea <write_super_block+0x32a>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:494

    // Build the Artifice Map Blocks.
    ret = afs_create_map_blocks(context);
    218b:	48 8b bd f0 fe ff ff 	mov    -0x110(%rbp),%rdi
    2192:	e8 00 00 00 00       	callq  2197 <write_super_block+0x1d7>
			2193: R_X86_64_PC32	afs_create_map_blocks-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:495
    afs_assert(!ret, map_block_err, "could not create Artifice map blocks [%d]", ret);
    2197:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:494
    ret = afs_create_map_blocks(context);
    2199:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:495
    afs_assert(!ret, map_block_err, "could not create Artifice map blocks [%d]", ret);
    219c:	0f 85 66 01 00 00    	jne    2308 <write_super_block+0x348>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:498

    // Allocate the Artifice Pointer Blocks.
    ptr_blocks = kmalloc(config->num_ptr_blocks * sizeof(*ptr_blocks), GFP_KERNEL);
    21a2:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    21a9:	be c0 00 40 01       	mov    $0x14000c0,%esi
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:498
    21ae:	8b 78 20             	mov    0x20(%rax),%edi
    21b1:	48 c1 e7 0c          	shl    $0xc,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    21b5:	e8 00 00 00 00       	callq  21ba <write_super_block+0x1fa>
			21b6: R_X86_64_PC32	__kmalloc-0x4
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:499
    afs_action(ptr_blocks, ret = -ENOMEM, ptr_block_err, "could not allocate ptr_blocks [%d]", ret);
    21ba:	48 85 c0             	test   %rax,%rax
    21bd:	0f 84 76 01 00 00    	je     2339 <write_super_block+0x379>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:500
    memset(ptr_blocks, 0, config->num_ptr_blocks * sizeof(*ptr_blocks));
    21c3:	48 8b 9d f0 fe ff ff 	mov    -0x110(%rbp),%rbx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    21ca:	31 f6                	xor    %esi,%esi
    21cc:	48 89 c7             	mov    %rax,%rdi
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:500
    21cf:	8b 53 20             	mov    0x20(%rbx),%edx
    21d2:	48 c1 e2 0c          	shl    $0xc,%rdx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    21d6:	e8 00 00 00 00       	callq  21db <write_super_block+0x21b>
			21d7: R_X86_64_PC32	memset-0x4
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:501
    context->afs_ptr_blocks = ptr_blocks;
    21db:	48 89 83 60 b0 03 00 	mov    %rax,0x3b060(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:504

    // Build the Artifice Pointer Blocks.
    sb->first_ptr_block = AFS_INVALID_BLOCK;
    21e2:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:505
    ret = write_ptr_blocks(sb, fs, context);
    21e9:	48 89 da             	mov    %rbx,%rdx
    21ec:	4c 89 fe             	mov    %r15,%rsi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:504
    sb->first_ptr_block = AFS_INVALID_BLOCK;
    21ef:	c7 80 fc 0f 00 00 ff 	movl   $0xffffffff,0xffc(%rax)
    21f6:	ff ff ff 
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:505
    ret = write_ptr_blocks(sb, fs, context);
    21f9:	48 89 c7             	mov    %rax,%rdi
    21fc:	e8 00 00 00 00       	callq  2201 <write_super_block+0x241>
			21fd: R_X86_64_PC32	write_ptr_blocks-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:506
    afs_assert(!ret, ptr_block_err, "could not write pointer blocks [%d]", ret);
    2201:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:505
    ret = write_ptr_blocks(sb, fs, context);
    2203:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:506
    afs_assert(!ret, ptr_block_err, "could not write pointer blocks [%d]", ret);
    2206:	0f 85 67 01 00 00    	jne    2373 <write_super_block+0x3b3>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:512

    // 1. Take note of the instance size.
    // 2. Take note of the entropy directory for the instance.
    // 3. Hash the super block.
    // 4. Write each block to disk.
    sb->instance_size = config->instance_size;
    220c:	4c 8b ad f0 fe ff ff 	mov    -0x110(%rbp),%r13
    2213:	48 8b 9d f8 fe ff ff 	mov    -0x108(%rbp),%rbx
strncpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:245
    221a:	ba 40 00 00 00       	mov    $0x40,%edx
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:518
    strncpy(sb->entropy_dir, context->args.entropy_dir, ENTROPY_DIR_SZ);
    hash_sha256((uint8_t *)sb + SHA256_SZ, sizeof(*sb) - SHA256_SZ, sb->sb_hash);
    for(i = 0; i < NUM_SUPERBLOCK_REPLICAS; i++){
        ret = write_page(sb, context->bdev, fs->block_list[sb_block[i]], context->passive_fs.data_start_off, false);
        afs_assert(!ret, sb_err, "could not write super block [%d]", ret);
        afs_debug("super blocks written to disk [block: %u]", sb_block[i]);
    221f:	49 c7 c7 00 00 00 00 	mov    $0x0,%r15
			2222: R_X86_64_32S	.rodata+0xc0
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:512
    sb->instance_size = config->instance_size;
    2226:	49 8b 45 28          	mov    0x28(%r13),%rax
strncpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:245
    222a:	48 8d 7b 40          	lea    0x40(%rbx),%rdi
    222e:	49 8d b5 c0 20 00 00 	lea    0x20c0(%r13),%rsi
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:512
    2235:	48 89 43 34          	mov    %rax,0x34(%rbx)
strncpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:245
    2239:	e8 00 00 00 00       	callq  223e <write_super_block+0x27e>
			223a: R_X86_64_PC32	strncpy-0x4
write_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:514
    hash_sha256((uint8_t *)sb + SHA256_SZ, sizeof(*sb) - SHA256_SZ, sb->sb_hash);
    223e:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
    2242:	48 89 da             	mov    %rbx,%rdx
    2245:	be e0 0f 00 00       	mov    $0xfe0,%esi
    224a:	e8 00 00 00 00       	callq  224f <write_super_block+0x28f>
			224b: R_X86_64_PC32	hash_sha256-0x4
    224f:	48 8b 9d d8 fe ff ff 	mov    -0x128(%rbp),%rbx
    2256:	4c 8d 63 20          	lea    0x20(%rbx),%r12
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:518
        afs_debug("super blocks written to disk [block: %u]", sb_block[i]);
    225a:	4c 89 a5 e8 fe ff ff 	mov    %r12,-0x118(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:516
        ret = write_page(sb, context->bdev, fs->block_list[sb_block[i]], context->passive_fs.data_start_off, false);
    2261:	8b 13                	mov    (%rbx),%edx
    2263:	49 8b 06             	mov    (%r14),%rax
    2266:	45 31 c0             	xor    %r8d,%r8d
    2269:	41 8b 8d 14 20 00 00 	mov    0x2014(%r13),%ecx
    2270:	49 8b 75 08          	mov    0x8(%r13),%rsi
    2274:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
    227b:	49 89 d4             	mov    %rdx,%r12
    227e:	8b 14 90             	mov    (%rax,%rdx,4),%edx
    2281:	e8 00 00 00 00       	callq  2286 <write_super_block+0x2c6>
			2282: R_X86_64_PC32	write_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:517
        afs_assert(!ret, sb_err, "could not write super block [%d]", ret);
    2286:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:516
        ret = write_page(sb, context->bdev, fs->block_list[sb_block[i]], context->passive_fs.data_start_off, false);
    2288:	41 89 c0             	mov    %eax,%r8d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:517
        afs_assert(!ret, sb_err, "could not write super block [%d]", ret);
    228b:	0f 85 00 01 00 00    	jne    2391 <write_super_block+0x3d1>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:518
        afs_debug("super blocks written to disk [block: %u]", sb_block[i]);
    2291:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 2297 <write_super_block+0x2d7>
			2293: R_X86_64_PC32	afs_debug_mode-0x4
    2297:	85 c0                	test   %eax,%eax
    2299:	0f 85 27 01 00 00    	jne    23c6 <write_super_block+0x406>
    229f:	48 83 c3 04          	add    $0x4,%rbx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:515 (discriminator 2)
    for(i = 0; i < NUM_SUPERBLOCK_REPLICAS; i++){
    22a3:	48 39 9d e8 fe ff ff 	cmp    %rbx,-0x118(%rbp)
    22aa:	75 b5                	jne    2261 <write_super_block+0x2a1>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:522
    }

    // We don't need the map blocks anymore.
    vfree(context->afs_map_blocks);
    22ac:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
    22b3:	45 89 c5             	mov    %r8d,%r13d
    22b6:	48 8b b8 58 b0 03 00 	mov    0x3b058(%rax),%rdi
    22bd:	e8 00 00 00 00       	callq  22c2 <write_super_block+0x302>
			22be: R_X86_64_PC32	vfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:536
map_block_err:
    vfree(context->afs_map);

map_err:
    return ret;
}
    22c2:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
    22c6:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    22cd:	00 00 
    22cf:	44 89 e8             	mov    %r13d,%eax
    22d2:	0f 85 1a 01 00 00    	jne    23f2 <write_super_block+0x432>
    22d8:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
    22df:	5b                   	pop    %rbx
    22e0:	41 5c                	pop    %r12
    22e2:	41 5d                	pop    %r13
    22e4:	41 5e                	pop    %r14
    22e6:	41 5f                	pop    %r15
    22e8:	5d                   	pop    %rbp
    22e9:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:491 (discriminator 1)
    afs_assert(!ret, map_err, "could not create Artifice map [%d]", ret);
    22ea:	89 c1                	mov    %eax,%ecx
    22ec:	ba eb 01 00 00       	mov    $0x1eb,%edx
    22f1:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			22f4: R_X86_64_32S	.rodata+0xc0
    22f8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			22fb: R_X86_64_32S	.rodata.str1.8+0xf98
    22ff:	31 c0                	xor    %eax,%eax
    2301:	e8 00 00 00 00       	callq  2306 <write_super_block+0x346>
			2302: R_X86_64_PC32	printk-0x4
    2306:	eb ba                	jmp    22c2 <write_super_block+0x302>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:495 (discriminator 1)
    afs_assert(!ret, map_block_err, "could not create Artifice map blocks [%d]", ret);
    2308:	89 c1                	mov    %eax,%ecx
    230a:	ba ef 01 00 00       	mov    $0x1ef,%edx
    230f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2312: R_X86_64_32S	.rodata+0xc0
    2316:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2319: R_X86_64_32S	.rodata.str1.8+0xfd8
    231d:	31 c0                	xor    %eax,%eax
    231f:	e8 00 00 00 00       	callq  2324 <write_super_block+0x364>
			2320: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:532
    vfree(context->afs_map);
    2324:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
    232b:	48 8b b8 50 b0 03 00 	mov    0x3b050(%rax),%rdi
    2332:	e8 00 00 00 00       	callq  2337 <write_super_block+0x377>
			2333: R_X86_64_PC32	vfree-0x4
    2337:	eb 89                	jmp    22c2 <write_super_block+0x302>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:499 (discriminator 1)
    afs_action(ptr_blocks, ret = -ENOMEM, ptr_block_err, "could not allocate ptr_blocks [%d]", ret);
    2339:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    233e:	ba f3 01 00 00       	mov    $0x1f3,%edx
    2343:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2346: R_X86_64_32S	.rodata+0xc0
    234a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			234d: R_X86_64_32S	.rodata.str1.8+0x1020
    2351:	31 c0                	xor    %eax,%eax
    2353:	41 bd f4 ff ff ff    	mov    $0xfffffff4,%r13d
    2359:	e8 00 00 00 00       	callq  235e <write_super_block+0x39e>
			235a: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:529
    vfree(context->afs_map_blocks);
    235e:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
    2365:	48 8b b8 58 b0 03 00 	mov    0x3b058(%rax),%rdi
    236c:	e8 00 00 00 00       	callq  2371 <write_super_block+0x3b1>
			236d: R_X86_64_PC32	vfree-0x4
    2371:	eb b1                	jmp    2324 <write_super_block+0x364>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:506 (discriminator 1)
    afs_assert(!ret, ptr_block_err, "could not write pointer blocks [%d]", ret);
    2373:	89 c1                	mov    %eax,%ecx
    2375:	ba fa 01 00 00       	mov    $0x1fa,%edx
    237a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			237d: R_X86_64_32S	.rodata+0xc0
    2381:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2384: R_X86_64_32S	.rodata.str1.8+0x1060
    2388:	31 c0                	xor    %eax,%eax
    238a:	e8 00 00 00 00       	callq  238f <write_super_block+0x3cf>
			238b: R_X86_64_PC32	printk-0x4
    238f:	eb cd                	jmp    235e <write_super_block+0x39e>
    2391:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:517 (discriminator 1)
        afs_assert(!ret, sb_err, "could not write super block [%d]", ret);
    2394:	44 89 c1             	mov    %r8d,%ecx
    2397:	ba 05 02 00 00       	mov    $0x205,%edx
    239c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			239f: R_X86_64_32S	.rodata+0xc0
    23a3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			23a6: R_X86_64_32S	.rodata.str1.8+0x10a0
    23aa:	31 c0                	xor    %eax,%eax
    23ac:	e8 00 00 00 00       	callq  23b1 <write_super_block+0x3f1>
			23ad: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:526 (discriminator 1)
    kfree(context->afs_ptr_blocks);
    23b1:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
    23b8:	48 8b b8 60 b0 03 00 	mov    0x3b060(%rax),%rdi
    23bf:	e8 00 00 00 00       	callq  23c4 <write_super_block+0x404>
			23c0: R_X86_64_PC32	kfree-0x4
    23c4:	eb 98                	jmp    235e <write_super_block+0x39e>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:518 (discriminator 1)
        afs_debug("super blocks written to disk [block: %u]", sb_block[i]);
    23c6:	44 89 e1             	mov    %r12d,%ecx
    23c9:	ba 06 02 00 00       	mov    $0x206,%edx
    23ce:	4c 89 fe             	mov    %r15,%rsi
    23d1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			23d4: R_X86_64_32S	.rodata.str1.8+0x10e0
    23d8:	31 c0                	xor    %eax,%eax
    23da:	44 89 85 e0 fe ff ff 	mov    %r8d,-0x120(%rbp)
    23e1:	e8 00 00 00 00       	callq  23e6 <write_super_block+0x426>
			23e2: R_X86_64_PC32	printk-0x4
    23e6:	44 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%r8d
    23ed:	e9 ad fe ff ff       	jmpq   229f <write_super_block+0x2df>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:536
}
    23f2:	e8 00 00 00 00       	callq  23f7 <write_super_block+0x437>
			23f3: R_X86_64_PC32	__stack_chk_fail-0x4
    23f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    23fe:	00 00 

0000000000002400 <find_super_block>:
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:602
 * Find the super block on the disk.
 *
 */
int
find_super_block(struct afs_super_block *sb, struct afs_private *context)
{
    2400:	e8 00 00 00 00       	callq  2405 <find_super_block+0x5>
			2401: R_X86_64_PC32	__fentry__-0x4
    2405:	55                   	push   %rbp
    2406:	48 89 e5             	mov    %rsp,%rbp
    2409:	41 57                	push   %r15
    240b:	41 56                	push   %r14
    240d:	41 55                	push   %r13
    240f:	41 54                	push   %r12
    2411:	49 89 fd             	mov    %rdi,%r13
    2414:	53                   	push   %rbx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:612
    int ret = 0;
    uint32_t sb_tries = 0;
    uint8_t pass_hash[NUM_SUPERBLOCK_REPLICAS][SHA1_SZ];
    uint32_t block_device_size = config->bdev_size / AFS_SECTORS_PER_BLOCK;

    hash_sha1(context->args.passphrase, PASSPHRASE_SZ, pass_hash[0]);
    2415:	48 8d be 20 20 00 00 	lea    0x2020(%rsi),%rdi
    241c:	48 8d 95 00 ff ff ff 	lea    -0x100(%rbp),%rdx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:602
{
    2423:	49 89 f6             	mov    %rsi,%r14
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:608
    uint32_t sb_tries = 0;
    2426:	31 db                	xor    %ebx,%ebx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:602
{
    2428:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:610
    uint32_t block_device_size = config->bdev_size / AFS_SECTORS_PER_BLOCK;
    242f:	4c 8b 66 30          	mov    0x30(%rsi),%r12
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:612
    hash_sha1(context->args.passphrase, PASSPHRASE_SZ, pass_hash[0]);
    2433:	be 40 00 00 00       	mov    $0x40,%esi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:602
{
    2438:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    243f:	00 00 
    2441:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    2445:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:612
    hash_sha1(context->args.passphrase, PASSPHRASE_SZ, pass_hash[0]);
    2447:	e8 00 00 00 00       	callq  244c <find_super_block+0x4c>
			2448: R_X86_64_PC32	hash_sha1-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:614
    memcpy(&sb_block[0], pass_hash[0], sizeof(uint32_t));
    sb_block[0] = sb_block[0] % block_device_size;
    244c:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:610
    uint32_t block_device_size = config->bdev_size / AFS_SECTORS_PER_BLOCK;
    2452:	49 c1 ec 03          	shr    $0x3,%r12
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:614
    sb_block[0] = sb_block[0] % block_device_size;
    2456:	31 d2                	xor    %edx,%edx
    2458:	41 f7 f4             	div    %r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:630
        //attempt to read superblock
        ret = read_page(sb, context->bdev, context->passive_fs.block_list[sb_block[0]], context->passive_fs.data_start_off, false);
        afs_assert(!ret, err, "could not read super block page [%d]", ret);

        // Check for corruption.
        hash_sha256((uint8_t *)sb + SHA256_SZ, sizeof(*sb) - SHA256_SZ, sb_digest);
    245b:	49 8d 45 20          	lea    0x20(%r13),%rax
    245f:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:614
    sb_block[0] = sb_block[0] % block_device_size;
    2466:	41 89 d7             	mov    %edx,%r15d
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:23
    last = length - 1;
    2469:	41 8b 86 08 20 00 00 	mov    0x2008(%r14),%eax
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:619
        while(binary_search(context->passive_fs.block_list, sb_block[0], context->passive_fs.list_len) == -1){
    2470:	49 8b b6 00 20 00 00 	mov    0x2000(%r14),%rsi
binary_search():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:23
    last = length - 1;
    2477:	83 e8 01             	sub    $0x1,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:24
    middle = (first + last) / 2;
    247a:	89 c2                	mov    %eax,%edx
    247c:	c1 ea 1f             	shr    $0x1f,%edx
    247f:	01 c2                	add    %eax,%edx
    2481:	d1 fa                	sar    %edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    2483:	85 c0                	test   %eax,%eax
    2485:	78 35                	js     24bc <find_super_block+0xbc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:22
    first = 0;
    2487:	31 ff                	xor    %edi,%edi
    2489:	eb 13                	jmp    249e <find_super_block+0x9e>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:28
            first = middle + 1;
    248b:	8d 7a 01             	lea    0x1(%rdx),%edi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:35
        middle = (first + last)/2;
    248e:	8d 0c 07             	lea    (%rdi,%rax,1),%ecx
    2491:	89 ca                	mov    %ecx,%edx
    2493:	c1 ea 1f             	shr    $0x1f,%edx
    2496:	01 ca                	add    %ecx,%edx
    2498:	d1 fa                	sar    %edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    249a:	39 c7                	cmp    %eax,%edi
    249c:	7f 1e                	jg     24bc <find_super_block+0xbc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:27
        if(array[middle] < value){
    249e:	48 63 ca             	movslq %edx,%rcx
    24a1:	44 39 3c 8e          	cmp    %r15d,(%rsi,%rcx,4)
    24a5:	72 e4                	jb     248b <find_super_block+0x8b>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:29
        } else if (array[middle] == value){
    24a7:	74 3a                	je     24e3 <find_super_block+0xe3>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:33
            last = middle - 1;
    24a9:	8d 42 ff             	lea    -0x1(%rdx),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:35
        middle = (first + last)/2;
    24ac:	8d 0c 07             	lea    (%rdi,%rax,1),%ecx
    24af:	89 ca                	mov    %ecx,%edx
    24b1:	c1 ea 1f             	shr    $0x1f,%edx
    24b4:	01 ca                	add    %ecx,%edx
    24b6:	d1 fa                	sar    %edx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:26
    while (first <= last){
    24b8:	39 c7                	cmp    %eax,%edi
    24ba:	7e e2                	jle    249e <find_super_block+0x9e>
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:620
            hash_sha1(pass_hash[0], SHA1_SZ, pass_hash[0]);
    24bc:	48 8d 95 00 ff ff ff 	lea    -0x100(%rbp),%rdx
    24c3:	be 14 00 00 00       	mov    $0x14,%esi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:623
            sb_tries++;
    24c8:	83 c3 01             	add    $0x1,%ebx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:620
            hash_sha1(pass_hash[0], SHA1_SZ, pass_hash[0]);
    24cb:	48 89 d7             	mov    %rdx,%rdi
    24ce:	e8 00 00 00 00       	callq  24d3 <find_super_block+0xd3>
			24cf: R_X86_64_PC32	hash_sha1-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:622
            sb_block[0] = sb_block[0] % block_device_size;
    24d3:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
    24d9:	31 d2                	xor    %edx,%edx
    24db:	41 f7 f4             	div    %r12d
    24de:	41 89 d7             	mov    %edx,%r15d
    24e1:	eb 86                	jmp    2469 <find_super_block+0x69>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:619
        while(binary_search(context->passive_fs.block_list, sb_block[0], context->passive_fs.list_len) == -1){
    24e3:	83 fa ff             	cmp    $0xffffffff,%edx
    24e6:	74 d4                	je     24bc <find_super_block+0xbc>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:626
        ret = read_page(sb, context->bdev, context->passive_fs.block_list[sb_block[0]], context->passive_fs.data_start_off, false);
    24e8:	44 89 f8             	mov    %r15d,%eax
    24eb:	41 8b 8e 14 20 00 00 	mov    0x2014(%r14),%ecx
    24f2:	45 31 c0             	xor    %r8d,%r8d
    24f5:	8b 14 86             	mov    (%rsi,%rax,4),%edx
    24f8:	49 8b 76 08          	mov    0x8(%r14),%rsi
    24fc:	4c 89 ef             	mov    %r13,%rdi
    24ff:	e8 00 00 00 00       	callq  2504 <find_super_block+0x104>
			2500: R_X86_64_PC32	read_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:627
        afs_assert(!ret, err, "could not read super block page [%d]", ret);
    2504:	85 c0                	test   %eax,%eax
    2506:	0f 85 54 03 00 00    	jne    2860 <find_super_block+0x460>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:630
        hash_sha256((uint8_t *)sb + SHA256_SZ, sizeof(*sb) - SHA256_SZ, sb_digest);
    250c:	48 8b bd f8 fe ff ff 	mov    -0x108(%rbp),%rdi
    2513:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
    2517:	be e0 0f 00 00       	mov    $0xfe0,%esi
    251c:	e8 00 00 00 00       	callq  2521 <find_super_block+0x121>
			251d: R_X86_64_PC32	hash_sha256-0x4
memcmp():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:385
    2521:	49 8b 45 00          	mov    0x0(%r13),%rax
    2525:	49 8b 55 08          	mov    0x8(%r13),%rdx
    2529:	48 33 45 a0          	xor    -0x60(%rbp),%rax
    252d:	48 33 55 a8          	xor    -0x58(%rbp),%rdx
    2531:	48 09 c2             	or     %rax,%rdx
    2534:	0f 85 e7 01 00 00    	jne    2721 <find_super_block+0x321>
    253a:	49 8b 45 10          	mov    0x10(%r13),%rax
    253e:	49 8b 55 18          	mov    0x18(%r13),%rdx
    2542:	48 33 45 b0          	xor    -0x50(%rbp),%rax
    2546:	48 33 55 b8          	xor    -0x48(%rbp),%rdx
    254a:	48 09 c2             	or     %rax,%rdx
    254d:	0f 85 ce 01 00 00    	jne    2721 <find_super_block+0x321>
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:639
            sb_tries++;
        }else{
            break; 
        }
    }
    allocation_set(&context->vector, sb_block[0]);
    2553:	49 8d 9e 08 21 00 00 	lea    0x2108(%r14),%rbx
    255a:	44 89 fe             	mov    %r15d,%esi
    255d:	48 89 df             	mov    %rbx,%rdi
    2560:	e8 00 00 00 00       	callq  2565 <find_super_block+0x165>
			2561: R_X86_64_PC32	allocation_set-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:644

    afs_action(!ret, ret = -ENOENT, err, "super block corrupted");

    // Confirm size is same.
    afs_action(config->instance_size == sb->instance_size, ret = -EINVAL, err,
    2565:	49 8b 4e 28          	mov    0x28(%r14),%rcx
    2569:	4d 8b 45 34          	mov    0x34(%r13),%r8
    256d:	4c 39 c1             	cmp    %r8,%rcx
    2570:	0f 85 18 03 00 00    	jne    288e <find_super_block+0x48e>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:648
        "incorrect size provided [%llu:%llu]", config->instance_size, sb->instance_size);

    // TODO: Acquire from RS params in SB.
    build_configuration(context, 4, 1);
    2576:	ba 01 00 00 00       	mov    $0x1,%edx
    257b:	be 04 00 00 00       	mov    $0x4,%esi
    2580:	4c 89 f7             	mov    %r14,%rdi
    2583:	e8 00 00 00 00       	callq  2588 <find_super_block+0x188>
			2584: R_X86_64_PC32	build_configuration-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:650

    ret = afs_create_map(context);
    2588:	4c 89 f7             	mov    %r14,%rdi
    258b:	e8 00 00 00 00       	callq  2590 <find_super_block+0x190>
			258c: R_X86_64_PC32	afs_create_map-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:651
    afs_assert(!ret, err, "could not create artifice map [%d]", ret);
    2590:	85 c0                	test   %eax,%eax
    2592:	0f 85 1b 03 00 00    	jne    28b3 <find_super_block+0x4b3>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:653

    ret = afs_fill_map(sb, context);
    2598:	4c 89 f6             	mov    %r14,%rsi
    259b:	4c 89 ef             	mov    %r13,%rdi
    259e:	e8 00 00 00 00       	callq  25a3 <find_super_block+0x1a3>
			259f: R_X86_64_PC32	afs_fill_map-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:654
    afs_assert(!ret, map_fill_err, "could not fill artifice map [%d]", ret);
    25a3:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:653
    ret = afs_fill_map(sb, context);
    25a5:	41 89 c4             	mov    %eax,%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:654
    afs_assert(!ret, map_fill_err, "could not fill artifice map [%d]", ret);
    25a8:	0f 85 33 03 00 00    	jne    28e1 <find_super_block+0x4e1>
rebuild_allocation_vector():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:553
    afs_map = context->afs_map;
    25ae:	49 8b 86 50 b0 03 00 	mov    0x3b050(%r14),%rax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:555
    num_carrier_blocks = config->num_carrier_blocks;
    25b5:	45 0f b6 7e 10       	movzbl 0x10(%r14),%r15d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:553
    afs_map = context->afs_map;
    25ba:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:554
    num_entries = config->num_blocks;
    25c1:	41 8b 46 18          	mov    0x18(%r14),%eax
    25c5:	89 c6                	mov    %eax,%esi
    25c7:	89 85 ec fe ff ff    	mov    %eax,-0x114(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:556
    map_entry_sz = config->map_entry_sz;
    25cd:	41 0f b6 46 12       	movzbl 0x12(%r14),%eax
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:558
    for (i = 0; i < num_entries; i++) {
    25d2:	85 f6                	test   %esi,%esi
    25d4:	0f 84 84 00 00 00    	je     265e <find_super_block+0x25e>
    25da:	41 0f b6 f7          	movzbl %r15b,%esi
    25de:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%rbp)
    25e4:	45 31 ff             	xor    %r15d,%r15d
    25e7:	8d 46 ff             	lea    -0x1(%rsi),%eax
    25ea:	89 b5 e4 fe ff ff    	mov    %esi,-0x11c(%rbp)
    25f0:	c7 85 f8 fe ff ff 00 	movl   $0x0,-0x108(%rbp)
    25f7:	00 00 00 
    25fa:	48 8d 44 80 05       	lea    0x5(%rax,%rax,4),%rax
    25ff:	48 01 c0             	add    %rax,%rax
    2602:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:559
        map_tuple = (struct afs_map_tuple *)(afs_map + (i * map_entry_sz));
    2609:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
    2610:	44 89 fa             	mov    %r15d,%edx
    2613:	4c 8d 2c 10          	lea    (%rax,%rdx,1),%r13
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:560
        for (j = 0; j < num_carrier_blocks; j++) {
    2617:	8b 95 e4 fe ff ff    	mov    -0x11c(%rbp),%edx
    261d:	85 d2                	test   %edx,%edx
    261f:	74 21                	je     2642 <find_super_block+0x242>
    2621:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
    2628:	4d 8d 64 05 00       	lea    0x0(%r13,%rax,1),%r12
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:561
            allocation_set(&context->vector, map_tuple->carrier_block_ptr);
    262d:	41 8b 75 00          	mov    0x0(%r13),%esi
    2631:	48 89 df             	mov    %rbx,%rdi
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:562
            map_tuple += 1;
    2634:	49 83 c5 0a          	add    $0xa,%r13
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:561
            allocation_set(&context->vector, map_tuple->carrier_block_ptr);
    2638:	e8 00 00 00 00       	callq  263d <find_super_block+0x23d>
			2639: R_X86_64_PC32	allocation_set-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:560
        for (j = 0; j < num_carrier_blocks; j++) {
    263d:	4d 39 ec             	cmp    %r13,%r12
    2640:	75 eb                	jne    262d <find_super_block+0x22d>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:558
    for (i = 0; i < num_entries; i++) {
    2642:	83 85 f8 fe ff ff 01 	addl   $0x1,-0x108(%rbp)
    2649:	44 03 bd e8 fe ff ff 	add    -0x118(%rbp),%r15d
    2650:	8b 85 f8 fe ff ff    	mov    -0x108(%rbp),%eax
    2656:	39 85 ec fe ff ff    	cmp    %eax,-0x114(%rbp)
    265c:	75 ab                	jne    2609 <find_super_block+0x209>
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:656
    rebuild_allocation_vector(context);
    afs_debug("Artifice map rebuilt");
    265e:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 2664 <find_super_block+0x264>
			2660: R_X86_64_PC32	afs_debug_mode-0x4
    2664:	85 c0                	test   %eax,%eax
    2666:	0f 85 99 02 00 00    	jne    2905 <find_super_block+0x505>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:660

    // Create the Artifice Pointer Blocks. These are required for when
    // we need to re-write the map blocks.
    ptr_blocks = kmalloc(config->num_ptr_blocks * sizeof(*ptr_blocks), GFP_KERNEL);
    266c:	41 8b 7e 20          	mov    0x20(%r14),%edi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    2670:	be c0 00 40 01       	mov    $0x14000c0,%esi
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:660
    2675:	48 c1 e7 0c          	shl    $0xc,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    2679:	e8 00 00 00 00       	callq  267e <find_super_block+0x27e>
			267a: R_X86_64_PC32	__kmalloc-0x4
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:661
    afs_action(ptr_blocks, ret = -ENOMEM, map_fill_err, "could not allocate ptr_blocks [%d]", ret);
    267e:	48 85 c0             	test   %rax,%rax
    2681:	0f 84 f1 00 00 00    	je     2778 <find_super_block+0x378>
rebuild_ptr_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:584
    num_ptr_blocks = config->num_ptr_blocks;
    2687:	45 8b 66 20          	mov    0x20(%r14),%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:578
    uint32_t data_sector_offset = context->passive_fs.data_start_off;
    268b:	41 8b 9e 14 20 00 00 	mov    0x2014(%r14),%ebx
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:662
    context->afs_ptr_blocks = ptr_blocks;
    2692:	49 89 86 60 b0 03 00 	mov    %rax,0x3b060(%r14)
rebuild_ptr_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:585
    for (i = 0; i < num_ptr_blocks; i++) {
    2699:	45 85 e4             	test   %r12d,%r12d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:578
    uint32_t data_sector_offset = context->passive_fs.data_start_off;
    269c:	89 9d f8 fe ff ff    	mov    %ebx,-0x108(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:585
    for (i = 0; i < num_ptr_blocks; i++) {
    26a2:	74 45                	je     26e9 <find_super_block+0x2e9>
    26a4:	49 89 c5             	mov    %rax,%r13
    26a7:	45 31 ff             	xor    %r15d,%r15d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:586
        block_num = (i == 0) ? context->super_block.first_ptr_block : afs_ptr_blocks[i].next_ptr_block;
    26aa:	45 85 ff             	test   %r15d,%r15d
    26ad:	0f 84 b9 00 00 00    	je     276c <find_super_block+0x36c>
    26b3:	41 8b 9d fc 0f 00 00 	mov    0xffc(%r13),%ebx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:587
        ret = read_page(afs_ptr_blocks + i, context->bdev, block_num, data_sector_offset, false);
    26ba:	49 8b 76 08          	mov    0x8(%r14),%rsi
    26be:	8b 8d f8 fe ff ff    	mov    -0x108(%rbp),%ecx
    26c4:	45 31 c0             	xor    %r8d,%r8d
    26c7:	89 da                	mov    %ebx,%edx
    26c9:	4c 89 ef             	mov    %r13,%rdi
    26cc:	e8 00 00 00 00       	callq  26d1 <find_super_block+0x2d1>
			26cd: R_X86_64_PC32	read_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:588
        afs_assert(!ret, done, "could not read pointer block [%d:%u]", ret, block_num);
    26d1:	85 c0                	test   %eax,%eax
    26d3:	0f 85 e1 00 00 00    	jne    27ba <find_super_block+0x3ba>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:585
    for (i = 0; i < num_ptr_blocks; i++) {
    26d9:	41 83 c7 01          	add    $0x1,%r15d
    26dd:	49 81 c5 00 10 00 00 	add    $0x1000,%r13
    26e4:	45 39 fc             	cmp    %r15d,%r12d
    26e7:	75 c1                	jne    26aa <find_super_block+0x2aa>
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:666

    ret = rebuild_ptr_blocks(context);
    afs_assert(!ret, ptr_block_err, "could not rebuild Artifice pointer blocks [%d]", ret);
    afs_debug("Artifice pointer blocks rebuilt");
    26e9:	44 8b 15 00 00 00 00 	mov    0x0(%rip),%r10d        # 26f0 <find_super_block+0x2f0>
			26ec: R_X86_64_PC32	afs_debug_mode-0x4
    26f0:	45 85 d2             	test   %r10d,%r10d
    26f3:	0f 85 1f 01 00 00    	jne    2818 <find_super_block+0x418>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:678
map_fill_err:
    vfree(context->afs_map);

err:
    return ret;
}
    26f9:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
    26fd:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    2704:	00 00 
    2706:	44 89 d0             	mov    %r10d,%eax
    2709:	0f 85 2b 01 00 00    	jne    283a <find_super_block+0x43a>
    270f:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
    2716:	5b                   	pop    %rbx
    2717:	41 5c                	pop    %r12
    2719:	41 5d                	pop    %r13
    271b:	41 5e                	pop    %r14
    271d:	41 5f                	pop    %r15
    271f:	5d                   	pop    %rbp
    2720:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:633
            afs_debug("Superblock read attempt %u failed", sb_tries);
    2721:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 2727 <find_super_block+0x327>
			2723: R_X86_64_PC32	afs_debug_mode-0x4
    2727:	85 c9                	test   %ecx,%ecx
    2729:	0f 85 10 01 00 00    	jne    283f <find_super_block+0x43f>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:634
            sb_tries++;
    272f:	83 c3 01             	add    $0x1,%ebx
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:617
    while (sb_tries < 32){
    2732:	83 fb 1f             	cmp    $0x1f,%ebx
    2735:	0f 86 2e fd ff ff    	jbe    2469 <find_super_block+0x69>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:639
    allocation_set(&context->vector, sb_block[0]);
    273b:	49 8d be 08 21 00 00 	lea    0x2108(%r14),%rdi
    2742:	44 89 fe             	mov    %r15d,%esi
    2745:	e8 00 00 00 00       	callq  274a <find_super_block+0x34a>
			2746: R_X86_64_PC32	allocation_set-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:641
    afs_action(!ret, ret = -ENOENT, err, "super block corrupted");
    274a:	ba 81 02 00 00       	mov    $0x281,%edx
    274f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2752: R_X86_64_32S	.rodata+0xa0
    2756:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2759: R_X86_64_32S	.rodata.str1.8+0x11a8
    275d:	31 c0                	xor    %eax,%eax
    275f:	e8 00 00 00 00       	callq  2764 <find_super_block+0x364>
			2760: R_X86_64_PC32	printk-0x4
    2764:	41 ba fe ff ff ff    	mov    $0xfffffffe,%r10d
    276a:	eb 8d                	jmp    26f9 <find_super_block+0x2f9>
rebuild_ptr_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:586
        block_num = (i == 0) ? context->super_block.first_ptr_block : afs_ptr_blocks[i].next_ptr_block;
    276c:	41 8b 9e fc 1f 00 00 	mov    0x1ffc(%r14),%ebx
    2773:	e9 42 ff ff ff       	jmpq   26ba <find_super_block+0x2ba>
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:661 (discriminator 1)
    afs_action(ptr_blocks, ret = -ENOMEM, map_fill_err, "could not allocate ptr_blocks [%d]", ret);
    2778:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    277d:	ba 95 02 00 00       	mov    $0x295,%edx
    2782:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2785: R_X86_64_32S	.rodata+0xa0
    2789:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			278c: R_X86_64_32S	.rodata.str1.8+0x1020
    2790:	e8 00 00 00 00       	callq  2795 <find_super_block+0x395>
			2791: R_X86_64_PC32	printk-0x4
    2795:	41 ba f4 ff ff ff    	mov    $0xfffffff4,%r10d
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:674
    vfree(context->afs_map);
    279b:	49 8b be 50 b0 03 00 	mov    0x3b050(%r14),%rdi
    27a2:	44 89 95 f8 fe ff ff 	mov    %r10d,-0x108(%rbp)
    27a9:	e8 00 00 00 00       	callq  27ae <find_super_block+0x3ae>
			27aa: R_X86_64_PC32	vfree-0x4
    27ae:	44 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%r10d
    27b5:	e9 3f ff ff ff       	jmpq   26f9 <find_super_block+0x2f9>
rebuild_ptr_blocks():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:588
        afs_assert(!ret, done, "could not read pointer block [%d:%u]", ret, block_num);
    27ba:	41 89 d8             	mov    %ebx,%r8d
    27bd:	89 c1                	mov    %eax,%ecx
    27bf:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%rbp)
    27c5:	ba 4c 02 00 00       	mov    $0x24c,%edx
    27ca:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			27cd: R_X86_64_32S	.rodata+0x80
    27d1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			27d4: R_X86_64_32S	.rodata.str1.8+0xc10
    27d8:	31 c0                	xor    %eax,%eax
    27da:	e8 00 00 00 00       	callq  27df <find_super_block+0x3df>
			27db: R_X86_64_PC32	printk-0x4
find_super_block():
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:665
    afs_assert(!ret, ptr_block_err, "could not rebuild Artifice pointer blocks [%d]", ret);
    27df:	44 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%r10d
    27e6:	ba 99 02 00 00       	mov    $0x299,%edx
    27eb:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			27ee: R_X86_64_32S	.rodata+0xa0
    27f2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			27f5: R_X86_64_32S	.rodata.str1.8+0x12c8
    27f9:	31 c0                	xor    %eax,%eax
    27fb:	44 89 d1             	mov    %r10d,%ecx
    27fe:	e8 00 00 00 00       	callq  2803 <find_super_block+0x403>
			27ff: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:671
    kfree(context->afs_map_blocks);
    2803:	49 8b be 58 b0 03 00 	mov    0x3b058(%r14),%rdi
    280a:	e8 00 00 00 00       	callq  280f <find_super_block+0x40f>
			280b: R_X86_64_PC32	kfree-0x4
    280f:	44 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%r10d
    2816:	eb 83                	jmp    279b <find_super_block+0x39b>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:666 (discriminator 1)
    afs_debug("Artifice pointer blocks rebuilt");
    2818:	ba 9a 02 00 00       	mov    $0x29a,%edx
    281d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2820: R_X86_64_32S	.rodata+0xa0
    2824:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2827: R_X86_64_32S	.rodata.str1.8+0x1310
    282b:	31 c0                	xor    %eax,%eax
    282d:	e8 00 00 00 00       	callq  2832 <find_super_block+0x432>
			282e: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:668 (discriminator 1)
    return 0;
    2832:	45 31 d2             	xor    %r10d,%r10d
    2835:	e9 bf fe ff ff       	jmpq   26f9 <find_super_block+0x2f9>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:678
}
    283a:	e8 00 00 00 00       	callq  283f <find_super_block+0x43f>
			283b: R_X86_64_PC32	__stack_chk_fail-0x4
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:633 (discriminator 1)
            afs_debug("Superblock read attempt %u failed", sb_tries);
    283f:	89 d9                	mov    %ebx,%ecx
    2841:	ba 79 02 00 00       	mov    $0x279,%edx
    2846:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2849: R_X86_64_32S	.rodata+0xa0
    284d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2850: R_X86_64_32S	.rodata.str1.8+0x1168
    2854:	31 c0                	xor    %eax,%eax
    2856:	e8 00 00 00 00       	callq  285b <find_super_block+0x45b>
			2857: R_X86_64_PC32	printk-0x4
    285b:	e9 cf fe ff ff       	jmpq   272f <find_super_block+0x32f>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:627 (discriminator 1)
        afs_assert(!ret, err, "could not read super block page [%d]", ret);
    2860:	89 c1                	mov    %eax,%ecx
    2862:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%rbp)
    2868:	ba 73 02 00 00       	mov    $0x273,%edx
    286d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2870: R_X86_64_32S	.rodata+0xa0
    2874:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2877: R_X86_64_32S	.rodata.str1.8+0x1128
    287b:	31 c0                	xor    %eax,%eax
    287d:	e8 00 00 00 00       	callq  2882 <find_super_block+0x482>
			287e: R_X86_64_PC32	printk-0x4
    2882:	44 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%r10d
    2889:	e9 6b fe ff ff       	jmpq   26f9 <find_super_block+0x2f9>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:644 (discriminator 1)
    afs_action(config->instance_size == sb->instance_size, ret = -EINVAL, err,
    288e:	ba 85 02 00 00       	mov    $0x285,%edx
    2893:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2896: R_X86_64_32S	.rodata+0xa0
    289a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			289d: R_X86_64_32S	.rodata.str1.8+0x11d8
    28a1:	31 c0                	xor    %eax,%eax
    28a3:	e8 00 00 00 00       	callq  28a8 <find_super_block+0x4a8>
			28a4: R_X86_64_PC32	printk-0x4
    28a8:	41 ba ea ff ff ff    	mov    $0xffffffea,%r10d
    28ae:	e9 46 fe ff ff       	jmpq   26f9 <find_super_block+0x2f9>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:651 (discriminator 1)
    afs_assert(!ret, err, "could not create artifice map [%d]", ret);
    28b3:	89 c1                	mov    %eax,%ecx
    28b5:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%rbp)
    28bb:	ba 8b 02 00 00       	mov    $0x28b,%edx
    28c0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			28c3: R_X86_64_32S	.rodata+0xa0
    28c7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			28ca: R_X86_64_32S	.rodata.str1.8+0x1218
    28ce:	31 c0                	xor    %eax,%eax
    28d0:	e8 00 00 00 00       	callq  28d5 <find_super_block+0x4d5>
			28d1: R_X86_64_PC32	printk-0x4
    28d5:	44 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%r10d
    28dc:	e9 18 fe ff ff       	jmpq   26f9 <find_super_block+0x2f9>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:654 (discriminator 1)
    afs_assert(!ret, map_fill_err, "could not fill artifice map [%d]", ret);
    28e1:	89 c1                	mov    %eax,%ecx
    28e3:	ba 8e 02 00 00       	mov    $0x28e,%edx
    28e8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			28eb: R_X86_64_32S	.rodata+0xa0
    28ef:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			28f2: R_X86_64_32S	.rodata.str1.8+0x1258
    28f6:	31 c0                	xor    %eax,%eax
    28f8:	e8 00 00 00 00       	callq  28fd <find_super_block+0x4fd>
			28f9: R_X86_64_PC32	printk-0x4
    28fd:	45 89 e2             	mov    %r12d,%r10d
    2900:	e9 96 fe ff ff       	jmpq   279b <find_super_block+0x39b>
/home/austen/programming/dm-afs/src/dm_afs_metadata.c:656 (discriminator 1)
    afs_debug("Artifice map rebuilt");
    2905:	ba 90 02 00 00       	mov    $0x290,%edx
    290a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			290d: R_X86_64_32S	.rodata+0xa0
    2911:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2914: R_X86_64_32S	.rodata.str1.8+0x1298
    2918:	31 c0                	xor    %eax,%eax
    291a:	e8 00 00 00 00       	callq  291f <find_super_block+0x51f>
			291b: R_X86_64_PC32	printk-0x4
    291f:	e9 48 fd ff ff       	jmpq   266c <find_super_block+0x26c>
    2924:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    292b:	00 00 00 
    292e:	66 90                	xchg   %ax,%ax

0000000000002930 <afs_req_clean>:
afs_req_clean():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:115
afs_get_map_entry(uint8_t *map, struct afs_config *config, uint32_t index)
{
    return map + (index * config->map_entry_sz);
}

static void afs_req_clean(struct afs_map_request *req){
    2930:	e8 00 00 00 00       	callq  2935 <afs_req_clean+0x5>
			2931: R_X86_64_PC32	__fentry__-0x4
    2935:	55                   	push   %rbp
    2936:	48 89 e5             	mov    %rsp,%rbp
    2939:	53                   	push   %rbx
    293a:	48 89 fb             	mov    %rdi,%rbx
    293d:	48 83 ec 08          	sub    $0x8,%rsp
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
    2941:	48 c7 87 00 90 01 00 	movq   $0x4,0x19000(%rdi)
    2948:	04 00 00 00 
afs_req_clean():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:121

    //set the state of the request to completed
    atomic64_set(&req->state, REQ_STATE_COMPLETED);

    //end the virtual block device's recieved bio
    bio_endio(req->bio);
    294c:	48 8b bf 08 90 01 00 	mov    0x19008(%rdi),%rdi
    2953:	e8 00 00 00 00       	callq  2958 <afs_req_clean+0x28>
			2954: R_X86_64_PC32	bio_endio-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:124

    //free any dynamically allocated objects in the request struct
    if(req->carrier_blocks){
    2958:	48 8b bb 50 90 01 00 	mov    0x19050(%rbx),%rdi
    295f:	48 85 ff             	test   %rdi,%rdi
    2962:	74 05                	je     2969 <afs_req_clean+0x39>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:125
        kfree(req->carrier_blocks);
    2964:	e8 00 00 00 00       	callq  2969 <afs_req_clean+0x39>
			2965: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:127
    }
    if(req->block_nums){
    2969:	48 8b bb 68 90 01 00 	mov    0x19068(%rbx),%rdi
    2970:	48 85 ff             	test   %rdi,%rdi
    2973:	74 05                	je     297a <afs_req_clean+0x4a>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:128
        kfree(req->block_nums);
    2975:	e8 00 00 00 00       	callq  297a <afs_req_clean+0x4a>
			2976: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:133
    }
    //TODO figure out a safer cleanup option
    //re-enable when we want libgfshare
    //gfshare_ctx_free(req->encoder);   
    if (req->allocated_write_page) {
    297a:	48 8b bb 38 90 01 00 	mov    0x19038(%rbx),%rdi
    2981:	48 85 ff             	test   %rdi,%rdi
    2984:	74 05                	je     298b <afs_req_clean+0x5b>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:134
        kfree(req->allocated_write_page);
    2986:	e8 00 00 00 00       	callq  298b <afs_req_clean+0x5b>
			2987: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:136
    } 
}
    298b:	48 83 c4 08          	add    $0x8,%rsp
    298f:	5b                   	pop    %rbx
    2990:	5d                   	pop    %rbp
    2991:	c3                   	retq   
    2992:	0f 1f 40 00          	nopl   0x0(%rax)
    2996:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    299d:	00 00 00 

00000000000029a0 <afs_write_endio>:
afs_write_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:201
        schedule_work(element->clean_ws);
    }
    return;
}

static void afs_write_endio(struct bio *bio){
    29a0:	e8 00 00 00 00       	callq  29a5 <afs_write_endio+0x5>
			29a1: R_X86_64_PC32	__fentry__-0x4
    29a5:	55                   	push   %rbp
    29a6:	48 89 e5             	mov    %rsp,%rbp
    29a9:	41 55                	push   %r13
    29ab:	41 54                	push   %r12
    29ad:	53                   	push   %rbx
    29ae:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_engine.c:202
    struct afs_bio_private *ctx = bio->bi_private;
    29b2:	48 8b 5f 50          	mov    0x50(%rdi),%rbx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:203
    struct afs_map_request *req = ctx->req;
    29b6:	4c 8b 23             	mov    (%rbx),%r12
/home/austen/programming/dm-afs/src/dm_afs_engine.c:211
    uint8_t *map_entry = NULL;
    uint8_t *map_entry_hash = NULL;
    uint8_t *map_entry_entropy = NULL;
    struct afs_map_queue *element = NULL;

    bio_put(bio); 
    29b9:	e8 00 00 00 00       	callq  29be <afs_write_endio+0x1e>
			29ba: R_X86_64_PC32	bio_put-0x4
atomic_dec_and_test():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/atomic.h:118
    29be:	f0 ff 4b 08          	lock decl 0x8(%rbx)
afs_write_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:212
    if(atomic_dec_and_test(&ctx->bios_pending)){
    29c2:	0f 85 87 00 00 00    	jne    2a4f <afs_write_endio+0xaf>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:213
        map_entry = afs_get_map_entry(req->map, req->config, req->block);
    29c8:	49 8b 94 24 20 90 01 	mov    0x19020(%r12),%rdx
    29cf:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:219
        map_entry_tuple = (struct afs_map_tuple *)map_entry;
        map_entry_hash = map_entry + (req->config->num_carrier_blocks * sizeof(*map_entry_tuple));
        map_entry_entropy = map_entry_hash + SHA128_SZ;

        // TODO: Set the entropy hash correctly, may not be needed
        digest = cityhash128_to_array(CityHash128(req->data_block, AFS_BLOCK_SIZE));
    29d0:	49 8d bc 24 00 80 01 	lea    0x18000(%r12),%rdi
    29d7:	00 
    29d8:	be 00 10 00 00       	mov    $0x1000,%esi
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    29dd:	0f b6 42 02          	movzbl 0x2(%rdx),%eax
afs_write_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:215
        map_entry_hash = map_entry + (req->config->num_carrier_blocks * sizeof(*map_entry_tuple));
    29e1:	0f b6 12             	movzbl (%rdx),%edx
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    29e4:	41 0f af 84 24 58 90 	imul   0x19058(%r12),%eax
    29eb:	01 00 
afs_write_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:215
        map_entry_hash = map_entry + (req->config->num_carrier_blocks * sizeof(*map_entry_tuple));
    29ed:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
    29f1:	4c 8d 2c 50          	lea    (%rax,%rdx,2),%r13
    29f5:	4d 03 ac 24 10 90 01 	add    0x19010(%r12),%r13
    29fc:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:219
        digest = cityhash128_to_array(CityHash128(req->data_block, AFS_BLOCK_SIZE));
    29fd:	e8 00 00 00 00       	callq  2a02 <afs_write_endio+0x62>
			29fe: R_X86_64_PC32	CityHash128-0x4
cityhash128_to_array():
/home/austen/programming/dm-afs/include/lib/city.h:111

//This should just convert a uint128 from the cityhash library to a byte array
static inline uint8_t* cityhash128_to_array(uint128 hash){
    static uint64_t array[2];
    array[0] = hash.first;
    array[1] = hash.second;
    2a02:	48 89 15 00 00 00 00 	mov    %rdx,0x0(%rip)        # 2a09 <afs_write_endio+0x69>
			2a05: R_X86_64_PC32	.bss+0x4
/home/austen/programming/dm-afs/include/lib/city.h:110
    array[0] = hash.first;
    2a09:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 2a10 <afs_write_endio+0x70>
			2a0c: R_X86_64_PC32	.bss-0x4
afs_write_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:227
        //memcpy(map_entry_hash, digest + (SHA1_SZ - SHA128_SZ), SHA128_SZ);
        memset(map_entry_entropy, 0, ENTROPY_HASH_SZ);
        
        //cleanup
        element = container_of(req, struct afs_map_queue, req);
        afs_req_clean(req);
    2a10:	4c 89 e7             	mov    %r12,%rdi
    2a13:	c5 f9 6f 05 00 00 00 	vmovdqa 0x0(%rip),%xmm0        # 2a1b <afs_write_endio+0x7b>
    2a1a:	00 
			2a17: R_X86_64_PC32	.bss-0x4
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    2a1b:	49 c7 45 10 00 00 00 	movq   $0x0,0x10(%r13)
    2a22:	00 
    2a23:	c4 c1 78 11 45 00    	vmovups %xmm0,0x0(%r13)
afs_write_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:227
    2a29:	e8 02 ff ff ff       	callq  2930 <afs_req_clean>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:228
	kfree(ctx);
    2a2e:	48 89 df             	mov    %rbx,%rdi
    2a31:	e8 00 00 00 00       	callq  2a36 <afs_write_endio+0x96>
			2a32: R_X86_64_PC32	kfree-0x4
queue_work():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/workqueue.h:489
    2a36:	49 8b 94 24 20 a0 01 	mov    0x1a020(%r12),%rdx
    2a3d:	00 
    2a3e:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2a45 <afs_write_endio+0xa5>
			2a41: R_X86_64_PC32	system_wq-0x4
    2a45:	bf 00 20 00 00       	mov    $0x2000,%edi
    2a4a:	e8 00 00 00 00       	callq  2a4f <afs_write_endio+0xaf>
			2a4b: R_X86_64_PC32	queue_work_on-0x4
afs_write_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:232
        schedule_work(element->clean_ws);
    }
    return;
}
    2a4f:	48 83 c4 08          	add    $0x8,%rsp
    2a53:	5b                   	pop    %rbx
    2a54:	41 5c                	pop    %r12
    2a56:	41 5d                	pop    %r13
    2a58:	5d                   	pop    %rbp
    2a59:	c3                   	retq   
    2a5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000002a60 <afs_read_endio>:
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:141
static void afs_read_endio(struct bio *bio){
    2a60:	e8 00 00 00 00       	callq  2a65 <afs_read_endio+0x5>
			2a61: R_X86_64_PC32	__fentry__-0x4
    2a65:	55                   	push   %rbp
    2a66:	48 89 e5             	mov    %rsp,%rbp
    2a69:	41 57                	push   %r15
    2a6b:	41 56                	push   %r14
    2a6d:	41 55                	push   %r13
    2a6f:	41 54                	push   %r12
    2a71:	53                   	push   %rbx
    2a72:	48 83 ec 38          	sub    $0x38,%rsp
/home/austen/programming/dm-afs/src/dm_afs_engine.c:142
    struct afs_bio_private *ctx = bio->bi_private;
    2a76:	48 8b 5f 50          	mov    0x50(%rdi),%rbx
    2a7a:	48 89 5d a8          	mov    %rbx,-0x58(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:143
    struct afs_map_request *req = ctx->req;
    2a7e:	4c 8b 3b             	mov    (%rbx),%r15
/home/austen/programming/dm-afs/src/dm_afs_engine.c:157
    bio_put(bio);
    2a81:	e8 00 00 00 00       	callq  2a86 <afs_read_endio+0x26>
			2a82: R_X86_64_PC32	bio_put-0x4
atomic_dec_and_test():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/atomic.h:118
    2a86:	f0 ff 4b 08          	lock decl 0x8(%rbx)
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:159
    if(atomic_dec_and_test(&ctx->bios_pending)){
    2a8a:	0f 85 dd 01 00 00    	jne    2c6d <afs_read_endio+0x20d>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:161
        map_entry = afs_get_map_entry(req->map, req->config, req->block);
    2a90:	49 8b 97 20 90 01 00 	mov    0x19020(%r15),%rdx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    2a97:	49 8d bf 08 80 01 00 	lea    0x18008(%r15),%rdi
    2a9e:	49 8d b7 00 80 00 00 	lea    0x8000(%r15),%rsi
    2aa5:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    2aa9:	0f b6 42 02          	movzbl 0x2(%rdx),%eax
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:163
        map_entry_hash = map_entry + (req->config->num_carrier_blocks * sizeof(*map_entry_tuple));
    2aad:	0f b6 12             	movzbl (%rdx),%edx
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    2ab0:	41 0f af 87 58 90 01 	imul   0x19058(%r15),%eax
    2ab7:	00 
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:163
        map_entry_hash = map_entry + (req->config->num_carrier_blocks * sizeof(*map_entry_tuple));
    2ab8:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
    2abc:	48 8d 1c 50          	lea    (%rax,%rdx,2),%rbx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:167
        memcpy(req->data_block, req->read_blocks[0], AFS_BLOCK_SIZE);
    2ac0:	49 8d 97 00 80 01 00 	lea    0x18000(%r15),%rdx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:163
        map_entry_hash = map_entry + (req->config->num_carrier_blocks * sizeof(*map_entry_tuple));
    2ac7:	49 03 9f 10 90 01 00 	add    0x19010(%r15),%rbx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:167
        memcpy(req->data_block, req->read_blocks[0], AFS_BLOCK_SIZE);
    2ace:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    2ad2:	49 8b 87 00 80 00 00 	mov    0x8000(%r15),%rax
    2ad9:	49 89 87 00 80 01 00 	mov    %rax,0x18000(%r15)
    2ae0:	49 8b 87 f8 8f 00 00 	mov    0x8ff8(%r15),%rax
    2ae7:	49 89 87 f8 8f 01 00 	mov    %rax,0x18ff8(%r15)
    2aee:	48 89 d0             	mov    %rdx,%rax
    2af1:	48 29 f8             	sub    %rdi,%rax
    2af4:	8d 88 00 10 00 00    	lea    0x1000(%rax),%ecx
    2afa:	48 29 c6             	sub    %rax,%rsi
    2afd:	89 c8                	mov    %ecx,%eax
    2aff:	c1 e8 03             	shr    $0x3,%eax
    2b02:	89 c1                	mov    %eax,%ecx
    2b04:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:171
        digest = cityhash128_to_array(CityHash128(req->data_block, AFS_BLOCK_SIZE));
    2b07:	be 00 10 00 00       	mov    $0x1000,%esi
    2b0c:	48 89 d7             	mov    %rdx,%rdi
    2b0f:	e8 00 00 00 00       	callq  2b14 <afs_read_endio+0xb4>
			2b10: R_X86_64_PC32	CityHash128-0x4
cityhash128_to_array():
/home/austen/programming/dm-afs/include/lib/city.h:110
    2b14:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 2b1b <afs_read_endio+0xbb>
			2b17: R_X86_64_PC32	.bss-0x4
/home/austen/programming/dm-afs/include/lib/city.h:111
    array[1] = hash.second;
    2b1b:	48 89 15 00 00 00 00 	mov    %rdx,0x0(%rip)        # 2b22 <afs_read_endio+0xc2>
			2b1e: R_X86_64_PC32	.bss+0x4
memcmp():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:385
    2b22:	48 8b 03             	mov    (%rbx),%rax
    2b25:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    2b29:	48 33 05 00 00 00 00 	xor    0x0(%rip),%rax        # 2b30 <afs_read_endio+0xd0>
			2b2c: R_X86_64_PC32	.bss-0x4
    2b30:	48 33 15 00 00 00 00 	xor    0x0(%rip),%rdx        # 2b37 <afs_read_endio+0xd7>
			2b33: R_X86_64_PC32	.bss+0x4
    2b37:	48 09 c2             	or     %rax,%rdx
    2b3a:	0f 85 e3 00 00 00    	jne    2c23 <afs_read_endio+0x1c3>
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:178
        bio_for_each_segment (bv, req->bio, iter) {
    2b40:	49 8b b7 08 90 01 00 	mov    0x19008(%r15),%rsi
/home/austen/programming/dm-afs/src/dm_afs_engine.c:177
	segment_offset = 0;
    2b47:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:178
        bio_for_each_segment (bv, req->bio, iter) {
    2b4e:	8b 46 34             	mov    0x34(%rsi),%eax
    2b51:	44 8b 6e 30          	mov    0x30(%rsi),%r13d
    2b55:	44 8b 76 3c          	mov    0x3c(%rsi),%r14d
    2b59:	89 45 cc             	mov    %eax,-0x34(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:178 (discriminator 1)
    2b5c:	45 85 ed             	test   %r13d,%r13d
    2b5f:	0f 84 df 00 00 00    	je     2c44 <afs_read_endio+0x1e4>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:178 (discriminator 3)
    2b65:	44 8b 5d cc          	mov    -0x34(%rbp),%r11d
    2b69:	44 89 f3             	mov    %r14d,%ebx
    2b6c:	4c 89 d8             	mov    %r11,%rax
    2b6f:	4c 89 5d b8          	mov    %r11,-0x48(%rbp)
    2b73:	48 c1 e0 04          	shl    $0x4,%rax
    2b77:	48 03 46 78          	add    0x78(%rsi),%rax
    2b7b:	8b 48 08             	mov    0x8(%rax),%ecx
    2b7e:	48 8b 38             	mov    (%rax),%rdi
    2b81:	44 29 f1             	sub    %r14d,%ecx
    2b84:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
    2b88:	44 39 e9             	cmp    %r13d,%ecx
    2b8b:	41 0f 47 cd          	cmova  %r13d,%ecx
    2b8f:	03 58 0c             	add    0xc(%rax),%ebx
    2b92:	41 89 cc             	mov    %ecx,%r12d
kmap():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/highmem.h:59 (discriminator 3)
    2b95:	e8 00 00 00 00       	callq  2b9a <afs_read_endio+0x13a>
			2b96: R_X86_64_PC32	_cond_resched-0x4
lowmem_page_address():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/mm.h:1087 (discriminator 3)
    2b9a:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    2b9e:	48 2b 3d 00 00 00 00 	sub    0x0(%rip),%rdi        # 2ba5 <afs_read_endio+0x145>
			2ba1: R_X86_64_PC32	vmemmap_base-0x4
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:180 (discriminator 3)
            if (bv.bv_len <= (req->request_size - segment_offset)) {
    2ba5:	8b 75 c8             	mov    -0x38(%rbp),%esi
    2ba8:	41 8b 97 5c 90 01 00 	mov    0x1905c(%r15),%edx
    2baf:	4c 8b 5d b8          	mov    -0x48(%rbp),%r11
lowmem_page_address():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/mm.h:1087 (discriminator 3)
    2bb3:	48 c1 ff 06          	sar    $0x6,%rdi
    2bb7:	48 c1 e7 0c          	shl    $0xc,%rdi
    2bbb:	48 03 3d 00 00 00 00 	add    0x0(%rip),%rdi        # 2bc2 <afs_read_endio+0x162>
			2bbe: R_X86_64_PC32	page_offset_base-0x4
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:180 (discriminator 3)
    2bc2:	29 f2                	sub    %esi,%edx
    2bc4:	48 01 df             	add    %rbx,%rdi
    2bc7:	44 39 e2             	cmp    %r12d,%edx
    2bca:	0f 82 02 01 00 00    	jb     2cd2 <afs_read_endio+0x272>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:181
                memcpy(bio_data + bv.bv_offset, req->data_block + (req->sector_offset * AFS_SECTOR_SIZE) + segment_offset, bv.bv_len);
    2bd0:	41 8b 87 60 90 01 00 	mov    0x19060(%r15),%eax
    2bd7:	44 89 e2             	mov    %r12d,%edx
    2bda:	4c 89 5d c0          	mov    %r11,-0x40(%rbp)
    2bde:	c1 e0 09             	shl    $0x9,%eax
    2be1:	48 01 c6             	add    %rax,%rsi
    2be4:	48 03 75 b0          	add    -0x50(%rbp),%rsi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    2be8:	e8 00 00 00 00       	callq  2bed <afs_read_endio+0x18d>
			2be9: R_X86_64_PC32	memcpy-0x4
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:178
        bio_for_each_segment (bv, req->bio, iter) {
    2bed:	49 8b b7 08 90 01 00 	mov    0x19008(%r15),%rsi
/home/austen/programming/dm-afs/src/dm_afs_engine.c:187
            segment_offset += bv.bv_len;
    2bf4:	44 01 65 c8          	add    %r12d,-0x38(%rbp)
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:169
    2bf8:	8b 56 10             	mov    0x10(%rsi),%edx
bio_no_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:96
    2bfb:	0f b6 c2             	movzbl %dl,%eax
    2bfe:	83 e8 05             	sub    $0x5,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:98
    2c01:	83 e0 fb             	and    $0xfffffffb,%eax
    2c04:	74 0f                	je     2c15 <afs_read_endio+0x1b5>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:96
    2c06:	81 e2 fb 00 00 00    	and    $0xfb,%edx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:98
    2c0c:	4c 8b 5d c0          	mov    -0x40(%rbp),%r11
    2c10:	83 fa 03             	cmp    $0x3,%edx
    2c13:	75 67                	jne    2c7c <afs_read_endio+0x21c>
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:170
    2c15:	45 29 e5             	sub    %r12d,%r13d
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:178
        bio_for_each_segment (bv, req->bio, iter) {
    2c18:	45 85 ed             	test   %r13d,%r13d
    2c1b:	0f 85 44 ff ff ff    	jne    2b65 <afs_read_endio+0x105>
    2c21:	eb 21                	jmp    2c44 <afs_read_endio+0x1e4>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:175
        afs_action(!ret, ret = -ENOENT, err, "data block is corrupted [%u]", req->block);
    2c23:	41 8b 8f 58 90 01 00 	mov    0x19058(%r15),%ecx
    2c2a:	ba af 00 00 00       	mov    $0xaf,%edx
    2c2f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			2c32: R_X86_64_32S	.rodata+0x1a8
    2c36:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2c39: R_X86_64_32S	.rodata.str1.8+0x1350
    2c3d:	31 c0                	xor    %eax,%eax
    2c3f:	e8 00 00 00 00       	callq  2c44 <afs_read_endio+0x1e4>
			2c40: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:194
        afs_req_clean(req);
    2c44:	4c 89 ff             	mov    %r15,%rdi
    2c47:	e8 e4 fc ff ff       	callq  2930 <afs_req_clean>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:195
	kfree(ctx);
    2c4c:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    2c50:	e8 00 00 00 00       	callq  2c55 <afs_read_endio+0x1f5>
			2c51: R_X86_64_PC32	kfree-0x4
queue_work():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/workqueue.h:489
    2c55:	49 8b 97 20 a0 01 00 	mov    0x1a020(%r15),%rdx
    2c5c:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2c63 <afs_read_endio+0x203>
			2c5f: R_X86_64_PC32	system_wq-0x4
    2c63:	bf 00 20 00 00       	mov    $0x2000,%edi
    2c68:	e8 00 00 00 00       	callq  2c6d <afs_read_endio+0x20d>
			2c69: R_X86_64_PC32	queue_work_on-0x4
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:199
}
    2c6d:	48 83 c4 38          	add    $0x38,%rsp
    2c71:	5b                   	pop    %rbx
    2c72:	41 5c                	pop    %r12
    2c74:	41 5d                	pop    %r13
    2c76:	41 5e                	pop    %r14
    2c78:	41 5f                	pop    %r15
    2c7a:	5d                   	pop    %rbp
    2c7b:	c3                   	retq   
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:75
    2c7c:	45 39 ec             	cmp    %r13d,%r12d
    2c7f:	77 6c                	ja     2ced <afs_read_endio+0x28d>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:81
    2c81:	45 85 e4             	test   %r12d,%r12d
    2c84:	0f 84 d2 fe ff ff    	je     2b5c <afs_read_endio+0xfc>
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:173
    2c8a:	48 8b 7e 78          	mov    0x78(%rsi),%rdi
    2c8e:	eb 04                	jmp    2c94 <afs_read_endio+0x234>
    2c90:	44 8b 5d cc          	mov    -0x34(%rbp),%r11d
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:82
    2c94:	49 c1 e3 04          	shl    $0x4,%r11
    2c98:	42 8b 54 1f 08       	mov    0x8(%rdi,%r11,1),%edx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:83
    2c9d:	45 89 eb             	mov    %r13d,%r11d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:82
    2ca0:	89 d0                	mov    %edx,%eax
    2ca2:	44 29 f0             	sub    %r14d,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:83
    2ca5:	45 39 ec             	cmp    %r13d,%r12d
    2ca8:	45 0f 46 dc          	cmovbe %r12d,%r11d
    2cac:	44 39 d8             	cmp    %r11d,%eax
    2caf:	41 0f 47 c3          	cmova  %r11d,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:87
    2cb3:	41 01 c6             	add    %eax,%r14d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:85
    2cb6:	41 29 c4             	sub    %eax,%r12d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:86
    2cb9:	41 29 c5             	sub    %eax,%r13d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:90
    2cbc:	44 39 f2             	cmp    %r14d,%edx
    2cbf:	75 07                	jne    2cc8 <afs_read_endio+0x268>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:92
    2cc1:	83 45 cc 01          	addl   $0x1,-0x34(%rbp)
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:91
    2cc5:	45 31 f6             	xor    %r14d,%r14d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:81
    2cc8:	45 85 e4             	test   %r12d,%r12d
    2ccb:	75 c3                	jne    2c90 <afs_read_endio+0x230>
    2ccd:	e9 8a fe ff ff       	jmpq   2b5c <afs_read_endio+0xfc>
afs_read_endio():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:183
                memcpy(bio_data + bv.bv_offset, req->data_block + (req->sector_offset * AFS_SECTOR_SIZE) + segment_offset, req->request_size - segment_offset);
    2cd2:	41 8b 87 60 90 01 00 	mov    0x19060(%r15),%eax
    2cd9:	c1 e0 09             	shl    $0x9,%eax
    2cdc:	48 01 c6             	add    %rax,%rsi
    2cdf:	48 03 75 b0          	add    -0x50(%rbp),%rsi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    2ce3:	e8 00 00 00 00       	callq  2ce8 <afs_read_endio+0x288>
			2ce4: R_X86_64_PC32	memcpy-0x4
    2ce8:	e9 57 ff ff ff       	jmpq   2c44 <afs_read_endio+0x1e4>
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:75
    2ced:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 2cf4 <afs_read_endio+0x294>
			2cef: R_X86_64_PC32	.data.once-0x5
    2cf4:	0f 85 4a ff ff ff    	jne    2c44 <afs_read_endio+0x1e4>
    2cfa:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2cfd: R_X86_64_32S	.rodata.str1.8+0x1388
    2d01:	31 c0                	xor    %eax,%eax
    2d03:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 2d0a <afs_read_endio+0x2aa>
			2d05: R_X86_64_PC32	.data.once-0x5
    2d0a:	e8 00 00 00 00       	callq  2d0f <afs_read_endio+0x2af>
			2d0b: R_X86_64_PC32	__warn_printk-0x4
    2d0f:	0f 0b                	ud2    
    2d11:	e9 2e ff ff ff       	jmpq   2c44 <afs_read_endio+0x1e4>
afs_read_endio():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:75
    2d16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    2d1d:	00 00 00 

0000000000002d20 <afs_eq_init>:
afs_eq_init():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:37
{
    2d20:	e8 00 00 00 00       	callq  2d25 <afs_eq_init+0x5>
			2d21: R_X86_64_PC32	__fentry__-0x4
    2d25:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_engine.c:38
    INIT_LIST_HEAD(&eq->mq.list);
    2d26:	48 8d 87 30 a0 01 00 	lea    0x1a030(%rdi),%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:39
    spin_lock_init(&eq->mq_lock);
    2d2d:	c7 87 00 b0 01 00 00 	movl   $0x0,0x1b000(%rdi)
    2d34:	00 00 00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:37
{
    2d37:	48 89 e5             	mov    %rsp,%rbp
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
    2d3a:	48 89 87 30 a0 01 00 	mov    %rax,0x1a030(%rdi)
INIT_LIST_HEAD():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:29
    2d41:	48 89 87 38 a0 01 00 	mov    %rax,0x1a038(%rdi)
afs_eq_init():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:40
}
    2d48:	5d                   	pop    %rbp
    2d49:	c3                   	retq   
    2d4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000002d50 <afs_eq_add>:
afs_eq_add():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:47
{
    2d50:	e8 00 00 00 00       	callq  2d55 <afs_eq_add+0x5>
			2d51: R_X86_64_PC32	__fentry__-0x4
    2d55:	55                   	push   %rbp
    2d56:	48 89 e5             	mov    %rsp,%rbp
    2d59:	41 55                	push   %r13
    2d5b:	41 54                	push   %r12
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    2d5d:	4c 8d a7 00 b0 01 00 	lea    0x1b000(%rdi),%r12
afs_eq_add():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:47
    2d64:	53                   	push   %rbx
    2d65:	49 89 f5             	mov    %rsi,%r13
    2d68:	48 89 fb             	mov    %rdi,%rbx
    2d6b:	48 83 ec 08          	sub    $0x8,%rsp
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    2d6f:	4c 89 e7             	mov    %r12,%rdi
afs_eq_add():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:49
    list_add_tail(&element->list, &eq->mq.list);
    2d72:	48 81 c3 30 a0 01 00 	add    $0x1a030,%rbx
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    2d79:	e8 00 00 00 00       	callq  2d7e <afs_eq_add+0x2e>
			2d7a: R_X86_64_PC32	_raw_spin_lock-0x4
list_add_tail():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:93
    2d7e:	48 8b 43 08          	mov    0x8(%rbx),%rax
afs_eq_add():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:49
    2d82:	49 8d 95 30 a0 01 00 	lea    0x1a030(%r13),%rdx
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
    2d89:	4c 89 e7             	mov    %r12,%rdi
__list_add():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:63
    2d8c:	48 89 53 08          	mov    %rdx,0x8(%rbx)
afs_eq_add():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:49
    2d90:	49 89 9d 30 a0 01 00 	mov    %rbx,0x1a030(%r13)
__list_add():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:65
    2d97:	49 89 85 38 a0 01 00 	mov    %rax,0x1a038(%r13)
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
    2d9e:	48 89 10             	mov    %rdx,(%rax)
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
    2da1:	ff 14 25 00 00 00 00 	callq  *0x0
			2da4: R_X86_64_32S	pv_lock_ops+0x8
afs_eq_add():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:51
}
    2da8:	48 83 c4 08          	add    $0x8,%rsp
    2dac:	5b                   	pop    %rbx
    2dad:	41 5c                	pop    %r12
    2daf:	41 5d                	pop    %r13
    2db1:	5d                   	pop    %rbp
    2db2:	c3                   	retq   
    2db3:	0f 1f 00             	nopl   (%rax)
    2db6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    2dbd:	00 00 00 

0000000000002dc0 <afs_eq_empty_unsafe>:
afs_eq_empty_unsafe():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:58
{
    2dc0:	e8 00 00 00 00       	callq  2dc5 <afs_eq_empty_unsafe+0x5>
			2dc1: R_X86_64_PC32	__fentry__-0x4
    2dc5:	55                   	push   %rbp
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188
    2dc6:	48 8b 87 30 a0 01 00 	mov    0x1a030(%rdi),%rax
afs_eq_empty_unsafe():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:59
    return list_empty(&eq->mq.list);
    2dcd:	48 81 c7 30 a0 01 00 	add    $0x1a030,%rdi
/home/austen/programming/dm-afs/src/dm_afs_engine.c:58
{
    2dd4:	48 89 e5             	mov    %rsp,%rbp
list_empty():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:203
    2dd7:	48 39 c7             	cmp    %rax,%rdi
    2dda:	0f 94 c0             	sete   %al
afs_eq_empty_unsafe():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:60
}
    2ddd:	5d                   	pop    %rbp
    2dde:	c3                   	retq   
    2ddf:	90                   	nop

0000000000002de0 <afs_eq_empty>:
afs_eq_empty():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:67
{
    2de0:	e8 00 00 00 00       	callq  2de5 <afs_eq_empty+0x5>
			2de1: R_X86_64_PC32	__fentry__-0x4
    2de5:	55                   	push   %rbp
    2de6:	48 89 e5             	mov    %rsp,%rbp
    2de9:	41 54                	push   %r12
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    2deb:	4c 8d a7 00 b0 01 00 	lea    0x1b000(%rdi),%r12
afs_eq_empty():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:67
    2df2:	53                   	push   %rbx
    2df3:	48 89 fb             	mov    %rdi,%rbx
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    2df6:	4c 89 e7             	mov    %r12,%rdi
    2df9:	e8 00 00 00 00       	callq  2dfe <afs_eq_empty+0x1e>
			2dfa: R_X86_64_PC32	_raw_spin_lock-0x4
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188
    2dfe:	48 8b 93 30 a0 01 00 	mov    0x1a030(%rbx),%rdx
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
    2e05:	4c 89 e7             	mov    %r12,%rdi
    2e08:	ff 14 25 00 00 00 00 	callq  *0x0
			2e0b: R_X86_64_32S	pv_lock_ops+0x8
afs_eq_empty_unsafe():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:59
    return list_empty(&eq->mq.list);
    2e0f:	48 81 c3 30 a0 01 00 	add    $0x1a030,%rbx
list_empty():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/list.h:203
    2e16:	48 39 d3             	cmp    %rdx,%rbx
    2e19:	0f 94 c0             	sete   %al
afs_eq_empty():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:75
}
    2e1c:	5b                   	pop    %rbx
    2e1d:	41 5c                	pop    %r12
    2e1f:	5d                   	pop    %rbp
    2e20:	c3                   	retq   
    2e21:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    2e26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    2e2d:	00 00 00 

0000000000002e30 <afs_eq_req_exist>:
afs_eq_req_exist():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:83
{
    2e30:	e8 00 00 00 00       	callq  2e35 <afs_eq_req_exist+0x5>
			2e31: R_X86_64_PC32	__fentry__-0x4
    2e35:	55                   	push   %rbp
    2e36:	48 89 e5             	mov    %rsp,%rbp
    2e39:	41 55                	push   %r13
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    2e3b:	4c 8d af 00 b0 01 00 	lea    0x1b000(%rdi),%r13
afs_eq_req_exist():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:83
    2e42:	41 54                	push   %r12
    2e44:	53                   	push   %rbx
    2e45:	49 89 fc             	mov    %rdi,%r12
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    2e48:	4c 89 ef             	mov    %r13,%rdi
afs_eq_req_exist():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:83
    2e4b:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_engine.c:90
    block_num = (bio->bi_iter.bi_sector * AFS_SECTOR_SIZE) / AFS_BLOCK_SIZE;
    2e4f:	48 8b 5e 28          	mov    0x28(%rsi),%rbx
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    2e53:	e8 00 00 00 00       	callq  2e58 <afs_eq_req_exist+0x28>
			2e54: R_X86_64_PC32	_raw_spin_lock-0x4
afs_eq_req_exist():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:92
    list_for_each_entry (node, &eq->mq.list, list) {
    2e58:	49 8b 84 24 30 a0 01 	mov    0x1a030(%r12),%rax
    2e5f:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:90
    block_num = (bio->bi_iter.bi_sector * AFS_SECTOR_SIZE) / AFS_BLOCK_SIZE;
    2e60:	48 c1 e3 1d          	shl    $0x1d,%rbx
    2e64:	48 c1 eb 20          	shr    $0x20,%rbx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:92
    list_for_each_entry (node, &eq->mq.list, list) {
    2e68:	48 8d 90 d0 5f fe ff 	lea    -0x1a030(%rax),%rdx
    2e6f:	49 39 d4             	cmp    %rdx,%r12
    2e72:	75 15                	jne    2e89 <afs_eq_req_exist+0x59>
    2e74:	eb 3e                	jmp    2eb4 <afs_eq_req_exist+0x84>
    2e76:	48 8b 92 30 a0 01 00 	mov    0x1a030(%rdx),%rdx
    2e7d:	48 81 ea 30 a0 01 00 	sub    $0x1a030,%rdx
    2e84:	49 39 d4             	cmp    %rdx,%r12
    2e87:	74 2b                	je     2eb4 <afs_eq_req_exist+0x84>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:94
        node_block_num = (node_bio->bi_iter.bi_sector * AFS_SECTOR_SIZE) / AFS_BLOCK_SIZE;
    2e89:	48 8b 8a 08 90 01 00 	mov    0x19008(%rdx),%rcx
    2e90:	48 8b 49 28          	mov    0x28(%rcx),%rcx
    2e94:	48 c1 e1 09          	shl    $0x9,%rcx
    2e98:	48 c1 e9 0c          	shr    $0xc,%rcx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:95
        if (block_num == node_block_num && atomic64_read(&node->req.state) == REQ_STATE_FLIGHT) {
    2e9c:	39 cb                	cmp    %ecx,%ebx
    2e9e:	75 d6                	jne    2e76 <afs_eq_req_exist+0x46>
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188 (discriminator 1)
    2ea0:	48 8b 8a 00 90 01 00 	mov    0x19000(%rdx),%rcx
afs_eq_req_exist():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:95 (discriminator 1)
    2ea7:	48 83 f9 02          	cmp    $0x2,%rcx
    2eab:	75 c9                	jne    2e76 <afs_eq_req_exist+0x46>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:96
            ret = true;
    2ead:	ba 01 00 00 00       	mov    $0x1,%edx
    2eb2:	eb 02                	jmp    2eb6 <afs_eq_req_exist+0x86>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:84
    bool ret = false;
    2eb4:	31 d2                	xor    %edx,%edx
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
    2eb6:	4c 89 ef             	mov    %r13,%rdi
    2eb9:	ff 14 25 00 00 00 00 	callq  *0x0
			2ebc: R_X86_64_32S	pv_lock_ops+0x8
afs_eq_req_exist():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:103
}
    2ec0:	48 83 c4 08          	add    $0x8,%rsp
    2ec4:	89 d0                	mov    %edx,%eax
    2ec6:	5b                   	pop    %rbx
    2ec7:	41 5c                	pop    %r12
    2ec9:	41 5d                	pop    %r13
    2ecb:	5d                   	pop    %rbp
    2ecc:	c3                   	retq   
    2ecd:	0f 1f 00             	nopl   (%rax)

0000000000002ed0 <afs_read_request>:
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:376
/**
 * Map a read request from userspace.
 */
int
afs_read_request(struct afs_map_request *req, struct bio *bio)
{
    2ed0:	e8 00 00 00 00       	callq  2ed5 <afs_read_request+0x5>
			2ed1: R_X86_64_PC32	__fentry__-0x4
    2ed5:	55                   	push   %rbp
    2ed6:	48 89 e5             	mov    %rsp,%rbp
    2ed9:	41 57                	push   %r15
    2edb:	41 56                	push   %r14
    2edd:	41 55                	push   %r13
    2edf:	41 54                	push   %r12
    2ee1:	53                   	push   %rbx
    2ee2:	48 83 ec 38          	sub    $0x38,%rsp
/home/austen/programming/dm-afs/src/dm_afs_engine.c:383
    struct bvec_iter iter;
    uint8_t *bio_data = NULL;
    uint32_t segment_offset;
    int ret;

    req->block = (bio->bi_iter.bi_sector * AFS_SECTOR_SIZE) / AFS_BLOCK_SIZE;
    2ee6:	48 8b 46 28          	mov    0x28(%rsi),%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:376
{
    2eea:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:383
    req->block = (bio->bi_iter.bi_sector * AFS_SECTOR_SIZE) / AFS_BLOCK_SIZE;
    2eee:	48 c1 e0 09          	shl    $0x9,%rax
    2ef2:	48 c1 e8 0c          	shr    $0xc,%rax
    2ef6:	89 87 58 90 01 00    	mov    %eax,0x19058(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:384
    req->sector_offset = bio->bi_iter.bi_sector % (AFS_BLOCK_SIZE / AFS_SECTOR_SIZE);
    2efc:	48 8b 5e 28          	mov    0x28(%rsi),%rbx
    2f00:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
    2f04:	8b 55 c8             	mov    -0x38(%rbp),%edx
    2f07:	83 e2 07             	and    $0x7,%edx
    2f0a:	89 97 60 90 01 00    	mov    %edx,0x19060(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:385
    req->request_size = bio_sectors(bio) * AFS_SECTOR_SIZE;
    2f10:	8b 5e 30             	mov    0x30(%rsi),%ebx
    2f13:	89 d9                	mov    %ebx,%ecx
    2f15:	89 5d c8             	mov    %ebx,-0x38(%rbp)
    2f18:	81 e1 00 fe ff ff    	and    $0xfffffe00,%ecx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:386
    afs_action(req->request_size <= AFS_BLOCK_SIZE, ret = -EINVAL, done, "cannot handle requested size [%u]", req->request_size);
    2f1e:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:385
    req->request_size = bio_sectors(bio) * AFS_SECTOR_SIZE;
    2f24:	89 8f 5c 90 01 00    	mov    %ecx,0x1905c(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:386
    afs_action(req->request_size <= AFS_BLOCK_SIZE, ret = -EINVAL, done, "cannot handle requested size [%u]", req->request_size);
    2f2a:	0f 87 67 05 00 00    	ja     3497 <afs_read_request+0x5c7>
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:333
    config = req->config;
    2f30:	4c 8b bf 20 90 01 00 	mov    0x19020(%rdi),%r15
    2f37:	49 89 fc             	mov    %rdi,%r12
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    2f3a:	41 0f b6 57 02       	movzbl 0x2(%r15),%edx
    2f3f:	0f af c2             	imul   %edx,%eax
    2f42:	48 03 87 10 90 01 00 	add    0x19010(%rdi),%rax
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:343
    if (map_entry_tuple[0].carrier_block_ptr == AFS_INVALID_BLOCK) {
    2f49:	83 38 ff             	cmpl   $0xffffffff,(%rax)
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    2f4c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:343
    if (map_entry_tuple[0].carrier_block_ptr == AFS_INVALID_BLOCK) {
    2f50:	0f 84 b2 03 00 00    	je     3308 <afs_read_request+0x438>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:340
    map_entry_hash = map_entry + (config->num_carrier_blocks * sizeof(*map_entry_tuple));
    2f56:	41 0f b6 3f          	movzbl (%r15),%edi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    2f5a:	be c0 00 40 01       	mov    $0x14000c0,%esi
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:348
        req->carrier_blocks = kmalloc(sizeof(uint8_t*)*config->num_carrier_blocks, GFP_KERNEL);
    2f5f:	48 c1 e7 03          	shl    $0x3,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    2f63:	e8 00 00 00 00       	callq  2f68 <afs_read_request+0x98>
			2f64: R_X86_64_PC32	__kmalloc-0x4
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:348
    2f68:	49 89 84 24 50 90 01 	mov    %rax,0x19050(%r12)
    2f6f:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:349
        req->block_nums = kmalloc(sizeof(uint32_t) * config->num_carrier_blocks, GFP_KERNEL);
    2f70:	41 0f b6 3f          	movzbl (%r15),%edi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    2f74:	be c0 00 40 01       	mov    $0x14000c0,%esi
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:349
    2f79:	48 c1 e7 02          	shl    $0x2,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    2f7d:	e8 00 00 00 00       	callq  2f82 <afs_read_request+0xb2>
			2f7e: R_X86_64_PC32	__kmalloc-0x4
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:349
    2f82:	49 89 84 24 68 90 01 	mov    %rax,0x19068(%r12)
    2f89:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:353
        arraytopointer(req->read_blocks, config->num_carrier_blocks, req->carrier_blocks);
    2f8a:	41 0f b6 1f          	movzbl (%r15),%ebx
    2f8e:	49 8d 84 24 00 80 00 	lea    0x8000(%r12),%rax
    2f95:	00 
    2f96:	49 8b 94 24 50 90 01 	mov    0x19050(%r12),%rdx
    2f9d:	00 
arraytopointer():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:27
    for(i = 0; i < size; i++){
    2f9e:	84 db                	test   %bl,%bl
    2fa0:	0f 84 3b 04 00 00    	je     33e1 <afs_read_request+0x511>
    2fa6:	8d 4b ff             	lea    -0x1(%rbx),%ecx
    2fa9:	48 c1 e1 0c          	shl    $0xc,%rcx
    2fad:	49 8d 8c 0c 00 90 00 	lea    0x9000(%r12,%rcx,1),%rcx
    2fb4:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:28
        output[i] = array[i];
    2fb5:	48 89 02             	mov    %rax,(%rdx)
    2fb8:	48 05 00 10 00 00    	add    $0x1000,%rax
    2fbe:	48 83 c2 08          	add    $0x8,%rdx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:27
    for(i = 0; i < size; i++){
    2fc2:	48 39 c1             	cmp    %rax,%rcx
    2fc5:	75 ee                	jne    2fb5 <afs_read_request+0xe5>
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:355
        for (i = 0; i < config->num_carrier_blocks; i++) {
    2fc7:	41 80 3f 00          	cmpb   $0x0,(%r15)
    2fcb:	0f 84 7c 03 00 00    	je     334d <afs_read_request+0x47d>
    2fd1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    2fd5:	31 c0                	xor    %eax,%eax
    2fd7:	45 31 f6             	xor    %r14d,%r14d
/home/austen/programming/dm-afs/src/dm_afs_engine.c:356
            req->block_nums[i] = map_entry_tuple[i].carrier_block_ptr;
    2fda:	8b 32                	mov    (%rdx),%esi
    2fdc:	49 8b 8c 24 68 90 01 	mov    0x19068(%r12),%rcx
    2fe3:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:355
        for (i = 0; i < config->num_carrier_blocks; i++) {
    2fe4:	41 83 c6 01          	add    $0x1,%r14d
    2fe8:	48 83 c2 0a          	add    $0xa,%rdx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:356
            req->block_nums[i] = map_entry_tuple[i].carrier_block_ptr;
    2fec:	89 34 01             	mov    %esi,(%rcx,%rax,1)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:355
        for (i = 0; i < config->num_carrier_blocks; i++) {
    2fef:	45 0f b6 2f          	movzbl (%r15),%r13d
    2ff3:	48 83 c0 04          	add    $0x4,%rax
    2ff7:	45 39 ee             	cmp    %r13d,%r14d
    2ffa:	44 89 eb             	mov    %r13d,%ebx
    2ffd:	7c db                	jl     2fda <afs_read_request+0x10a>
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    2fff:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3006 <afs_read_request+0x136>
			3002: R_X86_64_PC32	kmalloc_caches+0x1c
    3006:	ba 10 00 00 00       	mov    $0x10,%edx
    300b:	be c0 00 40 01       	mov    $0x14000c0,%esi
    3010:	e8 00 00 00 00       	callq  3015 <afs_read_request+0x145>
			3011: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:244
    bio = kmalloc(sizeof(struct bio *) * num_pages, GFP_KERNEL);
    3015:	0f b6 fb             	movzbl %bl,%edi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3018:	be c0 00 40 01       	mov    $0x14000c0,%esi
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    301d:	49 89 c7             	mov    %rax,%r15
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:244
    3020:	48 c1 e7 03          	shl    $0x3,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    3024:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3028:	e8 00 00 00 00       	callq  302d <afs_read_request+0x15d>
			3029: R_X86_64_PC32	__kmalloc-0x4
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:247
    for(i = 0; i < num_pages; i++){
    302d:	45 85 ed             	test   %r13d,%r13d
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3030:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
    3034:	45 89 6f 08          	mov    %r13d,0x8(%r15)
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:246
    completion->req = req;
    3038:	4d 89 27             	mov    %r12,(%r15)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:247
    for(i = 0; i < num_pages; i++){
    303b:	0f 84 3f 03 00 00    	je     3380 <afs_read_request+0x4b0>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:266
        bio[i]->bi_end_io = afs_read_endio;
    3041:	44 89 75 a8          	mov    %r14d,-0x58(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:247
    for(i = 0; i < num_pages; i++){
    3045:	31 db                	xor    %ebx,%ebx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:266
        bio[i]->bi_end_io = afs_read_endio;
    3047:	45 89 ee             	mov    %r13d,%r14d
    304a:	e9 e6 00 00 00       	jmpq   3135 <afs_read_request+0x265>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:254
        afs_action(!((uint64_t)req->carrier_blocks[i] & (AFS_BLOCK_SIZE - 1)), ret = -EINVAL, done, "page is not aligned [%d]", ret);
    304f:	49 8b 94 24 50 90 01 	mov    0x19050(%r12),%rdx
    3056:	00 
    3057:	4a 8b 14 ea          	mov    (%rdx,%r13,8),%rdx
    305b:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
    3061:	0f 85 91 03 00 00    	jne    33f8 <afs_read_request+0x528>
    3067:	b9 00 00 00 80       	mov    $0x80000000,%ecx
    306c:	48 01 ca             	add    %rcx,%rdx
    306f:	0f 82 77 03 00 00    	jb     33ec <afs_read_request+0x51c>
__phys_addr_nodebug():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19
    3075:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
    307c:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 3083 <afs_read_request+0x1b3>
			307f: R_X86_64_PC32	page_offset_base-0x4
    3083:	48 01 d6             	add    %rdx,%rsi
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:258
        sector_num = ((req->block_nums[i] * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE) + req->fs->data_start_off;
    3086:	49 8b 94 24 68 90 01 	mov    0x19068(%r12),%rdx
    308d:	00 
    308e:	49 8b 8c 24 28 90 01 	mov    0x19028(%r12),%rcx
    3095:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:257
        page_structure = (used_vmalloc) ? vmalloc_to_page(req->carrier_blocks[i]) : virt_to_page(req->carrier_blocks[i]);
    3096:	48 c1 ee 0c          	shr    $0xc,%rsi
    309a:	48 c1 e6 06          	shl    $0x6,%rsi
    309e:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 30a5 <afs_read_request+0x1d5>
			30a1: R_X86_64_PC32	vmemmap_base-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:258
        sector_num = ((req->block_nums[i] * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE) + req->fs->data_start_off;
    30a5:	42 8b 14 aa          	mov    (%rdx,%r13,4),%edx
    30a9:	c1 e2 0c             	shl    $0xc,%edx
    30ac:	c1 ea 09             	shr    $0x9,%edx
    30af:	03 51 14             	add    0x14(%rcx),%edx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:261
        bio_set_dev(bio[i], req->bdev);
    30b2:	49 8b 8c 24 18 90 01 	mov    0x19018(%r12),%rcx
    30b9:	00 
    30ba:	48 8b 89 80 00 00 00 	mov    0x80(%rcx),%rcx
    30c1:	48 39 48 08          	cmp    %rcx,0x8(%rax)
    30c5:	74 18                	je     30df <afs_read_request+0x20f>
bio_clear_flag():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:273
    30c7:	66 81 60 14 ff fd    	andw   $0xfdff,0x14(%rax)
    30cd:	49 8b 8c 24 18 90 01 	mov    0x19018(%r12),%rcx
    30d4:	00 
    30d5:	49 8b 07             	mov    (%r15),%rax
    30d8:	48 8b 89 80 00 00 00 	mov    0x80(%rcx),%rcx
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:261
    30df:	48 89 48 08          	mov    %rcx,0x8(%rax)
    30e3:	49 8b 8c 24 18 90 01 	mov    0x19018(%r12),%rcx
    30ea:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:247
    for(i = 0; i < num_pages; i++){
    30eb:	83 c3 01             	add    $0x1,%ebx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:261
        bio_set_dev(bio[i], req->bdev);
    30ee:	49 8b 07             	mov    (%r15),%rax
    30f1:	0f b6 49 6c          	movzbl 0x6c(%rcx),%ecx
    30f5:	88 48 1b             	mov    %cl,0x1b(%rax)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:262
        bio[i]->bi_iter.bi_sector = sector_num;
    30f8:	49 8b 07             	mov    (%r15),%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:263
        bio_add_page(bio[i], page_structure, AFS_BLOCK_SIZE, page_offset);
    30fb:	31 c9                	xor    %ecx,%ecx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:262
        bio[i]->bi_iter.bi_sector = sector_num;
    30fd:	48 89 50 28          	mov    %rdx,0x28(%rax)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:263
        bio_add_page(bio[i], page_structure, AFS_BLOCK_SIZE, page_offset);
    3101:	49 8b 3f             	mov    (%r15),%rdi
    3104:	ba 00 10 00 00       	mov    $0x1000,%edx
    3109:	e8 00 00 00 00       	callq  310e <afs_read_request+0x23e>
			310a: R_X86_64_PC32	bio_add_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:265
        bio[i]->bi_private = completion;
    310e:	49 8b 07             	mov    (%r15),%rax
    3111:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    3115:	48 89 48 50          	mov    %rcx,0x50(%rax)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:266
        bio[i]->bi_end_io = afs_read_endio;
    3119:	49 8b 07             	mov    (%r15),%rax
    311c:	48 c7 40 48 00 00 00 	movq   $0x0,0x48(%rax)
    3123:	00 
			3120: R_X86_64_32S	.text+0x2a60
/home/austen/programming/dm-afs/src/dm_afs_engine.c:267
        generic_make_request(bio[i]);
    3124:	49 8b 3f             	mov    (%r15),%rdi
    3127:	e8 00 00 00 00       	callq  312c <afs_read_request+0x25c>
			3128: R_X86_64_PC32	generic_make_request-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:247
    for(i = 0; i < num_pages; i++){
    312c:	44 39 f3             	cmp    %r14d,%ebx
    312f:	0f 84 4b 02 00 00    	je     3380 <afs_read_request+0x4b0>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:250
        bio[i] = bio_alloc(GFP_NOIO, 1);
    3135:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    3139:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 3140 <afs_read_request+0x270>
			313c: R_X86_64_PC32	fs_bio_set-0x4
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:250
    3140:	4c 63 eb             	movslq %ebx,%r13
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    3143:	be 01 00 00 00       	mov    $0x1,%esi
    3148:	bf 00 00 40 01       	mov    $0x1400000,%edi
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:250
    314d:	4e 8d 3c e8          	lea    (%rax,%r13,8),%r15
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    3151:	e8 00 00 00 00       	callq  3156 <afs_read_request+0x286>
			3152: R_X86_64_PC32	bio_alloc_bioset-0x4
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:251
        afs_action(!IS_ERR(bio[i]), ret = PTR_ERR(bio[i]), done, "could not allocate bio [%d]", ret);
    3156:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:250
        bio[i] = bio_alloc(GFP_NOIO, 1);
    315c:	49 89 07             	mov    %rax,(%r15)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:251
        afs_action(!IS_ERR(bio[i]), ret = PTR_ERR(bio[i]), done, "could not allocate bio [%d]", ret);
    315f:	0f 86 ea fe ff ff    	jbe    304f <afs_read_request+0x17f>
    3165:	89 c1                	mov    %eax,%ecx
    3167:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    316b:	ba fb 00 00 00       	mov    $0xfb,%edx
    3170:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3173: R_X86_64_32S	.rodata+0x1b8
    3177:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			317a: R_X86_64_32S	.rodata.str1.8+0x13f8
    317e:	31 c0                	xor    %eax,%eax
    3180:	44 8b 75 a8          	mov    -0x58(%rbp),%r14d
    3184:	e8 00 00 00 00       	callq  3189 <afs_read_request+0x2b9>
			3185: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:271
    kfree(bio);
    3189:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    318d:	e8 00 00 00 00       	callq  3192 <afs_read_request+0x2c2>
			318e: R_X86_64_PC32	kfree-0x4
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:359
        afs_action(!ret, ret = -EIO, done, "could not read page at block [%u]", map_entry_tuple[i].carrier_block_ptr);
    3192:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    3196:	45 85 d2             	test   %r10d,%r10d
    3199:	0f 85 85 02 00 00    	jne    3424 <afs_read_request+0x554>
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188
    319f:	41 8b 84 24 70 90 01 	mov    0x19070(%r12),%eax
    31a6:	00 
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:394
    // Read the raw block.
    ret = __afs_read_block(req);
    afs_assert(!ret, done, "could not read data block [%d:%u]", ret, req->block);

    // Copy back into the segments.
    if(atomic_read(&req->pending) == 2){
    31a7:	83 f8 02             	cmp    $0x2,%eax
    31aa:	74 11                	je     31bd <afs_read_request+0x2ed>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:390
    ret = __afs_read_block(req);
    31ac:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:413
        ret = 0;
    }

done:
    return ret;
}
    31ae:	48 83 c4 38          	add    $0x38,%rsp
    31b2:	5b                   	pop    %rbx
    31b3:	41 5c                	pop    %r12
    31b5:	41 5d                	pop    %r13
    31b7:	41 5e                	pop    %r14
    31b9:	41 5f                	pop    %r15
    31bb:	5d                   	pop    %rbp
    31bc:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_engine.c:396
        bio_for_each_segment (bv, bio, iter) {
    31bd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:395
        segment_offset = 0;
    31c1:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
    31c8:	4d 89 e5             	mov    %r12,%r13
/home/austen/programming/dm-afs/src/dm_afs_engine.c:396
        bio_for_each_segment (bv, bio, iter) {
    31cb:	44 8b 78 3c          	mov    0x3c(%rax),%r15d
    31cf:	44 8b 70 30          	mov    0x30(%rax),%r14d
    31d3:	8b 78 34             	mov    0x34(%rax),%edi
    31d6:	49 8d 84 24 00 80 01 	lea    0x18000(%r12),%rax
    31dd:	00 
    31de:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    31e2:	44 89 f8             	mov    %r15d,%eax
    31e5:	45 89 f7             	mov    %r14d,%r15d
    31e8:	89 7d c8             	mov    %edi,-0x38(%rbp)
    31eb:	41 89 c6             	mov    %eax,%r14d
/home/austen/programming/dm-afs/src/dm_afs_engine.c:396 (discriminator 1)
    31ee:	45 85 ff             	test   %r15d,%r15d
    31f1:	74 b9                	je     31ac <afs_read_request+0x2dc>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:396 (discriminator 3)
    31f3:	44 8b 55 c8          	mov    -0x38(%rbp),%r10d
    31f7:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    31fb:	45 89 f4             	mov    %r14d,%r12d
    31fe:	4c 89 d0             	mov    %r10,%rax
    3201:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    3205:	48 c1 e0 04          	shl    $0x4,%rax
    3209:	48 03 47 78          	add    0x78(%rdi),%rax
    320d:	8b 58 08             	mov    0x8(%rax),%ebx
    3210:	48 8b 38             	mov    (%rax),%rdi
    3213:	44 29 f3             	sub    %r14d,%ebx
    3216:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
    321a:	44 39 fb             	cmp    %r15d,%ebx
    321d:	41 0f 47 df          	cmova  %r15d,%ebx
    3221:	44 03 60 0c          	add    0xc(%rax),%r12d
kmap():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/highmem.h:59 (discriminator 3)
    3225:	e8 00 00 00 00       	callq  322a <afs_read_request+0x35a>
			3226: R_X86_64_PC32	_cond_resched-0x4
lowmem_page_address():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/mm.h:1087 (discriminator 3)
    322a:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    322e:	48 2b 3d 00 00 00 00 	sub    0x0(%rip),%rdi        # 3235 <afs_read_request+0x365>
			3231: R_X86_64_PC32	vmemmap_base-0x4
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:398 (discriminator 3)
            if (bv.bv_len <= (req->request_size - segment_offset)) {
    3235:	8b 45 b8             	mov    -0x48(%rbp),%eax
    3238:	41 8b 95 5c 90 01 00 	mov    0x1905c(%r13),%edx
    323f:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
lowmem_page_address():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/mm.h:1087 (discriminator 3)
    3243:	48 c1 ff 06          	sar    $0x6,%rdi
    3247:	48 c1 e7 0c          	shl    $0xc,%rdi
    324b:	48 03 3d 00 00 00 00 	add    0x0(%rip),%rdi        # 3252 <afs_read_request+0x382>
			324e: R_X86_64_PC32	page_offset_base-0x4
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:398 (discriminator 3)
    3252:	29 c2                	sub    %eax,%edx
    3254:	4c 01 e7             	add    %r12,%rdi
    3257:	39 da                	cmp    %ebx,%edx
    3259:	0f 82 2f 01 00 00    	jb     338e <afs_read_request+0x4be>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:399
                memcpy(bio_data + bv.bv_offset, req->data_block + (req->sector_offset * AFS_SECTOR_SIZE) + segment_offset, bv.bv_len);
    325f:	41 8b b5 60 90 01 00 	mov    0x19060(%r13),%esi
    3266:	89 da                	mov    %ebx,%edx
    3268:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    326c:	c1 e6 09             	shl    $0x9,%esi
    326f:	48 01 c6             	add    %rax,%rsi
    3272:	48 03 75 a0          	add    -0x60(%rbp),%rsi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    3276:	e8 00 00 00 00       	callq  327b <afs_read_request+0x3ab>
			3277: R_X86_64_PC32	memcpy-0x4
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:169
    327b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:405
            segment_offset += bv.bv_len;
    327f:	01 5d b8             	add    %ebx,-0x48(%rbp)
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:169
    3282:	8b 50 10             	mov    0x10(%rax),%edx
bio_no_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:96
    3285:	0f b6 c2             	movzbl %dl,%eax
    3288:	83 e8 05             	sub    $0x5,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:98
    328b:	83 e0 fb             	and    $0xfffffffb,%eax
    328e:	74 0f                	je     329f <afs_read_request+0x3cf>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:96
    3290:	81 e2 fb 00 00 00    	and    $0xfb,%edx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:98
    3296:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    329a:	83 fa 03             	cmp    $0x3,%edx
    329d:	75 11                	jne    32b0 <afs_read_request+0x3e0>
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:170
    329f:	41 29 df             	sub    %ebx,%r15d
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:396
        bio_for_each_segment (bv, bio, iter) {
    32a2:	45 85 ff             	test   %r15d,%r15d
    32a5:	0f 85 48 ff ff ff    	jne    31f3 <afs_read_request+0x323>
    32ab:	e9 fc fe ff ff       	jmpq   31ac <afs_read_request+0x2dc>
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:75
    32b0:	44 39 fb             	cmp    %r15d,%ebx
    32b3:	0f 87 ff 00 00 00    	ja     33b8 <afs_read_request+0x4e8>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:81
    32b9:	85 db                	test   %ebx,%ebx
    32bb:	0f 84 2d ff ff ff    	je     31ee <afs_read_request+0x31e>
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:173
    32c1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    32c5:	48 8b 78 78          	mov    0x78(%rax),%rdi
    32c9:	eb 04                	jmp    32cf <afs_read_request+0x3ff>
    32cb:	44 8b 55 c8          	mov    -0x38(%rbp),%r10d
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:82
    32cf:	49 c1 e2 04          	shl    $0x4,%r10
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:83
    32d3:	44 89 f8             	mov    %r15d,%eax
    32d6:	44 39 fb             	cmp    %r15d,%ebx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:82
    32d9:	42 8b 54 17 08       	mov    0x8(%rdi,%r10,1),%edx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:83
    32de:	0f 46 c3             	cmovbe %ebx,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:82
    32e1:	89 d6                	mov    %edx,%esi
    32e3:	44 29 f6             	sub    %r14d,%esi
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:83
    32e6:	39 f0                	cmp    %esi,%eax
    32e8:	0f 47 c6             	cmova  %esi,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:87
    32eb:	41 01 c6             	add    %eax,%r14d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:85
    32ee:	29 c3                	sub    %eax,%ebx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:86
    32f0:	41 29 c7             	sub    %eax,%r15d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:90
    32f3:	44 39 f2             	cmp    %r14d,%edx
    32f6:	75 07                	jne    32ff <afs_read_request+0x42f>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:92
    32f8:	83 45 c8 01          	addl   $0x1,-0x38(%rbp)
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:91
    32fc:	45 31 f6             	xor    %r14d,%r14d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:81
    32ff:	85 db                	test   %ebx,%ebx
    3301:	75 c8                	jne    32cb <afs_read_request+0x3fb>
    3303:	e9 e6 fe ff ff       	jmpq   31ee <afs_read_request+0x31e>
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    3308:	48 c7 87 00 80 01 00 	movq   $0x0,0x18000(%rdi)
    330f:	00 00 00 00 
    3313:	48 c7 87 f8 8f 01 00 	movq   $0x0,0x18ff8(%rdi)
    331a:	00 00 00 00 
    331e:	48 8d bf 08 80 01 00 	lea    0x18008(%rdi),%rdi
    3325:	44 89 e0             	mov    %r12d,%eax
    3328:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    332c:	29 f8                	sub    %edi,%eax
    332e:	8d 88 00 90 01 00    	lea    0x19000(%rax),%ecx
    3334:	31 c0                	xor    %eax,%eax
    3336:	c1 e9 03             	shr    $0x3,%ecx
    3339:	f3 48 ab             	rep stos %rax,%es:(%rdi)
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
    333c:	41 c7 84 24 70 90 01 	movl   $0x2,0x19070(%r12)
    3343:	00 02 00 00 00 
    3348:	e9 52 fe ff ff       	jmpq   319f <afs_read_request+0x2cf>
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    334d:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 3354 <afs_read_request+0x484>
			3350: R_X86_64_PC32	kmalloc_caches+0x1c
    3354:	ba 10 00 00 00       	mov    $0x10,%edx
    3359:	be c0 00 40 01       	mov    $0x14000c0,%esi
    335e:	e8 00 00 00 00       	callq  3363 <afs_read_request+0x493>
			335f: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3363:	be c0 00 40 01       	mov    $0x14000c0,%esi
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    3368:	48 89 c3             	mov    %rax,%rbx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    336b:	31 ff                	xor    %edi,%edi
    336d:	e8 00 00 00 00       	callq  3372 <afs_read_request+0x4a2>
			336e: R_X86_64_PC32	__kmalloc-0x4
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
    3372:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%rbx)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3379:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:246
    completion->req = req;
    337d:	4c 89 23             	mov    %r12,(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:271
    kfree(bio);
    3380:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    3384:	e8 00 00 00 00       	callq  3389 <afs_read_request+0x4b9>
			3385: R_X86_64_PC32	kfree-0x4
    3389:	e9 11 fe ff ff       	jmpq   319f <afs_read_request+0x2cf>
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:401
                memcpy(bio_data + bv.bv_offset, req->data_block + (req->sector_offset * AFS_SECTOR_SIZE) + segment_offset, req->request_size - segment_offset);
    338e:	41 8b b5 60 90 01 00 	mov    0x19060(%r13),%esi
    3395:	c1 e6 09             	shl    $0x9,%esi
    3398:	48 01 f0             	add    %rsi,%rax
    339b:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
    339f:	48 01 c6             	add    %rax,%rsi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    33a2:	e8 00 00 00 00       	callq  33a7 <afs_read_request+0x4d7>
			33a3: R_X86_64_PC32	memcpy-0x4
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:413
}
    33a7:	48 83 c4 38          	add    $0x38,%rsp
/home/austen/programming/dm-afs/src/dm_afs_engine.c:408
        ret = 0;
    33ab:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:413
}
    33ad:	5b                   	pop    %rbx
    33ae:	41 5c                	pop    %r12
    33b0:	41 5d                	pop    %r13
    33b2:	41 5e                	pop    %r14
    33b4:	41 5f                	pop    %r15
    33b6:	5d                   	pop    %rbp
    33b7:	c3                   	retq   
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:75
    33b8:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 33bf <afs_read_request+0x4ef>
			33ba: R_X86_64_PC32	.data.once-0x5
    33bf:	0f 85 e7 fd ff ff    	jne    31ac <afs_read_request+0x2dc>
    33c5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			33c8: R_X86_64_32S	.rodata.str1.8+0x1388
    33cc:	31 c0                	xor    %eax,%eax
    33ce:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 33d5 <afs_read_request+0x505>
			33d0: R_X86_64_PC32	.data.once-0x5
    33d5:	e8 00 00 00 00       	callq  33da <afs_read_request+0x50a>
			33d6: R_X86_64_PC32	__warn_printk-0x4
    33da:	0f 0b                	ud2    
    33dc:	e9 cb fd ff ff       	jmpq   31ac <afs_read_request+0x2dc>
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:355
        for (i = 0; i < config->num_carrier_blocks; i++) {
    33e1:	45 31 f6             	xor    %r14d,%r14d
    33e4:	45 31 ed             	xor    %r13d,%r13d
    33e7:	e9 13 fc ff ff       	jmpq   2fff <afs_read_request+0x12f>
__phys_addr_nodebug():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19
    33ec:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 33f3 <afs_read_request+0x523>
			33ef: R_X86_64_PC32	phys_base-0x4
    33f3:	e9 8b fc ff ff       	jmpq   3083 <afs_read_request+0x1b3>
read_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:254
        afs_action(!((uint64_t)req->carrier_blocks[i] & (AFS_BLOCK_SIZE - 1)), ret = -EINVAL, done, "page is not aligned [%d]", ret);
    33f8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			33fb: R_X86_64_32S	.rodata.str1.8+0x1430
    33ff:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
    3404:	ba fe 00 00 00       	mov    $0xfe,%edx
    3409:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			340c: R_X86_64_32S	.rodata+0x1b8
    3410:	31 c0                	xor    %eax,%eax
    3412:	44 8b 75 a8          	mov    -0x58(%rbp),%r14d
    3416:	e8 00 00 00 00       	callq  341b <afs_read_request+0x54b>
			3417: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:271
    kfree(bio);
    341b:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    341f:	e8 00 00 00 00       	callq  3424 <afs_read_request+0x554>
			3420: R_X86_64_PC32	kfree-0x4
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:359
        afs_action(!ret, ret = -EIO, done, "could not read page at block [%u]", map_entry_tuple[i].carrier_block_ptr);
    3424:	49 63 c6             	movslq %r14d,%rax
    3427:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    342b:	ba 67 01 00 00       	mov    $0x167,%edx
    3430:	48 6b c0 0a          	imul   $0xa,%rax,%rax
    3434:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3437: R_X86_64_32S	.rodata+0x1d0
    343b:	8b 0c 07             	mov    (%rdi,%rax,1),%ecx
    343e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3441: R_X86_64_32S	.rodata.str1.8+0x1468
    3445:	31 c0                	xor    %eax,%eax
    3447:	e8 00 00 00 00       	callq  344c <afs_read_request+0x57c>
			3448: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:365
    kfree(req->carrier_blocks);
    344c:	49 8b bc 24 50 90 01 	mov    0x19050(%r12),%rdi
    3453:	00 
    3454:	e8 00 00 00 00       	callq  3459 <afs_read_request+0x589>
			3455: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:366
    kfree(req->block_nums);
    3459:	49 8b bc 24 68 90 01 	mov    0x19068(%r12),%rdi
    3460:	00 
    3461:	e8 00 00 00 00       	callq  3466 <afs_read_request+0x596>
			3462: R_X86_64_PC32	kfree-0x4
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:391
    afs_assert(!ret, done, "could not read data block [%d:%u]", ret, req->block);
    3466:	45 8b 84 24 58 90 01 	mov    0x19058(%r12),%r8d
    346d:	00 
    346e:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
    3473:	ba 87 01 00 00       	mov    $0x187,%edx
    3478:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			347b: R_X86_64_32S	.rodata+0x1f0
    347f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3482: R_X86_64_32S	.rodata.str1.8+0x14a8
    3486:	31 c0                	xor    %eax,%eax
    3488:	e8 00 00 00 00       	callq  348d <afs_read_request+0x5bd>
			3489: R_X86_64_PC32	printk-0x4
__afs_read_block():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:368
    return ret;
    348d:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
afs_read_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:391
    afs_assert(!ret, done, "could not read data block [%d:%u]", ret, req->block);
    3492:	e9 17 fd ff ff       	jmpq   31ae <afs_read_request+0x2de>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:386 (discriminator 1)
    afs_action(req->request_size <= AFS_BLOCK_SIZE, ret = -EINVAL, done, "cannot handle requested size [%u]", req->request_size);
    3497:	ba 82 01 00 00       	mov    $0x182,%edx
    349c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			349f: R_X86_64_32S	.rodata+0x1f0
    34a3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			34a6: R_X86_64_32S	.rodata.str1.8+0x13b8
    34aa:	31 c0                	xor    %eax,%eax
    34ac:	e8 00 00 00 00       	callq  34b1 <afs_read_request+0x5e1>
			34ad: R_X86_64_PC32	printk-0x4
    34b1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    34b6:	e9 f3 fc ff ff       	jmpq   31ae <afs_read_request+0x2de>
    34bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000034c0 <afs_write_request>:
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:420
/**
 * Map a write request from userspace.
 */
int
afs_write_request(struct afs_map_request *req, struct bio *bio)
{
    34c0:	e8 00 00 00 00       	callq  34c5 <afs_write_request+0x5>
			34c1: R_X86_64_PC32	__fentry__-0x4
    34c5:	55                   	push   %rbp
    34c6:	48 89 e5             	mov    %rsp,%rbp
    34c9:	41 57                	push   %r15
    34cb:	41 56                	push   %r14
    34cd:	41 55                	push   %r13
    34cf:	41 54                	push   %r12
    34d1:	49 89 fc             	mov    %rdi,%r12
    34d4:	53                   	push   %rbx
    34d5:	48 83 ec 58          	sub    $0x58,%rsp
/home/austen/programming/dm-afs/src/dm_afs_engine.c:434
    uint32_t block_num;
    uint32_t segment_offset;
    bool modification = false;
    int ret = 0, i;

    config = req->config;
    34d9:	48 8b 87 20 90 01 00 	mov    0x19020(%rdi),%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:420
{
    34e0:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:434
    config = req->config;
    34e4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:435
    req->block = (bio->bi_iter.bi_sector * AFS_SECTOR_SIZE) / AFS_BLOCK_SIZE;
    34e8:	48 8b 46 28          	mov    0x28(%rsi),%rax
    34ec:	48 c1 e0 09          	shl    $0x9,%rax
    34f0:	48 c1 e8 0c          	shr    $0xc,%rax
    34f4:	89 87 58 90 01 00    	mov    %eax,0x19058(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:436
    req->sector_offset = bio->bi_iter.bi_sector % (AFS_BLOCK_SIZE / AFS_SECTOR_SIZE);
    34fa:	48 8b 7e 28          	mov    0x28(%rsi),%rdi
    34fe:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
    3502:	8b 55 c0             	mov    -0x40(%rbp),%edx
    3505:	83 e2 07             	and    $0x7,%edx
    3508:	41 89 94 24 60 90 01 	mov    %edx,0x19060(%r12)
    350f:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:437
    req->request_size = bio_sectors(bio) * AFS_SECTOR_SIZE;
    3510:	8b 7e 30             	mov    0x30(%rsi),%edi
    3513:	89 f9                	mov    %edi,%ecx
    3515:	89 7d c0             	mov    %edi,-0x40(%rbp)
    3518:	81 e1 00 fe ff ff    	and    $0xfffffe00,%ecx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:439
    
    afs_action(req->request_size <= AFS_BLOCK_SIZE, ret = -EINVAL, err, "cannot handle requested size [%u]", req->request_size);
    351e:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:437
    req->request_size = bio_sectors(bio) * AFS_SECTOR_SIZE;
    3524:	41 89 8c 24 5c 90 01 	mov    %ecx,0x1905c(%r12)
    352b:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:439
    afs_action(req->request_size <= AFS_BLOCK_SIZE, ret = -EINVAL, err, "cannot handle requested size [%u]", req->request_size);
    352c:	0f 87 24 06 00 00    	ja     3b56 <afs_write_request+0x696>
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    3532:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3536:	be c0 00 40 01       	mov    $0x14000c0,%esi
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    353b:	0f b6 53 02          	movzbl 0x2(%rbx),%edx
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:443

    map_entry = afs_get_map_entry(req->map, config, req->block);
    map_entry_tuple = (struct afs_map_tuple *)map_entry;
    map_entry_hash = map_entry + (config->num_carrier_blocks * sizeof(*map_entry_tuple));
    353f:	0f b6 3b             	movzbl (%rbx),%edi
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    3542:	0f af c2             	imul   %edx,%eax
    3545:	49 03 84 24 10 90 01 	add    0x19010(%r12),%rax
    354c:	00 
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:459

    if (map_entry_tuple[0].carrier_block_ptr != AFS_INVALID_BLOCK) {
        modification = true;
    }

    req->carrier_blocks = kmalloc(sizeof(uint8_t*) * config->num_carrier_blocks, GFP_KERNEL);
    354d:	48 c1 e7 03          	shl    $0x3,%rdi
afs_get_map_entry():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:112
    return map + (index * config->map_entry_sz);
    3551:	48 89 45 90          	mov    %rax,-0x70(%rbp)
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:455
    if (map_entry_tuple[0].carrier_block_ptr != AFS_INVALID_BLOCK) {
    3555:	8b 00                	mov    (%rax),%eax
    3557:	89 45 a8             	mov    %eax,-0x58(%rbp)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    355a:	e8 00 00 00 00       	callq  355f <afs_write_request+0x9f>
			355b: R_X86_64_PC32	__kmalloc-0x4
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:460
    afs_action(req->carrier_blocks, ret = -ENOMEM, err, "could not allocate carrier block array [%d]", ret);
    355f:	48 85 c0             	test   %rax,%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:459
    req->carrier_blocks = kmalloc(sizeof(uint8_t*) * config->num_carrier_blocks, GFP_KERNEL);
    3562:	49 89 84 24 50 90 01 	mov    %rax,0x19050(%r12)
    3569:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:460
    afs_action(req->carrier_blocks, ret = -ENOMEM, err, "could not allocate carrier block array [%d]", ret);
    356a:	0f 84 bf 05 00 00    	je     3b2f <afs_write_request+0x66f>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:461
    req->block_nums = kmalloc(sizeof(uint32_t) * config->num_carrier_blocks, GFP_KERNEL);
    3570:	48 8b 45 98          	mov    -0x68(%rbp),%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3574:	be c0 00 40 01       	mov    $0x14000c0,%esi
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:461
    3579:	0f b6 38             	movzbl (%rax),%edi
    357c:	48 c1 e7 02          	shl    $0x2,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3580:	e8 00 00 00 00       	callq  3585 <afs_write_request+0xc5>
			3581: R_X86_64_PC32	__kmalloc-0x4
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:462
    afs_action(req->block_nums, ret = -ENOMEM, block_err, "could not allocate block nums [%d]", ret);
    3585:	48 85 c0             	test   %rax,%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:461
    req->block_nums = kmalloc(sizeof(uint32_t) * config->num_carrier_blocks, GFP_KERNEL);
    3588:	49 89 84 24 68 90 01 	mov    %rax,0x19068(%r12)
    358f:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:462
    afs_action(req->block_nums, ret = -ENOMEM, block_err, "could not allocate block nums [%d]", ret);
    3590:	0f 84 72 05 00 00    	je     3b08 <afs_write_request+0x648>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:477
    // NOTE: ^This case is only true if the __clone_bio function
    // in dm_afs.c has override disabled. As of 3rd March 2019, the
    // override has been enabled due to massive lock contention.

    segment_offset = 0;
    bio_for_each_segment (bv, bio, iter) {
    3596:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:476
    segment_offset = 0;
    359a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
    35a1:	4d 89 e7             	mov    %r12,%r15
/home/austen/programming/dm-afs/src/dm_afs_engine.c:477
    bio_for_each_segment (bv, bio, iter) {
    35a4:	44 8b 70 3c          	mov    0x3c(%rax),%r14d
    35a8:	44 8b 68 30          	mov    0x30(%rax),%r13d
    35ac:	8b 78 34             	mov    0x34(%rax),%edi
    35af:	49 8d 84 24 00 80 01 	lea    0x18000(%r12),%rax
    35b6:	00 
    35b7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    35bb:	44 89 f0             	mov    %r14d,%eax
    35be:	45 89 ee             	mov    %r13d,%r14d
    35c1:	89 7d ac             	mov    %edi,-0x54(%rbp)
    35c4:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_engine.c:477 (discriminator 1)
    35c7:	45 85 f6             	test   %r14d,%r14d
    35ca:	0f 84 b8 00 00 00    	je     3688 <afs_write_request+0x1c8>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:477 (discriminator 3)
    35d0:	44 8b 55 ac          	mov    -0x54(%rbp),%r10d
    35d4:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    35d8:	45 89 ec             	mov    %r13d,%r12d
    35db:	4c 89 d0             	mov    %r10,%rax
    35de:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
    35e2:	48 c1 e0 04          	shl    $0x4,%rax
    35e6:	48 03 47 78          	add    0x78(%rdi),%rax
    35ea:	8b 58 08             	mov    0x8(%rax),%ebx
    35ed:	48 8b 30             	mov    (%rax),%rsi
    35f0:	44 29 eb             	sub    %r13d,%ebx
    35f3:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
    35f7:	44 39 f3             	cmp    %r14d,%ebx
    35fa:	41 0f 47 de          	cmova  %r14d,%ebx
    35fe:	44 03 60 0c          	add    0xc(%rax),%r12d
kmap():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/highmem.h:59 (discriminator 3)
    3602:	e8 00 00 00 00       	callq  3607 <afs_write_request+0x147>
			3603: R_X86_64_PC32	_cond_resched-0x4
lowmem_page_address():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/mm.h:1087 (discriminator 3)
    3607:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    360b:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 3612 <afs_write_request+0x152>
			360e: R_X86_64_PC32	vmemmap_base-0x4
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:479 (discriminator 3)
        bio_data = kmap(bv.bv_page);
        if (bv.bv_len <= (req->request_size - segment_offset)) {
    3612:	8b 45 c0             	mov    -0x40(%rbp),%eax
    3615:	41 8b 97 5c 90 01 00 	mov    0x1905c(%r15),%edx
    361c:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
lowmem_page_address():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/mm.h:1087 (discriminator 3)
    3620:	48 c1 fe 06          	sar    $0x6,%rsi
    3624:	48 c1 e6 0c          	shl    $0xc,%rsi
    3628:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 362f <afs_write_request+0x16f>
			362b: R_X86_64_PC32	page_offset_base-0x4
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:479 (discriminator 3)
    362f:	29 c2                	sub    %eax,%edx
    3631:	4c 01 e6             	add    %r12,%rsi
    3634:	39 da                	cmp    %ebx,%edx
    3636:	0f 82 ad 00 00 00    	jb     36e9 <afs_write_request+0x229>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:480
            memcpy(req->data_block + (req->sector_offset * AFS_SECTOR_SIZE) + segment_offset, bio_data + bv.bv_offset, bv.bv_len);
    363c:	41 8b bf 60 90 01 00 	mov    0x19060(%r15),%edi
    3643:	89 da                	mov    %ebx,%edx
    3645:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
    3649:	c1 e7 09             	shl    $0x9,%edi
    364c:	48 01 c7             	add    %rax,%rdi
    364f:	48 03 7d a0          	add    -0x60(%rbp),%rdi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    3653:	e8 00 00 00 00       	callq  3658 <afs_write_request+0x198>
			3654: R_X86_64_PC32	memcpy-0x4
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:169
    3658:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:486
        } else {
            memcpy(req->data_block + (req->sector_offset * AFS_SECTOR_SIZE) + segment_offset, bio_data + bv.bv_offset, req->request_size - segment_offset);
            kunmap(bv.bv_page);
            break;
        }
        segment_offset += bv.bv_len;
    365c:	01 5d c0             	add    %ebx,-0x40(%rbp)
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:169
    365f:	8b 50 10             	mov    0x10(%rax),%edx
bio_no_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:96
    3662:	0f b6 c2             	movzbl %dl,%eax
    3665:	83 e8 05             	sub    $0x5,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:98
    3668:	83 e0 fb             	and    $0xfffffffb,%eax
    366b:	74 0f                	je     367c <afs_write_request+0x1bc>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:96
    366d:	81 e2 fb 00 00 00    	and    $0xfb,%edx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:98
    3673:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    3677:	83 fa 03             	cmp    $0x3,%edx
    367a:	75 11                	jne    368d <afs_write_request+0x1cd>
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:170
    367c:	41 29 de             	sub    %ebx,%r14d
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:477
    bio_for_each_segment (bv, bio, iter) {
    367f:	45 85 f6             	test   %r14d,%r14d
    3682:	0f 85 48 ff ff ff    	jne    35d0 <afs_write_request+0x110>
    3688:	4d 89 fc             	mov    %r15,%r12
    368b:	eb 78                	jmp    3705 <afs_write_request+0x245>
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:75
    368d:	44 39 f3             	cmp    %r14d,%ebx
    3690:	0f 87 6c 03 00 00    	ja     3a02 <afs_write_request+0x542>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:81
    3696:	85 db                	test   %ebx,%ebx
    3698:	0f 84 29 ff ff ff    	je     35c7 <afs_write_request+0x107>
bio_advance_iter():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:173
    369e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    36a2:	8b 75 ac             	mov    -0x54(%rbp),%esi
    36a5:	48 8b 78 78          	mov    0x78(%rax),%rdi
    36a9:	eb 03                	jmp    36ae <afs_write_request+0x1ee>
    36ab:	41 89 f2             	mov    %esi,%r10d
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:82
    36ae:	49 c1 e2 04          	shl    $0x4,%r10
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:83
    36b2:	44 89 f0             	mov    %r14d,%eax
    36b5:	44 39 f3             	cmp    %r14d,%ebx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:82
    36b8:	42 8b 54 17 08       	mov    0x8(%rdi,%r10,1),%edx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:83
    36bd:	0f 46 c3             	cmovbe %ebx,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:82
    36c0:	89 d1                	mov    %edx,%ecx
    36c2:	44 29 e9             	sub    %r13d,%ecx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:83
    36c5:	39 c8                	cmp    %ecx,%eax
    36c7:	0f 47 c1             	cmova  %ecx,%eax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:87
    36ca:	41 01 c5             	add    %eax,%r13d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:85
    36cd:	29 c3                	sub    %eax,%ebx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:86
    36cf:	41 29 c6             	sub    %eax,%r14d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:90
    36d2:	44 39 ea             	cmp    %r13d,%edx
    36d5:	75 06                	jne    36dd <afs_write_request+0x21d>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:92
    36d7:	83 c6 01             	add    $0x1,%esi
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:91
    36da:	45 31 ed             	xor    %r13d,%r13d
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:81
    36dd:	85 db                	test   %ebx,%ebx
    36df:	75 ca                	jne    36ab <afs_write_request+0x1eb>
    36e1:	89 75 ac             	mov    %esi,-0x54(%rbp)
    36e4:	e9 de fe ff ff       	jmpq   35c7 <afs_write_request+0x107>
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:482
            memcpy(req->data_block + (req->sector_offset * AFS_SECTOR_SIZE) + segment_offset, bio_data + bv.bv_offset, req->request_size - segment_offset);
    36e9:	41 8b bf 60 90 01 00 	mov    0x19060(%r15),%edi
    36f0:	4d 89 fc             	mov    %r15,%r12
    36f3:	c1 e7 09             	shl    $0x9,%edi
    36f6:	48 01 f8             	add    %rdi,%rax
    36f9:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    36fd:	48 01 c7             	add    %rax,%rdi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    3700:	e8 00 00 00 00       	callq  3705 <afs_write_request+0x245>
			3701: R_X86_64_PC32	memcpy-0x4
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:494
    //TODO update this
    //req->sharenrs = "0123";
    //req->encoder = gfshare_ctx_init_enc(req->sharenrs, config->num_carrier_blocks, 2, AFS_BLOCK_SIZE);

    // TODO: Read entropy blocks as well., if needed with secret sharing
    arraytopointer(req->write_blocks, config->num_carrier_blocks, req->carrier_blocks);
    3705:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    3709:	45 31 c9             	xor    %r9d,%r9d
    370c:	49 8b 94 24 50 90 01 	mov    0x19050(%r12),%rdx
    3713:	00 
    3714:	44 0f b6 30          	movzbl (%rax),%r14d
    3718:	49 8d 84 24 00 00 01 	lea    0x10000(%r12),%rax
    371f:	00 
arraytopointer():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:27
    for(i = 0; i < size; i++){
    3720:	45 84 f6             	test   %r14b,%r14b
    3723:	0f 84 df 00 00 00    	je     3808 <afs_write_request+0x348>
    3729:	41 8d 4e ff          	lea    -0x1(%r14),%ecx
    372d:	48 c1 e1 0c          	shl    $0xc,%rcx
    3731:	49 8d 8c 0c 00 10 01 	lea    0x11000(%r12,%rcx,1),%rcx
    3738:	00 
/home/austen/programming/dm-afs/src/dm_afs_engine.c:28
        output[i] = array[i];
    3739:	48 89 02             	mov    %rax,(%rdx)
    373c:	48 05 00 10 00 00    	add    $0x1000,%rax
    3742:	48 83 c2 08          	add    $0x8,%rdx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:27
    for(i = 0; i < size; i++){
    3746:	48 39 c1             	cmp    %rax,%rcx
    3749:	75 ee                	jne    3739 <afs_write_request+0x279>
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:498
    //gfshare_ctx_enc_getshares(req->encoder, req->data_block, req->carrier_blocks);

    // Issue the writes.
    for (i = 0; i < config->num_carrier_blocks; i++) {
    374b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
    374f:	80 3a 00             	cmpb   $0x0,(%rdx)
    3752:	0f 84 6a 02 00 00    	je     39c2 <afs_write_request+0x502>
    3758:	4c 8b 6d 90          	mov    -0x70(%rbp),%r13
    375c:	31 db                	xor    %ebx,%ebx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    375e:	4d 8d bc 24 00 80 01 	lea    0x18000(%r12),%r15
    3765:	00 
    3766:	44 8b 75 a8          	mov    -0x58(%rbp),%r14d
    376a:	eb 6e                	jmp    37da <afs_write_request+0x31a>
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:500 (discriminator 1)
        // Allocate new block, or use old one.
        block_num = (modification) ? map_entry_tuple[i].carrier_block_ptr : acquire_block(req->fs, req->vector);
    376c:	41 8b 45 00          	mov    0x0(%r13),%eax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:501 (discriminator 4)
        afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, reset_entry, "no free space left");
    3770:	83 f8 ff             	cmp    $0xffffffff,%eax
    3773:	0f 84 b5 02 00 00    	je     3a2e <afs_write_request+0x56e>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:502 (discriminator 2)
        map_entry_tuple[i].carrier_block_ptr = block_num;
    3779:	41 89 45 00          	mov    %eax,0x0(%r13)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:503 (discriminator 2)
	req->block_nums[i] = block_num;
    377d:	49 8b 8c 24 68 90 01 	mov    0x19068(%r12),%rcx
    3784:	00 
    3785:	49 83 c5 0a          	add    $0xa,%r13
    3789:	89 04 99             	mov    %eax,(%rcx,%rbx,4)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:504 (discriminator 2)
        memcpy(req->carrier_blocks[i], req->data_block, AFS_BLOCK_SIZE);
    378c:	49 8b 8c 24 50 90 01 	mov    0x19050(%r12),%rcx
    3793:	00 
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344 (discriminator 2)
    3794:	49 8b 37             	mov    (%r15),%rsi
    3797:	48 8b 0c d9          	mov    (%rcx,%rbx,8),%rcx
    379b:	48 89 31             	mov    %rsi,(%rcx)
    379e:	48 8d 79 08          	lea    0x8(%rcx),%rdi
    37a2:	49 8b b4 24 f8 8f 01 	mov    0x18ff8(%r12),%rsi
    37a9:	00 
    37aa:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    37ae:	48 89 b1 f8 0f 00 00 	mov    %rsi,0xff8(%rcx)
    37b5:	48 29 f9             	sub    %rdi,%rcx
    37b8:	4c 89 fe             	mov    %r15,%rsi
    37bb:	48 29 ce             	sub    %rcx,%rsi
    37be:	81 c1 00 10 00 00    	add    $0x1000,%ecx
    37c4:	c1 e9 03             	shr    $0x3,%ecx
    37c7:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    37ca:	8d 73 01             	lea    0x1(%rbx),%esi
    37cd:	48 83 c3 01          	add    $0x1,%rbx
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:498 (discriminator 2)
    for (i = 0; i < config->num_carrier_blocks; i++) {
    37d1:	44 0f b6 0a          	movzbl (%rdx),%r9d
    37d5:	41 39 f1             	cmp    %esi,%r9d
    37d8:	7e 28                	jle    3802 <afs_write_request+0x342>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:500
        block_num = (modification) ? map_entry_tuple[i].carrier_block_ptr : acquire_block(req->fs, req->vector);
    37da:	41 83 fe ff          	cmp    $0xffffffff,%r14d
    37de:	75 8c                	jne    376c <afs_write_request+0x2ac>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:500 (discriminator 2)
    37e0:	49 8b b4 24 30 90 01 	mov    0x19030(%r12),%rsi
    37e7:	00 
    37e8:	49 8b bc 24 28 90 01 	mov    0x19028(%r12),%rdi
    37ef:	00 
    37f0:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    37f4:	e8 00 00 00 00       	callq  37f9 <afs_write_request+0x339>
			37f5: R_X86_64_PC32	acquire_block-0x4
    37f9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    37fd:	e9 6e ff ff ff       	jmpq   3770 <afs_write_request+0x2b0>
    3802:	45 89 ce             	mov    %r9d,%r14d
    3805:	89 45 8c             	mov    %eax,-0x74(%rbp)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    3808:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 380f <afs_write_request+0x34f>
			380b: R_X86_64_PC32	kmalloc_caches+0x1c
    380f:	ba 10 00 00 00       	mov    $0x10,%edx
    3814:	be c0 00 40 01       	mov    $0x14000c0,%esi
    3819:	44 89 4d c0          	mov    %r9d,-0x40(%rbp)
    381d:	e8 00 00 00 00       	callq  3822 <afs_write_request+0x362>
			381e: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:286
    bio = kmalloc(sizeof(struct bio *) * num_pages, GFP_KERNEL);
    3822:	41 0f b6 fe          	movzbl %r14b,%edi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3826:	be c0 00 40 01       	mov    $0x14000c0,%esi
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    382b:	49 89 c5             	mov    %rax,%r13
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:286
    382e:	48 c1 e7 03          	shl    $0x3,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    3832:	e8 00 00 00 00       	callq  3837 <afs_write_request+0x377>
			3833: R_X86_64_PC32	__kmalloc-0x4
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
    3837:	44 8b 4d c0          	mov    -0x40(%rbp),%r9d
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    383b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:288
    completion->req = req;
    383f:	4d 89 65 00          	mov    %r12,0x0(%r13)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:290
    for(i = 0; i < num_pages; i++){
    3843:	45 85 c9             	test   %r9d,%r9d
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
    3846:	45 89 4d 08          	mov    %r9d,0x8(%r13)
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:290
    384a:	0f 84 a5 01 00 00    	je     39f5 <afs_write_request+0x535>
    3850:	31 db                	xor    %ebx,%ebx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:310
        bio[i]->bi_end_io = afs_write_endio;
    3852:	4d 89 e6             	mov    %r12,%r14
    3855:	e9 eb 00 00 00       	jmpq   3945 <afs_write_request+0x485>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:297
        afs_action(!((uint64_t)req->carrier_blocks[i] & (AFS_BLOCK_SIZE - 1)), ret = -EINVAL, done, "page is not aligned [%d]", ret);
    385a:	49 8b 96 50 90 01 00 	mov    0x19050(%r14),%rdx
    3861:	4a 8b 14 fa          	mov    (%rdx,%r15,8),%rdx
    3865:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
    386b:	0f 85 45 02 00 00    	jne    3ab6 <afs_write_request+0x5f6>
    3871:	bf 00 00 00 80       	mov    $0x80000000,%edi
    3876:	48 01 fa             	add    %rdi,%rdx
    3879:	0f 82 2b 02 00 00    	jb     3aaa <afs_write_request+0x5ea>
__phys_addr_nodebug():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19
    387f:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
    3886:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 388d <afs_write_request+0x3cd>
			3889: R_X86_64_PC32	page_offset_base-0x4
    388d:	48 01 d6             	add    %rdx,%rsi
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:301
        sector_num = ((req->block_nums[i] * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE) + req->fs->data_start_off;
    3890:	49 8b 96 68 90 01 00 	mov    0x19068(%r14),%rdx
    3897:	49 8b 8e 28 90 01 00 	mov    0x19028(%r14),%rcx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:300
        page_structure = (used_vmalloc) ? vmalloc_to_page(req->carrier_blocks[i]) : virt_to_page(req->carrier_blocks[i]);
    389e:	48 c1 ee 0c          	shr    $0xc,%rsi
    38a2:	48 c1 e6 06          	shl    $0x6,%rsi
    38a6:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 38ad <afs_write_request+0x3ed>
			38a9: R_X86_64_PC32	vmemmap_base-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:301
        sector_num = ((req->block_nums[i] * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE) + req->fs->data_start_off;
    38ad:	42 8b 14 ba          	mov    (%rdx,%r15,4),%edx
    38b1:	c1 e2 0c             	shl    $0xc,%edx
    38b4:	c1 ea 09             	shr    $0x9,%edx
    38b7:	03 51 14             	add    0x14(%rcx),%edx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:304
        bio[i]->bi_opf |= REQ_OP_WRITE;
    38ba:	83 48 10 01          	orl    $0x1,0x10(%rax)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:305
        bio_set_dev(bio[i], req->bdev);
    38be:	49 8b 04 24          	mov    (%r12),%rax
    38c2:	49 8b 8e 18 90 01 00 	mov    0x19018(%r14),%rcx
    38c9:	48 8b 89 80 00 00 00 	mov    0x80(%rcx),%rcx
    38d0:	48 39 48 08          	cmp    %rcx,0x8(%rax)
    38d4:	74 18                	je     38ee <afs_write_request+0x42e>
bio_clear_flag():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:273
    38d6:	66 81 60 14 ff fd    	andw   $0xfdff,0x14(%rax)
    38dc:	49 8b 8e 18 90 01 00 	mov    0x19018(%r14),%rcx
    38e3:	49 8b 04 24          	mov    (%r12),%rax
    38e7:	48 8b 89 80 00 00 00 	mov    0x80(%rcx),%rcx
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:305
    38ee:	48 89 48 08          	mov    %rcx,0x8(%rax)
    38f2:	49 8b 8e 18 90 01 00 	mov    0x19018(%r14),%rcx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:290
    for(i = 0; i < num_pages; i++){
    38f9:	83 c3 01             	add    $0x1,%ebx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:305
        bio_set_dev(bio[i], req->bdev);
    38fc:	49 8b 04 24          	mov    (%r12),%rax
    3900:	0f b6 49 6c          	movzbl 0x6c(%rcx),%ecx
    3904:	88 48 1b             	mov    %cl,0x1b(%rax)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:306
        bio[i]->bi_iter.bi_sector = sector_num;
    3907:	49 8b 04 24          	mov    (%r12),%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:307
        bio_add_page(bio[i], page_structure, AFS_BLOCK_SIZE, page_offset);
    390b:	31 c9                	xor    %ecx,%ecx
/home/austen/programming/dm-afs/src/dm_afs_engine.c:306
        bio[i]->bi_iter.bi_sector = sector_num;
    390d:	48 89 50 28          	mov    %rdx,0x28(%rax)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:307
        bio_add_page(bio[i], page_structure, AFS_BLOCK_SIZE, page_offset);
    3911:	49 8b 3c 24          	mov    (%r12),%rdi
    3915:	ba 00 10 00 00       	mov    $0x1000,%edx
    391a:	e8 00 00 00 00       	callq  391f <afs_write_request+0x45f>
			391b: R_X86_64_PC32	bio_add_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:309
        bio[i]->bi_private = completion;
    391f:	49 8b 04 24          	mov    (%r12),%rax
    3923:	4c 89 68 50          	mov    %r13,0x50(%rax)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:310
        bio[i]->bi_end_io = afs_write_endio;
    3927:	49 8b 04 24          	mov    (%r12),%rax
    392b:	48 c7 40 48 00 00 00 	movq   $0x0,0x48(%rax)
    3932:	00 
			392f: R_X86_64_32S	.text+0x29a0
/home/austen/programming/dm-afs/src/dm_afs_engine.c:311
        generic_make_request(bio[i]);
    3933:	49 8b 3c 24          	mov    (%r12),%rdi
    3937:	e8 00 00 00 00       	callq  393c <afs_write_request+0x47c>
			3938: R_X86_64_PC32	generic_make_request-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:290
    for(i = 0; i < num_pages; i++){
    393c:	39 5d c0             	cmp    %ebx,-0x40(%rbp)
    393f:	0f 84 b0 00 00 00    	je     39f5 <afs_write_request+0x535>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:293
        bio[i] = bio_alloc(GFP_NOIO, 1);
    3945:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    3949:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 3950 <afs_write_request+0x490>
			394c: R_X86_64_PC32	fs_bio_set-0x4
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:293
    3950:	4c 63 fb             	movslq %ebx,%r15
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    3953:	be 01 00 00 00       	mov    $0x1,%esi
    3958:	bf 00 00 40 01       	mov    $0x1400000,%edi
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:293
    395d:	4e 8d 24 f8          	lea    (%rax,%r15,8),%r12
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    3961:	e8 00 00 00 00       	callq  3966 <afs_write_request+0x4a6>
			3962: R_X86_64_PC32	bio_alloc_bioset-0x4
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:294
        afs_action(!IS_ERR(bio[i]), ret = PTR_ERR(bio[i]), done, "could not allocate bio [%d]", ret);
    3966:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
/home/austen/programming/dm-afs/src/dm_afs_engine.c:293
        bio[i] = bio_alloc(GFP_NOIO, 1);
    396c:	49 89 04 24          	mov    %rax,(%r12)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:294
        afs_action(!IS_ERR(bio[i]), ret = PTR_ERR(bio[i]), done, "could not allocate bio [%d]", ret);
    3970:	0f 86 e4 fe ff ff    	jbe    385a <afs_write_request+0x39a>
    3976:	89 c1                	mov    %eax,%ecx
    3978:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    397c:	ba 26 01 00 00       	mov    $0x126,%edx
    3981:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3984: R_X86_64_32S	.rodata+0x180
    3988:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			398b: R_X86_64_32S	.rodata.str1.8+0x13f8
    398f:	89 c3                	mov    %eax,%ebx
    3991:	31 c0                	xor    %eax,%eax
    3993:	4d 89 f4             	mov    %r14,%r12
    3996:	e8 00 00 00 00       	callq  399b <afs_write_request+0x4db>
			3997: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:315
    kfree(bio);
    399b:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    399f:	e8 00 00 00 00       	callq  39a4 <afs_write_request+0x4e4>
			39a0: R_X86_64_PC32	kfree-0x4
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:507
    }
    ret = write_pages(req, false, config->num_carrier_blocks);
    afs_action(!ret, ret = -EIO, reset_entry, "could not write page at block [%u]", block_num);
    39a4:	4c 8b 5d c0          	mov    -0x40(%rbp),%r11
    39a8:	45 85 db             	test   %r11d,%r11d
    39ab:	0f 85 30 01 00 00    	jne    3ae1 <afs_write_request+0x621>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:525
block_err:
    kfree(req->carrier_blocks);

err:
    return ret;
}
    39b1:	48 83 c4 58          	add    $0x58,%rsp
    39b5:	89 d8                	mov    %ebx,%eax
    39b7:	5b                   	pop    %rbx
    39b8:	41 5c                	pop    %r12
    39ba:	41 5d                	pop    %r13
    39bc:	41 5e                	pop    %r14
    39be:	41 5f                	pop    %r15
    39c0:	5d                   	pop    %rbp
    39c1:	c3                   	retq   
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    39c2:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 39c9 <afs_write_request+0x509>
			39c5: R_X86_64_PC32	kmalloc_caches+0x1c
    39c9:	ba 10 00 00 00       	mov    $0x10,%edx
    39ce:	be c0 00 40 01       	mov    $0x14000c0,%esi
    39d3:	e8 00 00 00 00       	callq  39d8 <afs_write_request+0x518>
			39d4: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    39d8:	be c0 00 40 01       	mov    $0x14000c0,%esi
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    39dd:	48 89 c3             	mov    %rax,%rbx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    39e0:	31 ff                	xor    %edi,%edi
    39e2:	e8 00 00 00 00       	callq  39e7 <afs_write_request+0x527>
			39e3: R_X86_64_PC32	__kmalloc-0x4
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:216
    39e7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%rbx)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    39ee:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:288
    completion->req = req;
    39f2:	4c 89 23             	mov    %r12,(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:315
    kfree(bio);
    39f5:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    39f9:	31 db                	xor    %ebx,%ebx
    39fb:	e8 00 00 00 00       	callq  3a00 <afs_write_request+0x540>
			39fc: R_X86_64_PC32	kfree-0x4
    3a00:	eb af                	jmp    39b1 <afs_write_request+0x4f1>
bvec_iter_advance():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bvec.h:75
    3a02:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 3a09 <afs_write_request+0x549>
			3a04: R_X86_64_PC32	.data.once-0x5
    3a09:	4d 89 fc             	mov    %r15,%r12
    3a0c:	0f 85 f3 fc ff ff    	jne    3705 <afs_write_request+0x245>
    3a12:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3a15: R_X86_64_32S	.rodata.str1.8+0x1388
    3a19:	31 c0                	xor    %eax,%eax
    3a1b:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 3a22 <afs_write_request+0x562>
			3a1d: R_X86_64_PC32	.data.once-0x5
    3a22:	e8 00 00 00 00       	callq  3a27 <afs_write_request+0x567>
			3a23: R_X86_64_PC32	__warn_printk-0x4
    3a27:	0f 0b                	ud2    
    3a29:	e9 d7 fc ff ff       	jmpq   3705 <afs_write_request+0x245>
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:501 (discriminator 1)
        afs_action(block_num != AFS_INVALID_BLOCK, ret = -ENOSPC, reset_entry, "no free space left");
    3a2e:	ba f5 01 00 00       	mov    $0x1f5,%edx
    3a33:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3a36: R_X86_64_32S	.rodata+0x190
    3a3a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3a3d: R_X86_64_32S	.rodata.str1.8+0x1570
    3a41:	31 c0                	xor    %eax,%eax
    3a43:	bb e4 ff ff ff       	mov    $0xffffffe4,%ebx
    3a48:	e8 00 00 00 00       	callq  3a4d <afs_write_request+0x58d>
			3a49: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:511
    for (i = 0; i < config->num_carrier_blocks; i++) {
    3a4d:	4c 8b 7d 98          	mov    -0x68(%rbp),%r15
    3a51:	41 80 3f 00          	cmpb   $0x0,(%r15)
    3a55:	74 34                	je     3a8b <afs_write_request+0x5cb>
    3a57:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
    3a5b:	45 31 ed             	xor    %r13d,%r13d
/home/austen/programming/dm-afs/src/dm_afs_engine.c:512
        if (map_entry_tuple[i].carrier_block_ptr != AFS_INVALID_BLOCK) {
    3a5e:	41 8b 36             	mov    (%r14),%esi
    3a61:	83 fe ff             	cmp    $0xffffffff,%esi
    3a64:	74 0d                	je     3a73 <afs_write_request+0x5b3>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:513
            allocation_free(req->vector, map_entry_tuple[i].carrier_block_ptr);
    3a66:	49 8b bc 24 30 90 01 	mov    0x19030(%r12),%rdi
    3a6d:	00 
    3a6e:	e8 00 00 00 00       	callq  3a73 <afs_write_request+0x5b3>
			3a6f: R_X86_64_PC32	allocation_free-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:515 (discriminator 2)
        map_entry_tuple[i].carrier_block_ptr = AFS_INVALID_BLOCK;
    3a73:	41 c7 06 ff ff ff ff 	movl   $0xffffffff,(%r14)
/home/austen/programming/dm-afs/src/dm_afs_engine.c:511 (discriminator 2)
    for (i = 0; i < config->num_carrier_blocks; i++) {
    3a7a:	41 0f b6 07          	movzbl (%r15),%eax
    3a7e:	41 83 c5 01          	add    $0x1,%r13d
    3a82:	49 83 c6 0a          	add    $0xa,%r14
    3a86:	44 39 e8             	cmp    %r13d,%eax
    3a89:	7f d3                	jg     3a5e <afs_write_request+0x59e>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:517
    kfree(req->block_nums);
    3a8b:	49 8b bc 24 68 90 01 	mov    0x19068(%r12),%rdi
    3a92:	00 
    3a93:	e8 00 00 00 00       	callq  3a98 <afs_write_request+0x5d8>
			3a94: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:521
    kfree(req->carrier_blocks);
    3a98:	49 8b bc 24 50 90 01 	mov    0x19050(%r12),%rdi
    3a9f:	00 
    3aa0:	e8 00 00 00 00       	callq  3aa5 <afs_write_request+0x5e5>
			3aa1: R_X86_64_PC32	kfree-0x4
    3aa5:	e9 07 ff ff ff       	jmpq   39b1 <afs_write_request+0x4f1>
__phys_addr_nodebug():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19
    3aaa:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 3ab1 <afs_write_request+0x5f1>
			3aad: R_X86_64_PC32	phys_base-0x4
    3ab1:	e9 d7 fd ff ff       	jmpq   388d <afs_write_request+0x3cd>
write_pages():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:297
        afs_action(!((uint64_t)req->carrier_blocks[i] & (AFS_BLOCK_SIZE - 1)), ret = -EINVAL, done, "page is not aligned [%d]", ret);
    3ab6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3ab9: R_X86_64_32S	.rodata.str1.8+0x1430
    3abd:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
    3ac2:	ba 29 01 00 00       	mov    $0x129,%edx
    3ac7:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3aca: R_X86_64_32S	.rodata+0x180
    3ace:	31 c0                	xor    %eax,%eax
    3ad0:	4d 89 f4             	mov    %r14,%r12
    3ad3:	e8 00 00 00 00       	callq  3ad8 <afs_write_request+0x618>
			3ad4: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_engine.c:315
    kfree(bio);
    3ad8:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    3adc:	e8 00 00 00 00       	callq  3ae1 <afs_write_request+0x621>
			3add: R_X86_64_PC32	kfree-0x4
afs_write_request():
/home/austen/programming/dm-afs/src/dm_afs_engine.c:507 (discriminator 1)
    afs_action(!ret, ret = -EIO, reset_entry, "could not write page at block [%u]", block_num);
    3ae1:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
    3ae4:	ba fb 01 00 00       	mov    $0x1fb,%edx
    3ae9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3aec: R_X86_64_32S	.rodata+0x190
    3af0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3af3: R_X86_64_32S	.rodata.str1.8+0x15a0
    3af7:	31 c0                	xor    %eax,%eax
    3af9:	bb fb ff ff ff       	mov    $0xfffffffb,%ebx
    3afe:	e8 00 00 00 00       	callq  3b03 <afs_write_request+0x643>
			3aff: R_X86_64_PC32	printk-0x4
    3b03:	e9 45 ff ff ff       	jmpq   3a4d <afs_write_request+0x58d>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:462 (discriminator 1)
    afs_action(req->block_nums, ret = -ENOMEM, block_err, "could not allocate block nums [%d]", ret);
    3b08:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    3b0d:	ba ce 01 00 00       	mov    $0x1ce,%edx
    3b12:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3b15: R_X86_64_32S	.rodata+0x190
    3b19:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3b1c: R_X86_64_32S	.rodata.str1.8+0x1530
    3b20:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
    3b25:	e8 00 00 00 00       	callq  3b2a <afs_write_request+0x66a>
			3b26: R_X86_64_PC32	printk-0x4
    3b2a:	e9 69 ff ff ff       	jmpq   3a98 <afs_write_request+0x5d8>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:460 (discriminator 1)
    afs_action(req->carrier_blocks, ret = -ENOMEM, err, "could not allocate carrier block array [%d]", ret);
    3b2f:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    3b34:	ba cc 01 00 00       	mov    $0x1cc,%edx
    3b39:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3b3c: R_X86_64_32S	.rodata+0x190
    3b40:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3b43: R_X86_64_32S	.rodata.str1.8+0x14e8
    3b47:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
    3b4c:	e8 00 00 00 00       	callq  3b51 <afs_write_request+0x691>
			3b4d: R_X86_64_PC32	printk-0x4
    3b51:	e9 5b fe ff ff       	jmpq   39b1 <afs_write_request+0x4f1>
/home/austen/programming/dm-afs/src/dm_afs_engine.c:439 (discriminator 1)
    afs_action(req->request_size <= AFS_BLOCK_SIZE, ret = -EINVAL, err, "cannot handle requested size [%u]", req->request_size);
    3b56:	ba b7 01 00 00       	mov    $0x1b7,%edx
    3b5b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3b5e: R_X86_64_32S	.rodata+0x190
    3b62:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3b65: R_X86_64_32S	.rodata.str1.8+0x13b8
    3b69:	31 c0                	xor    %eax,%eax
    3b6b:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
    3b70:	e8 00 00 00 00       	callq  3b75 <afs_write_request+0x6b5>
			3b71: R_X86_64_PC32	printk-0x4
    3b75:	e9 37 fe ff ff       	jmpq   39b1 <afs_write_request+0x4f1>
    3b7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000003b80 <random_block_index>:
random_block_index():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:14

/**
 * Pick an index at random within the allocation vector
 * TODO Probably should have this operate over the length of the block_list array 
 */
uint32_t random_block_index(struct afs_passive_fs *fs, struct afs_allocation_vector *vector){
    3b80:	e8 00 00 00 00       	callq  3b85 <random_block_index+0x5>
			3b81: R_X86_64_PC32	__fentry__-0x4
    3b85:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:16
    uint32_t block_num;
    get_random_bytes(&block_num, sizeof(uint32_t));
    3b86:	be 04 00 00 00       	mov    $0x4,%esi
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:14
uint32_t random_block_index(struct afs_passive_fs *fs, struct afs_allocation_vector *vector){
    3b8b:	48 89 e5             	mov    %rsp,%rbp
    3b8e:	53                   	push   %rbx
    3b8f:	48 89 fb             	mov    %rdi,%rbx
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:16
    get_random_bytes(&block_num, sizeof(uint32_t));
    3b92:	48 8d 7d e4          	lea    -0x1c(%rbp),%rdi
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:14
uint32_t random_block_index(struct afs_passive_fs *fs, struct afs_allocation_vector *vector){
    3b96:	48 83 ec 18          	sub    $0x18,%rsp
    3b9a:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    3ba1:	00 00 
    3ba3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    3ba7:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:16
    get_random_bytes(&block_num, sizeof(uint32_t));
    3ba9:	e8 00 00 00 00       	callq  3bae <random_block_index+0x2e>
			3baa: R_X86_64_PC32	get_random_bytes-0x4
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:17
    block_num = block_num % fs->list_len;
    3bae:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    3bb1:	31 d2                	xor    %edx,%edx
    3bb3:	f7 73 08             	divl   0x8(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:19
    return block_num; 
}
    3bb6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    3bba:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    3bc1:	00 00 
    3bc3:	75 09                	jne    3bce <random_block_index+0x4e>
    3bc5:	48 83 c4 18          	add    $0x18,%rsp
    3bc9:	89 d0                	mov    %edx,%eax
    3bcb:	5b                   	pop    %rbx
    3bcc:	5d                   	pop    %rbp
    3bcd:	c3                   	retq   
    3bce:	e8 00 00 00 00       	callq  3bd3 <random_block_index+0x53>
			3bcf: R_X86_64_PC32	__stack_chk_fail-0x4
    3bd3:	0f 1f 00             	nopl   (%rax)
    3bd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3bdd:	00 00 00 

0000000000003be0 <allocation_get>:
allocation_get():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:26
/**
 * Get the state of a block in the allocation vector.
 */
uint8_t
allocation_get(struct afs_allocation_vector *vector, uint32_t index)
{
    3be0:	e8 00 00 00 00       	callq  3be5 <allocation_get+0x5>
			3be1: R_X86_64_PC32	__fentry__-0x4
    3be5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:27
    int ret = bit_vector_get(vector->vector, index);
    3be6:	48 8b 3f             	mov    (%rdi),%rdi
    3be9:	89 f6                	mov    %esi,%esi
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:26
{
    3beb:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:27
    int ret = bit_vector_get(vector->vector, index);
    3bee:	e8 00 00 00 00       	callq  3bf3 <allocation_get+0x13>
			3bef: R_X86_64_PC32	bit_vector_get-0x4
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:30

    // Make sure return code was valid.
    if (ret < 0) {
    3bf3:	85 c0                	test   %eax,%eax
    3bf5:	78 07                	js     3bfe <allocation_get+0x1e>
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:35
        afs_alert("bit_vector_get returned %d", ret);
        ret = 0;
    }

    return (ret) ? 1 : 0;
    3bf7:	85 c0                	test   %eax,%eax
    3bf9:	0f 95 c0             	setne  %al
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:36
}
    3bfc:	5d                   	pop    %rbp
    3bfd:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:31
        afs_alert("bit_vector_get returned %d", ret);
    3bfe:	89 c1                	mov    %eax,%ecx
    3c00:	ba 1f 00 00 00       	mov    $0x1f,%edx
    3c05:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3c08: R_X86_64_32S	.rodata+0x230
    3c0c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3c0f: R_X86_64_32S	.rodata.str1.8+0x15e0
    3c13:	31 c0                	xor    %eax,%eax
    3c15:	e8 00 00 00 00       	callq  3c1a <allocation_get+0x3a>
			3c16: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:32
        ret = 0;
    3c1a:	31 c0                	xor    %eax,%eax
    3c1c:	eb d9                	jmp    3bf7 <allocation_get+0x17>
    3c1e:	66 90                	xchg   %ax,%ax

0000000000003c20 <allocation_set>:
allocation_set():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:43
/**
 * Set the usage of a block in the allocation vector.
 */
bool
allocation_set(struct afs_allocation_vector *vector, uint32_t index)
{
    3c20:	e8 00 00 00 00       	callq  3c25 <allocation_set+0x5>
			3c21: R_X86_64_PC32	__fentry__-0x4
    3c25:	55                   	push   %rbp
    3c26:	48 89 e5             	mov    %rsp,%rbp
    3c29:	41 55                	push   %r13
    3c2b:	41 54                	push   %r12
    3c2d:	53                   	push   %rbx
    3c2e:	49 89 fd             	mov    %rdi,%r13
    3c31:	89 f3                	mov    %esi,%ebx
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:48
    int ret;

    // Make sure index is not already taken.
    if (allocation_get(vector, index)) {
        return false;
    3c33:	45 31 e4             	xor    %r12d,%r12d
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:43
{
    3c36:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:47
    if (allocation_get(vector, index)) {
    3c3a:	e8 00 00 00 00       	callq  3c3f <allocation_set+0x1f>
			3c3b: R_X86_64_PC32	allocation_get-0x4
    3c3f:	84 c0                	test   %al,%al
    3c41:	74 0e                	je     3c51 <allocation_set+0x31>
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:58
    afs_assert(!ret, err, "bit_vector_set returned %d", ret);
    return true;

err:
    return false;
}
    3c43:	48 83 c4 08          	add    $0x8,%rsp
    3c47:	44 89 e0             	mov    %r12d,%eax
    3c4a:	5b                   	pop    %rbx
    3c4b:	41 5c                	pop    %r12
    3c4d:	41 5d                	pop    %r13
    3c4f:	5d                   	pop    %rbp
    3c50:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:50
    ret = bit_vector_set(vector->vector, index);
    3c51:	49 8b 7d 00          	mov    0x0(%r13),%rdi
    3c55:	89 de                	mov    %ebx,%esi
    3c57:	e8 00 00 00 00       	callq  3c5c <allocation_set+0x3c>
			3c58: R_X86_64_PC32	bit_vector_set-0x4
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:53
    afs_assert(!ret, err, "bit_vector_set returned %d", ret);
    3c5c:	85 c0                	test   %eax,%eax
    3c5e:	75 14                	jne    3c74 <allocation_set+0x54>
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:58
}
    3c60:	48 83 c4 08          	add    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:54
    return true;
    3c64:	41 bc 01 00 00 00    	mov    $0x1,%r12d
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:58
}
    3c6a:	5b                   	pop    %rbx
    3c6b:	44 89 e0             	mov    %r12d,%eax
    3c6e:	41 5c                	pop    %r12
    3c70:	41 5d                	pop    %r13
    3c72:	5d                   	pop    %rbp
    3c73:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:53
    afs_assert(!ret, err, "bit_vector_set returned %d", ret);
    3c74:	89 c1                	mov    %eax,%ecx
    3c76:	ba 35 00 00 00       	mov    $0x35,%edx
    3c7b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3c7e: R_X86_64_32S	.rodata+0x220
    3c82:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3c85: R_X86_64_32S	.rodata.str1.8+0x1618
    3c89:	31 c0                	xor    %eax,%eax
    3c8b:	e8 00 00 00 00       	callq  3c90 <allocation_set+0x70>
			3c8c: R_X86_64_PC32	printk-0x4
    3c90:	eb b1                	jmp    3c43 <allocation_set+0x23>
    3c92:	0f 1f 40 00          	nopl   0x0(%rax)
    3c96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3c9d:	00 00 00 

0000000000003ca0 <allocation_free>:
allocation_free():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:65
/**
 * Clear the usage of a block in the allocation vector.
 */
void
allocation_free(struct afs_allocation_vector *vector, uint32_t index)
{
    3ca0:	e8 00 00 00 00       	callq  3ca5 <allocation_free+0x5>
			3ca1: R_X86_64_PC32	__fentry__-0x4
    3ca5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:66
    int ret = bit_vector_clear(vector->vector, index);
    3ca6:	48 8b 3f             	mov    (%rdi),%rdi
    3ca9:	89 f6                	mov    %esi,%esi
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:65
{
    3cab:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:66
    int ret = bit_vector_clear(vector->vector, index);
    3cae:	e8 00 00 00 00       	callq  3cb3 <allocation_free+0x13>
			3caf: R_X86_64_PC32	bit_vector_clear-0x4
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:69

    // Make sure return code was valid.
    if (ret) {
    3cb3:	85 c0                	test   %eax,%eax
    3cb5:	75 02                	jne    3cb9 <allocation_free+0x19>
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:72
        afs_alert("bit_vector_clear returned %d", ret);
    }
}
    3cb7:	5d                   	pop    %rbp
    3cb8:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:70
        afs_alert("bit_vector_clear returned %d", ret);
    3cb9:	89 c1                	mov    %eax,%ecx
    3cbb:	ba 46 00 00 00       	mov    $0x46,%edx
    3cc0:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			3cc3: R_X86_64_32S	.rodata+0x210
    3cc7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			3cca: R_X86_64_32S	.rodata.str1.8+0x1650
    3cce:	31 c0                	xor    %eax,%eax
    3cd0:	e8 00 00 00 00       	callq  3cd5 <allocation_free+0x35>
			3cd1: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:72
}
    3cd5:	5d                   	pop    %rbp
    3cd6:	c3                   	retq   
    3cd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3cde:	00 00 

0000000000003ce0 <acquire_block>:
acquire_block():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:80
 * Acquire a free block from the free list.
 * TODO just have it randomly select a block
 */
uint32_t
acquire_block(struct afs_passive_fs *fs, struct afs_allocation_vector *vector)
{
    3ce0:	e8 00 00 00 00       	callq  3ce5 <acquire_block+0x5>
			3ce1: R_X86_64_PC32	__fentry__-0x4
    3ce5:	55                   	push   %rbp
    3ce6:	48 89 e5             	mov    %rsp,%rbp
    3ce9:	41 56                	push   %r14
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    3ceb:	4c 8d 76 08          	lea    0x8(%rsi),%r14
acquire_block():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:80
    3cef:	41 55                	push   %r13
    3cf1:	41 54                	push   %r12
    3cf3:	49 89 f4             	mov    %rsi,%r12
    3cf6:	53                   	push   %rbx
    3cf7:	48 89 fb             	mov    %rdi,%rbx
spin_lock():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/spinlock.h:310
    3cfa:	4c 89 f7             	mov    %r14,%rdi
    3cfd:	e8 00 00 00 00       	callq  3d02 <acquire_block+0x22>
			3cfe: R_X86_64_PC32	_raw_spin_lock-0x4
acquire_block():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:87
    uint32_t current_num;
    uint32_t ret;

    spin_lock(&vector->lock);
    //block_num = random_block_index(fs, vector);
    current_num = block_num;
    3d02:	44 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13d        # 3d09 <acquire_block+0x29>
			3d05: R_X86_64_PC32	.bss+0xc
    3d09:	44 89 ee             	mov    %r13d,%esi
    3d0c:	eb 1b                	jmp    3d29 <acquire_block+0x49>
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:96
            block_num = (block_num + 1) % fs->list_len;
            spin_unlock(&vector->lock);
            return ret;
        }
	//block_num = random_block_index(fs, vector);
        block_num = (block_num + 1) % fs->list_len;
    3d0e:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 3d14 <acquire_block+0x34>
			3d10: R_X86_64_PC32	.bss+0xc
    3d14:	31 d2                	xor    %edx,%edx
    3d16:	83 c0 01             	add    $0x1,%eax
    3d19:	f7 73 08             	divl   0x8(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:97
    } while (block_num != current_num);
    3d1c:	44 39 ea             	cmp    %r13d,%edx
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:96
        block_num = (block_num + 1) % fs->list_len;
    3d1f:	89 d6                	mov    %edx,%esi
    3d21:	89 15 00 00 00 00    	mov    %edx,0x0(%rip)        # 3d27 <acquire_block+0x47>
			3d23: R_X86_64_PC32	.bss+0xc
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:97
    } while (block_num != current_num);
    3d27:	74 3e                	je     3d67 <acquire_block+0x87>
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:89
        if (allocation_set(vector, block_num)) {
    3d29:	4c 89 e7             	mov    %r12,%rdi
    3d2c:	e8 00 00 00 00       	callq  3d31 <acquire_block+0x51>
			3d2d: R_X86_64_PC32	allocation_set-0x4
    3d31:	84 c0                	test   %al,%al
    3d33:	74 d9                	je     3d0e <acquire_block+0x2e>
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:90
            ret = fs->block_list[block_num];
    3d35:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 3d3b <acquire_block+0x5b>
			3d37: R_X86_64_PC32	.bss+0xc
    3d3b:	48 8b 13             	mov    (%rbx),%rdx
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
    3d3e:	4c 89 f7             	mov    %r14,%rdi
acquire_block():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:90
    3d41:	48 89 c8             	mov    %rcx,%rax
    3d44:	8b 0c 8a             	mov    (%rdx,%rcx,4),%ecx
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:91
            block_num = (block_num + 1) % fs->list_len;
    3d47:	31 d2                	xor    %edx,%edx
    3d49:	83 c0 01             	add    $0x1,%eax
    3d4c:	f7 73 08             	divl   0x8(%rbx)
    3d4f:	89 15 00 00 00 00    	mov    %edx,0x0(%rip)        # 3d55 <acquire_block+0x75>
			3d51: R_X86_64_PC32	.bss+0xc
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
    3d55:	ff 14 25 00 00 00 00 	callq  *0x0
			3d58: R_X86_64_32S	pv_lock_ops+0x8
acquire_block():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:101
    spin_unlock(&vector->lock);

    return AFS_INVALID_BLOCK;
}
    3d5c:	5b                   	pop    %rbx
    3d5d:	89 c8                	mov    %ecx,%eax
    3d5f:	41 5c                	pop    %r12
    3d61:	41 5d                	pop    %r13
    3d63:	41 5e                	pop    %r14
    3d65:	5d                   	pop    %rbp
    3d66:	c3                   	retq   
pv_queued_spin_unlock():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/paravirt.h:674
    3d67:	4c 89 f7             	mov    %r14,%rdi
    3d6a:	ff 14 25 00 00 00 00 	callq  *0x0
			3d6d: R_X86_64_32S	pv_lock_ops+0x8
acquire_block():
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:100
    return AFS_INVALID_BLOCK;
    3d71:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
/home/austen/programming/dm-afs/src/dm_afs_allocation.c:101
}
    3d76:	5b                   	pop    %rbx
    3d77:	89 c8                	mov    %ecx,%eax
    3d79:	41 5c                	pop    %r12
    3d7b:	41 5d                	pop    %r13
    3d7d:	41 5e                	pop    %r14
    3d7f:	5d                   	pop    %rbp
    3d80:	c3                   	retq   
    3d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3d88:	00 00 00 
    3d8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000003d90 <gen_crc16.part.0>:
gen_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:107
}

/**
 * Somewhat fast CRC16 function
 */
uint16_t gen_crc16(const uint8_t *data, uint16_t size)
    3d90:	e8 00 00 00 00       	callq  3d95 <gen_crc16.part.0+0x5>
			3d91: R_X86_64_PC32	__fentry__-0x4
    3d95:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:109
{
    uint16_t out = 0;
    3d96:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:119

    /* Sanity check: */
    if(data == NULL)
        return 0;

    while(size > 0)
    3d98:	66 85 f6             	test   %si,%si
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:107
uint16_t gen_crc16(const uint8_t *data, uint16_t size)
    3d9b:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:119
    while(size > 0)
    3d9e:	74 42                	je     3de2 <gen_crc16.part.0+0x52>
    3da0:	41 89 f0             	mov    %esi,%r8d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:110
    int bits_read = 0, bit_flag;
    3da3:	31 c9                	xor    %ecx,%ecx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:109
    uint16_t out = 0;
    3da5:	31 c0                	xor    %eax,%eax
    3da7:	44 0f b6 0f          	movzbl (%rdi),%r9d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:125
    {
        bit_flag = out >> 15;

        /* Get next bit: */
        out <<= 1;
        out |= (*data >> bits_read) & 1; // item a) work from the least significant bits
    3dab:	44 89 ca             	mov    %r9d,%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:121
        bit_flag = out >> 15;
    3dae:	89 c6                	mov    %eax,%esi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:124
        out <<= 1;
    3db0:	01 c0                	add    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:125
        out |= (*data >> bits_read) & 1; // item a) work from the least significant bits
    3db2:	d3 fa                	sar    %cl,%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:128

        /* Increment bit counter: */
        bits_read++;
    3db4:	83 c1 01             	add    $0x1,%ecx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:121
        bit_flag = out >> 15;
    3db7:	66 c1 ee 0f          	shr    $0xf,%si
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:125
        out |= (*data >> bits_read) & 1; // item a) work from the least significant bits
    3dbb:	83 e2 01             	and    $0x1,%edx
    3dbe:	09 c2                	or     %eax,%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:129
        if(bits_read > 7)
    3dc0:	83 f9 07             	cmp    $0x7,%ecx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:125
        out |= (*data >> bits_read) & 1; // item a) work from the least significant bits
    3dc3:	89 d0                	mov    %edx,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:129
        if(bits_read > 7)
    3dc5:	7e 65                	jle    3e2c <gen_crc16.part.0+0x9c>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:132
        {
            bits_read = 0;
            data++;
    3dc7:	48 83 c7 01          	add    $0x1,%rdi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:133
            size--;
    3dcb:	41 83 e8 01          	sub    $0x1,%r8d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:131
            bits_read = 0;
    3dcf:	31 c9                	xor    %ecx,%ecx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:137
        }

        /* Cycle check: */
        if(bit_flag)
    3dd1:	66 85 f6             	test   %si,%si
    3dd4:	74 06                	je     3ddc <gen_crc16.part.0+0x4c>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:138
            out ^= CRC16;
    3dd6:	89 d0                	mov    %edx,%eax
    3dd8:	66 35 05 80          	xor    $0x8005,%ax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:119
    while(size > 0)
    3ddc:	66 45 85 c0          	test   %r8w,%r8w
    3de0:	75 c5                	jne    3da7 <gen_crc16.part.0+0x17>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:109
    uint16_t out = 0;
    3de2:	ba 10 00 00 00       	mov    $0x10,%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:144

    }

    // item b) "push out" the last 16 bits
    for (i = 0; i < 16; ++i) {
        bit_flag = out >> 15;
    3de7:	89 c6                	mov    %eax,%esi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:145
        out <<= 1;
    3de9:	01 c0                	add    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:147
        if(bit_flag)
            out ^= CRC16;
    3deb:	89 c1                	mov    %eax,%ecx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:144
        bit_flag = out >> 15;
    3ded:	66 c1 ee 0f          	shr    $0xf,%si
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:147
            out ^= CRC16;
    3df1:	66 81 f1 05 80       	xor    $0x8005,%cx
    3df6:	66 85 f6             	test   %si,%si
    3df9:	0f 45 c1             	cmovne %ecx,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:143
    for (i = 0; i < 16; ++i) {
    3dfc:	83 ea 01             	sub    $0x1,%edx
    3dff:	75 e6                	jne    3de7 <gen_crc16.part.0+0x57>
    3e01:	0f b7 d0             	movzwl %ax,%edx
    3e04:	bf 10 00 00 00       	mov    $0x10,%edi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:151
    }

    // item c) reverse the bits
    crc = 0;
    3e09:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:113
    int j = 0x0001;
    3e0b:	be 01 00 00 00       	mov    $0x1,%esi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:152
    i = 0x8000;
    3e10:	b9 00 80 00 00       	mov    $0x8000,%ecx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:154
    for (; i != 0; i >>=1, j <<= 1) {
        if (i & out) crc |= j;
    3e15:	41 89 c0             	mov    %eax,%r8d
    3e18:	41 09 f0             	or     %esi,%r8d
    3e1b:	85 d1                	test   %edx,%ecx
    3e1d:	41 0f 45 c0          	cmovne %r8d,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:153
    for (; i != 0; i >>=1, j <<= 1) {
    3e21:	d1 f9                	sar    %ecx
    3e23:	01 f6                	add    %esi,%esi
    3e25:	83 ef 01             	sub    $0x1,%edi
    3e28:	75 eb                	jne    3e15 <gen_crc16.part.0+0x85>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:158
    }

    return crc;
}
    3e2a:	5d                   	pop    %rbp
    3e2b:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:137
        if(bit_flag)
    3e2c:	66 85 f6             	test   %si,%si
    3e2f:	75 a5                	jne    3dd6 <gen_crc16.part.0+0x46>
    3e31:	e9 75 ff ff ff       	jmpq   3dab <gen_crc16.part.0+0x1b>
gen_crc16.part.0():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:137
    3e36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3e3d:	00 00 00 

0000000000003e40 <speck_encrypt_128>:
speck_encrypt_128():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:32
{
    3e40:	e8 00 00 00 00       	callq  3e45 <speck_encrypt_128+0x5>
			3e41: R_X86_64_PC32	__fentry__-0x4
    3e45:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:33
    uint64_t y = pt[0], x = pt[1], b = K[0], a = K[1];
    3e46:	48 8b 46 08          	mov    0x8(%rsi),%rax
    3e4a:	4c 8b 06             	mov    (%rsi),%r8
    3e4d:	48 8b 0a             	mov    (%rdx),%rcx
    3e50:	48 8b 52 08          	mov    0x8(%rdx),%rdx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:32
{
    3e54:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:36
    R(x, y, b);
    3e57:	48 c1 c8 08          	ror    $0x8,%rax
    3e5b:	4c 01 c0             	add    %r8,%rax
    3e5e:	4c 89 c6             	mov    %r8,%rsi
    3e61:	45 31 c0             	xor    %r8d,%r8d
    3e64:	48 31 c8             	xor    %rcx,%rax
    3e67:	48 c1 c6 03          	rol    $0x3,%rsi
    3e6b:	48 31 c6             	xor    %rax,%rsi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:38 (discriminator 3)
        R(a, b, i);
    3e6e:	48 c1 ca 08          	ror    $0x8,%rdx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:39 (discriminator 3)
        R(x, y, b);
    3e72:	48 c1 c8 08          	ror    $0x8,%rax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:38 (discriminator 3)
        R(a, b, i);
    3e76:	48 01 ca             	add    %rcx,%rdx
    3e79:	48 c1 c1 03          	rol    $0x3,%rcx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:39 (discriminator 3)
        R(x, y, b);
    3e7d:	48 01 f0             	add    %rsi,%rax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:38 (discriminator 3)
        R(a, b, i);
    3e80:	4c 31 c2             	xor    %r8,%rdx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:39 (discriminator 3)
        R(x, y, b);
    3e83:	48 c1 c6 03          	rol    $0x3,%rsi
    3e87:	49 83 c0 01          	add    $0x1,%r8
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:38 (discriminator 3)
        R(a, b, i);
    3e8b:	48 31 d1             	xor    %rdx,%rcx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:39 (discriminator 3)
        R(x, y, b);
    3e8e:	48 31 c8             	xor    %rcx,%rax
    3e91:	48 31 c6             	xor    %rax,%rsi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:37 (discriminator 3)
    for (i = 0; i < ROUNDS - 1; i++) {
    3e94:	49 83 f8 1f          	cmp    $0x1f,%r8
    3e98:	75 d4                	jne    3e6e <speck_encrypt_128+0x2e>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:42
    ct[0] = y;
    3e9a:	48 89 37             	mov    %rsi,(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:43
    ct[1] = x;
    3e9d:	48 89 47 08          	mov    %rax,0x8(%rdi)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:44
}
    3ea1:	5d                   	pop    %rbp
    3ea2:	c3                   	retq   
    3ea3:	0f 1f 00             	nopl   (%rax)
    3ea6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3ead:	00 00 00 

0000000000003eb0 <speck_128_hash>:
speck_128_hash():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:46
void speck_128_hash(uint8_t *data, size_t data_length, uint8_t* hash){
    3eb0:	e8 00 00 00 00       	callq  3eb5 <speck_128_hash+0x5>
			3eb1: R_X86_64_PC32	__fentry__-0x4
    3eb5:	55                   	push   %rbp
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    3eb6:	c5 f9 ef c0          	vpxor  %xmm0,%xmm0,%xmm0
speck_128_hash():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:48
    uint32_t rounds = data_length/SPECK_BLOCK_SIZE;
    3eba:	48 c1 ee 04          	shr    $0x4,%rsi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:46
void speck_128_hash(uint8_t *data, size_t data_length, uint8_t* hash){
    3ebe:	48 89 e5             	mov    %rsp,%rbp
    3ec1:	41 55                	push   %r13
    3ec3:	41 54                	push   %r12
    3ec5:	53                   	push   %rbx
    3ec6:	48 83 ec 48          	sub    $0x48,%rsp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:47
    uint64_t seed[2] = {0,0};
    3eca:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
    3ed1:	00 
    3ed2:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
    3ed9:	00 
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:46
void speck_128_hash(uint8_t *data, size_t data_length, uint8_t* hash){
    3eda:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    3ee1:	00 00 
    3ee3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    3ee7:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:56
    for(i = 0; i < rounds; i++){
    3ee9:	83 e6 ff             	and    $0xffffffff,%esi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:52
    ctr[0] = 0;
    3eec:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    3ef3:	00 
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:53
    ctr[1] = 0;
    3ef4:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    3efb:	00 
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    3efc:	c5 f8 11 02          	vmovups %xmm0,(%rdx)
speck_128_hash():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:56
    for(i = 0; i < rounds; i++){
    3f00:	74 54                	je     3f56 <speck_128_hash+0xa6>
    3f02:	48 c1 e6 04          	shl    $0x4,%rsi
    3f06:	49 89 d4             	mov    %rdx,%r12
    3f09:	48 89 fb             	mov    %rdi,%rbx
    3f0c:	4c 8d 2c 37          	lea    (%rdi,%rsi,1),%r13
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:57
        temp[0] = ((uint64_t *)data)[j + 0];
    3f10:	48 8b 03             	mov    (%rbx),%rax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:59
        speck_encrypt_128(temp, ctr, seed);
    3f13:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
    3f17:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
    3f1b:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:57
        temp[0] = ((uint64_t *)data)[j + 0];
    3f1f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:58
        temp[1] = ((uint64_t *)data)[j + 1];
    3f23:	48 8b 43 08          	mov    0x8(%rbx),%rax
    3f27:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:59
        speck_encrypt_128(temp, ctr, seed);
    3f2b:	e8 00 00 00 00       	callq  3f30 <speck_128_hash+0x80>
			3f2c: R_X86_64_PC32	speck_encrypt_128-0x4
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:60
        ((uint64_t*)hash)[0] ^= temp[0];
    3f30:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    3f34:	49 31 04 24          	xor    %rax,(%r12)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:61
        ((uint64_t*)hash)[1] ^= temp[1];
    3f38:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3f3c:	49 31 44 24 08       	xor    %rax,0x8(%r12)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:63
        if(ctr[0] == 0) ctr[1]++;
    3f41:	48 83 45 b0 01       	addq   $0x1,-0x50(%rbp)
    3f46:	75 05                	jne    3f4d <speck_128_hash+0x9d>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:63 (discriminator 1)
    3f48:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
    3f4d:	48 83 c3 10          	add    $0x10,%rbx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:56 (discriminator 2)
    for(i = 0; i < rounds; i++){
    3f51:	4c 39 eb             	cmp    %r13,%rbx
    3f54:	75 ba                	jne    3f10 <speck_128_hash+0x60>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:66
}
    3f56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3f5a:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    3f61:	00 00 
    3f63:	75 0b                	jne    3f70 <speck_128_hash+0xc0>
    3f65:	48 83 c4 48          	add    $0x48,%rsp
    3f69:	5b                   	pop    %rbx
    3f6a:	41 5c                	pop    %r12
    3f6c:	41 5d                	pop    %r13
    3f6e:	5d                   	pop    %rbp
    3f6f:	c3                   	retq   
    3f70:	e8 00 00 00 00       	callq  3f75 <speck_128_hash+0xc5>
			3f71: R_X86_64_PC32	__stack_chk_fail-0x4
    3f75:	90                   	nop
    3f76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f7d:	00 00 00 

0000000000003f80 <gen_crc32>:
gen_crc32():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:75
{
    3f80:	e8 00 00 00 00       	callq  3f85 <gen_crc32+0x5>
			3f81: R_X86_64_PC32	__fentry__-0x4
    3f85:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:77
  uint32_t crc = ~previousCrc32;
    3f86:	89 d0                	mov    %edx,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:83
  while (length >= 8){
    3f88:	48 83 fe 07          	cmp    $0x7,%rsi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:75
{
    3f8c:	49 89 f2             	mov    %rsi,%r10
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:77
  uint32_t crc = ~previousCrc32;
    3f8f:	f7 d0                	not    %eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:75
{
    3f91:	48 89 e5             	mov    %rsp,%rbp
    3f94:	53                   	push   %rbx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:83
  while (length >= 8){
    3f95:	0f 86 81 00 00 00    	jbe    401c <gen_crc32+0x9c>
    3f9b:	48 8d 56 f8          	lea    -0x8(%rsi),%rdx
    3f9f:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
			3fa2: R_X86_64_32S	.rodata+0x280
    3fa6:	48 c1 ea 03          	shr    $0x3,%rdx
    3faa:	4c 8d 44 d7 08       	lea    0x8(%rdi,%rdx,8),%r8
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:84
    one = *current_data++ ^ crc;
    3faf:	33 07                	xor    (%rdi),%eax
    3fb1:	48 83 c7 08          	add    $0x8,%rdi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:85
    two = *current_data++;
    3fb5:	8b 5f fc             	mov    -0x4(%rdi),%ebx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:89
          crc32Lookup[4][ one>>24        ] ^
    3fb8:	41 89 c1             	mov    %eax,%r9d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:86
    crc = crc32Lookup[7][ one      & 0xFF] ^
    3fbb:	0f b6 d0             	movzbl %al,%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:87
          crc32Lookup[6][(one>> 8) & 0xFF] ^
    3fbe:	0f b6 f4             	movzbl %ah,%esi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:89
          crc32Lookup[4][ one>>24        ] ^
    3fc1:	41 c1 e9 18          	shr    $0x18,%r9d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:88
          crc32Lookup[5][(one>>16) & 0xFF] ^
    3fc5:	c1 e8 10             	shr    $0x10,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:86
    crc = crc32Lookup[7][ one      & 0xFF] ^
    3fc8:	8b 94 91 00 1c 00 00 	mov    0x1c00(%rcx,%rdx,4),%edx
    3fcf:	42 33 94 89 00 10 00 	xor    0x1000(%rcx,%r9,4),%edx
    3fd6:	00 
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:88
          crc32Lookup[5][(one>>16) & 0xFF] ^
    3fd7:	0f b6 c0             	movzbl %al,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:86
    crc = crc32Lookup[7][ one      & 0xFF] ^
    3fda:	33 94 b1 00 18 00 00 	xor    0x1800(%rcx,%rsi,4),%edx
    3fe1:	33 94 81 00 14 00 00 	xor    0x1400(%rcx,%rax,4),%edx
    3fe8:	89 d0                	mov    %edx,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:90
          crc32Lookup[3][ two      & 0xFF] ^
    3fea:	0f b6 d3             	movzbl %bl,%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:86
    crc = crc32Lookup[7][ one      & 0xFF] ^
    3fed:	33 84 91 00 0c 00 00 	xor    0xc00(%rcx,%rdx,4),%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:93
          crc32Lookup[0][ two>>24        ];
    3ff4:	89 da                	mov    %ebx,%edx
    3ff6:	c1 ea 18             	shr    $0x18,%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:86
    crc = crc32Lookup[7][ one      & 0xFF] ^
    3ff9:	33 04 91             	xor    (%rcx,%rdx,4),%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:91
          crc32Lookup[2][(two>> 8) & 0xFF] ^
    3ffc:	0f b6 d7             	movzbl %bh,%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:92
          crc32Lookup[1][(two>>16) & 0xFF] ^
    3fff:	c1 eb 10             	shr    $0x10,%ebx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:86
    crc = crc32Lookup[7][ one      & 0xFF] ^
    4002:	33 84 91 00 08 00 00 	xor    0x800(%rcx,%rdx,4),%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:92
          crc32Lookup[1][(two>>16) & 0xFF] ^
    4009:	0f b6 db             	movzbl %bl,%ebx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:86
    crc = crc32Lookup[7][ one      & 0xFF] ^
    400c:	33 84 99 00 04 00 00 	xor    0x400(%rcx,%rbx,4),%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:83
  while (length >= 8){
    4013:	4c 39 c7             	cmp    %r8,%rdi
    4016:	75 97                	jne    3faf <gen_crc32+0x2f>
    4018:	41 83 e2 07          	and    $0x7,%r10d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:98
  while (length--){
    401c:	4d 85 d2             	test   %r10,%r10
    401f:	74 24                	je     4045 <gen_crc32+0xc5>
    4021:	49 8d 34 3a          	lea    (%r10,%rdi,1),%rsi
    4025:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
			4028: R_X86_64_32S	.rodata+0x280
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:99
    crc = (crc >> 8) ^ crc32Lookup[0][(crc & 0xFF) ^ *currentChar++];
    402c:	48 83 c7 01          	add    $0x1,%rdi
    4030:	89 c2                	mov    %eax,%edx
    4032:	32 47 ff             	xor    -0x1(%rdi),%al
    4035:	c1 ea 08             	shr    $0x8,%edx
    4038:	0f b6 c0             	movzbl %al,%eax
    403b:	33 14 81             	xor    (%rcx,%rax,4),%edx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:98
  while (length--){
    403e:	48 39 f7             	cmp    %rsi,%rdi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:99
    crc = (crc >> 8) ^ crc32Lookup[0][(crc & 0xFF) ^ *currentChar++];
    4041:	89 d0                	mov    %edx,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:98
  while (length--){
    4043:	75 e7                	jne    402c <gen_crc32+0xac>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:101
  return ~crc;
    4045:	f7 d0                	not    %eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:102
}
    4047:	5b                   	pop    %rbx
    4048:	5d                   	pop    %rbp
    4049:	c3                   	retq   
    404a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000004050 <gen_crc16>:
gen_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:108
{
    4050:	e8 00 00 00 00       	callq  4055 <gen_crc16+0x5>
			4051: R_X86_64_PC32	__fentry__-0x4
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:116
    if(data == NULL)
    4055:	48 85 ff             	test   %rdi,%rdi
    4058:	74 0e                	je     4068 <gen_crc16+0x18>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:108
{
    405a:	55                   	push   %rbp
    405b:	0f b7 f6             	movzwl %si,%esi
    405e:	48 89 e5             	mov    %rsp,%rbp
    4061:	e8 2a fd ff ff       	callq  3d90 <gen_crc16.part.0>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:158
}
    4066:	5d                   	pop    %rbp
    4067:	c3                   	retq   
    4068:	31 c0                	xor    %eax,%eax
    406a:	c3                   	retq   
    406b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000004070 <check_crc32>:
check_crc32():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:160

bool check_crc32(uint32_t checksum, const void* data, size_t len){
    4070:	e8 00 00 00 00       	callq  4075 <check_crc32+0x5>
			4071: R_X86_64_PC32	__fentry__-0x4
    4075:	55                   	push   %rbp
    4076:	48 89 e5             	mov    %rsp,%rbp
    4079:	53                   	push   %rbx
    407a:	89 fb                	mov    %edi,%ebx
    407c:	48 89 f7             	mov    %rsi,%rdi
    407f:	48 89 d6             	mov    %rdx,%rsi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:161
    if(checksum == gen_crc32(data, len, 0)){
    4082:	31 d2                	xor    %edx,%edx
    4084:	e8 00 00 00 00       	callq  4089 <check_crc32+0x19>
			4085: R_X86_64_PC32	gen_crc32-0x4
    4089:	39 d8                	cmp    %ebx,%eax
    408b:	0f 94 c0             	sete   %al
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:165
        return true;
    }
    return false;
}
    408e:	5b                   	pop    %rbx
    408f:	5d                   	pop    %rbp
    4090:	c3                   	retq   
    4091:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    4096:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    409d:	00 00 00 

00000000000040a0 <check_crc16>:
check_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:167

bool check_crc16(uint16_t checksum, const void* data, size_t len){
    40a0:	e8 00 00 00 00       	callq  40a5 <check_crc16+0x5>
			40a1: R_X86_64_PC32	__fentry__-0x4
    40a5:	55                   	push   %rbp
    40a6:	31 c0                	xor    %eax,%eax
gen_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:116
    if(data == NULL)
    40a8:	48 85 f6             	test   %rsi,%rsi
check_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:167
bool check_crc16(uint16_t checksum, const void* data, size_t len){
    40ab:	48 89 e5             	mov    %rsp,%rbp
    40ae:	53                   	push   %rbx
    40af:	89 fb                	mov    %edi,%ebx
gen_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:116
    if(data == NULL)
    40b1:	74 0b                	je     40be <check_crc16+0x1e>
    40b3:	48 89 f7             	mov    %rsi,%rdi
check_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:168
    if(checksum == gen_crc16(data, len)){
    40b6:	0f b7 f2             	movzwl %dx,%esi
gen_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:168
    40b9:	e8 d2 fc ff ff       	callq  3d90 <gen_crc16.part.0>
check_crc16():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:168
    40be:	66 39 c3             	cmp    %ax,%bx
    40c1:	0f 94 c0             	sete   %al
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:172
        return true;
    }
    return false;
}
    40c4:	5b                   	pop    %rbx
    40c5:	5d                   	pop    %rbp
    40c6:	c3                   	retq   
    40c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    40ce:	00 00 

00000000000040d0 <hash_sha1>:
hash_sha1():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:181
 * 
 * @digest Array to return digest into. Needs to be pre-allocated 20 bytes.
 */
int
hash_sha1(const void *data, const uint32_t data_len, uint8_t *digest)
{
    40d0:	e8 00 00 00 00       	callq  40d5 <hash_sha1+0x5>
			40d1: R_X86_64_PC32	__fentry__-0x4
    40d5:	55                   	push   %rbp
    40d6:	48 89 e5             	mov    %rsp,%rbp
    40d9:	41 57                	push   %r15
    40db:	41 56                	push   %r14
    40dd:	41 55                	push   %r13
    40df:	41 54                	push   %r12
    40e1:	49 89 fd             	mov    %rdi,%r13
    40e4:	53                   	push   %rbx
    40e5:	41 89 f6             	mov    %esi,%r14d
    40e8:	49 89 d7             	mov    %rdx,%r15
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:187
    const char *alg_name = "sha1";
    struct crypto_shash *tfm;
    struct shash_desc *desc;
    int ret;

    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    40eb:	31 f6                	xor    %esi,%esi
    40ed:	ba 80 00 00 00       	mov    $0x80,%edx
    40f2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			40f5: R_X86_64_32S	.rodata.str1.1+0x67
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:181
{
    40f9:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:187
    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    40fd:	e8 00 00 00 00       	callq  4102 <hash_sha1+0x32>
			40fe: R_X86_64_PC32	crypto_alloc_shash-0x4
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:188
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    4102:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:187
    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    4108:	48 89 c3             	mov    %rax,%rbx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:188
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    410b:	77 60                	ja     416d <hash_sha1+0x9d>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:190

    desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
    410d:	8b 38                	mov    (%rax),%edi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    410f:	be c0 00 40 01       	mov    $0x14000c0,%esi
hash_sha1():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:190
    4114:	48 83 c7 10          	add    $0x10,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4118:	e8 00 00 00 00       	callq  411d <hash_sha1+0x4d>
			4119: R_X86_64_PC32	__kmalloc-0x4
hash_sha1():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:191
    afs_action(desc, ret = -ENOMEM, desc_done, "could not allocate desc [%d]", ret);
    411d:	48 85 c0             	test   %rax,%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4120:	49 89 c4             	mov    %rax,%r12
hash_sha1():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:191
    4123:	74 69                	je     418e <hash_sha1+0xbe>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:195

    desc->tfm = tfm;
    desc->flags = 0;
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4125:	4c 89 ee             	mov    %r13,%rsi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:193
    desc->tfm = tfm;
    4128:	48 89 18             	mov    %rbx,(%rax)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:194
    desc->flags = 0;
    412b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:195
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4132:	4c 89 f9             	mov    %r15,%rcx
    4135:	44 89 f2             	mov    %r14d,%edx
    4138:	48 89 c7             	mov    %rax,%rdi
    413b:	e8 00 00 00 00       	callq  4140 <hash_sha1+0x70>
			413c: R_X86_64_PC32	crypto_shash_digest-0x4
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:196
    afs_assert(!ret, compute_done, "error computing sha1 [%d]", ret);
    4140:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:195
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4142:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:196
    afs_assert(!ret, compute_done, "error computing sha1 [%d]", ret);
    4145:	75 6e                	jne    41b5 <hash_sha1+0xe5>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:199

compute_done:
    kfree(desc);
    4147:	4c 89 e7             	mov    %r12,%rdi
    414a:	e8 00 00 00 00       	callq  414f <hash_sha1+0x7f>
			414b: R_X86_64_PC32	kfree-0x4
crypto_shash_tfm():
/usr/src/linux-headers-4.15.0-54-generic/./include/crypto/hash.h:690
    414f:	48 8d 73 08          	lea    0x8(%rbx),%rsi
crypto_free_shash():
/usr/src/linux-headers-4.15.0-54-generic/./include/crypto/hash.h:699
    4153:	48 89 df             	mov    %rbx,%rdi
    4156:	e8 00 00 00 00       	callq  415b <hash_sha1+0x8b>
			4157: R_X86_64_PC32	crypto_destroy_tfm-0x4
hash_sha1():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:206
desc_done:
    crypto_free_shash(tfm);

tfm_done:
    return ret;
}
    415b:	48 83 c4 08          	add    $0x8,%rsp
    415f:	44 89 e8             	mov    %r13d,%eax
    4162:	5b                   	pop    %rbx
    4163:	41 5c                	pop    %r12
    4165:	41 5d                	pop    %r13
    4167:	41 5e                	pop    %r14
    4169:	41 5f                	pop    %r15
    416b:	5d                   	pop    %rbp
    416c:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:188
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    416d:	41 89 c5             	mov    %eax,%r13d
    4170:	89 c1                	mov    %eax,%ecx
    4172:	ba bc 00 00 00       	mov    $0xbc,%edx
    4177:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			417a: R_X86_64_32S	.rodata+0x260
    417e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			4181: R_X86_64_32S	.rodata.str1.8+0x1688
    4185:	31 c0                	xor    %eax,%eax
    4187:	e8 00 00 00 00       	callq  418c <hash_sha1+0xbc>
			4188: R_X86_64_PC32	printk-0x4
    418c:	eb cd                	jmp    415b <hash_sha1+0x8b>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:191 (discriminator 1)
    afs_action(desc, ret = -ENOMEM, desc_done, "could not allocate desc [%d]", ret);
    418e:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    4193:	ba bf 00 00 00       	mov    $0xbf,%edx
    4198:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			419b: R_X86_64_32S	.rodata+0x260
    419f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			41a2: R_X86_64_32S	.rodata.str1.8+0x16c0
    41a6:	31 c0                	xor    %eax,%eax
    41a8:	41 bd f4 ff ff ff    	mov    $0xfffffff4,%r13d
    41ae:	e8 00 00 00 00       	callq  41b3 <hash_sha1+0xe3>
			41af: R_X86_64_PC32	printk-0x4
    41b3:	eb 9a                	jmp    414f <hash_sha1+0x7f>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:196 (discriminator 1)
    afs_assert(!ret, compute_done, "error computing sha1 [%d]", ret);
    41b5:	89 c1                	mov    %eax,%ecx
    41b7:	ba c4 00 00 00       	mov    $0xc4,%edx
    41bc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			41bf: R_X86_64_32S	.rodata+0x260
    41c3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			41c6: R_X86_64_32S	.rodata.str1.8+0x16f8
    41ca:	31 c0                	xor    %eax,%eax
    41cc:	e8 00 00 00 00       	callq  41d1 <hash_sha1+0x101>
			41cd: R_X86_64_PC32	printk-0x4
    41d1:	e9 71 ff ff ff       	jmpq   4147 <hash_sha1+0x77>
    41d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    41dd:	00 00 00 

00000000000041e0 <hash_sha256>:
hash_sha256():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:215
 *
 * @digest Array to return digest into. Needs to be pre-allocated 32 bytes.
 */
int
hash_sha256(const void *data, const uint32_t data_len, uint8_t *digest)
{
    41e0:	e8 00 00 00 00       	callq  41e5 <hash_sha256+0x5>
			41e1: R_X86_64_PC32	__fentry__-0x4
    41e5:	55                   	push   %rbp
    41e6:	48 89 e5             	mov    %rsp,%rbp
    41e9:	41 57                	push   %r15
    41eb:	41 56                	push   %r14
    41ed:	41 55                	push   %r13
    41ef:	41 54                	push   %r12
    41f1:	49 89 fd             	mov    %rdi,%r13
    41f4:	53                   	push   %rbx
    41f5:	41 89 f6             	mov    %esi,%r14d
    41f8:	49 89 d7             	mov    %rdx,%r15
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:221
    const char *alg_name = "sha256";
    struct crypto_shash *tfm;
    struct shash_desc *desc;
    int ret;

    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    41fb:	31 f6                	xor    %esi,%esi
    41fd:	ba 80 00 00 00       	mov    $0x80,%edx
    4202:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			4205: R_X86_64_32S	.rodata.str1.1+0x6c
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:215
{
    4209:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:221
    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    420d:	e8 00 00 00 00       	callq  4212 <hash_sha256+0x32>
			420e: R_X86_64_PC32	crypto_alloc_shash-0x4
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:222
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    4212:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:221
    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    4218:	48 89 c3             	mov    %rax,%rbx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:222
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    421b:	77 60                	ja     427d <hash_sha256+0x9d>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:224

    desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
    421d:	8b 38                	mov    (%rax),%edi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    421f:	be c0 00 40 01       	mov    $0x14000c0,%esi
hash_sha256():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:224
    4224:	48 83 c7 10          	add    $0x10,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4228:	e8 00 00 00 00       	callq  422d <hash_sha256+0x4d>
			4229: R_X86_64_PC32	__kmalloc-0x4
hash_sha256():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:225
    afs_action(desc, ret = -ENOMEM, desc_done, "could not allocate desc [%d]", ret);
    422d:	48 85 c0             	test   %rax,%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4230:	49 89 c4             	mov    %rax,%r12
hash_sha256():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:225
    4233:	74 69                	je     429e <hash_sha256+0xbe>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:229

    desc->tfm = tfm;
    desc->flags = 0;
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4235:	4c 89 ee             	mov    %r13,%rsi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:227
    desc->tfm = tfm;
    4238:	48 89 18             	mov    %rbx,(%rax)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:228
    desc->flags = 0;
    423b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:229
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4242:	4c 89 f9             	mov    %r15,%rcx
    4245:	44 89 f2             	mov    %r14d,%edx
    4248:	48 89 c7             	mov    %rax,%rdi
    424b:	e8 00 00 00 00       	callq  4250 <hash_sha256+0x70>
			424c: R_X86_64_PC32	crypto_shash_digest-0x4
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:230
    afs_assert(!ret, compute_done, "error computing sha256 [%d]", ret);
    4250:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:229
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4252:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:230
    afs_assert(!ret, compute_done, "error computing sha256 [%d]", ret);
    4255:	75 6e                	jne    42c5 <hash_sha256+0xe5>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:233

compute_done:
    kfree(desc);
    4257:	4c 89 e7             	mov    %r12,%rdi
    425a:	e8 00 00 00 00       	callq  425f <hash_sha256+0x7f>
			425b: R_X86_64_PC32	kfree-0x4
crypto_shash_tfm():
/usr/src/linux-headers-4.15.0-54-generic/./include/crypto/hash.h:690
    425f:	48 8d 73 08          	lea    0x8(%rbx),%rsi
crypto_free_shash():
/usr/src/linux-headers-4.15.0-54-generic/./include/crypto/hash.h:699
    4263:	48 89 df             	mov    %rbx,%rdi
    4266:	e8 00 00 00 00       	callq  426b <hash_sha256+0x8b>
			4267: R_X86_64_PC32	crypto_destroy_tfm-0x4
hash_sha256():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:240
desc_done:
    crypto_free_shash(tfm);

tfm_done:
    return ret;
}
    426b:	48 83 c4 08          	add    $0x8,%rsp
    426f:	44 89 e8             	mov    %r13d,%eax
    4272:	5b                   	pop    %rbx
    4273:	41 5c                	pop    %r12
    4275:	41 5d                	pop    %r13
    4277:	41 5e                	pop    %r14
    4279:	41 5f                	pop    %r15
    427b:	5d                   	pop    %rbp
    427c:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:222
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    427d:	41 89 c5             	mov    %eax,%r13d
    4280:	89 c1                	mov    %eax,%ecx
    4282:	ba de 00 00 00       	mov    $0xde,%edx
    4287:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			428a: R_X86_64_32S	.rodata+0x250
    428e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			4291: R_X86_64_32S	.rodata.str1.8+0x1688
    4295:	31 c0                	xor    %eax,%eax
    4297:	e8 00 00 00 00       	callq  429c <hash_sha256+0xbc>
			4298: R_X86_64_PC32	printk-0x4
    429c:	eb cd                	jmp    426b <hash_sha256+0x8b>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:225 (discriminator 1)
    afs_action(desc, ret = -ENOMEM, desc_done, "could not allocate desc [%d]", ret);
    429e:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    42a3:	ba e1 00 00 00       	mov    $0xe1,%edx
    42a8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			42ab: R_X86_64_32S	.rodata+0x250
    42af:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			42b2: R_X86_64_32S	.rodata.str1.8+0x16c0
    42b6:	31 c0                	xor    %eax,%eax
    42b8:	41 bd f4 ff ff ff    	mov    $0xfffffff4,%r13d
    42be:	e8 00 00 00 00       	callq  42c3 <hash_sha256+0xe3>
			42bf: R_X86_64_PC32	printk-0x4
    42c3:	eb 9a                	jmp    425f <hash_sha256+0x7f>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:230 (discriminator 1)
    afs_assert(!ret, compute_done, "error computing sha256 [%d]", ret);
    42c5:	89 c1                	mov    %eax,%ecx
    42c7:	ba e6 00 00 00       	mov    $0xe6,%edx
    42cc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			42cf: R_X86_64_32S	.rodata+0x250
    42d3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			42d6: R_X86_64_32S	.rodata.str1.8+0x1730
    42da:	31 c0                	xor    %eax,%eax
    42dc:	e8 00 00 00 00       	callq  42e1 <hash_sha256+0x101>
			42dd: R_X86_64_PC32	printk-0x4
    42e1:	e9 71 ff ff ff       	jmpq   4257 <hash_sha256+0x77>
    42e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    42ed:	00 00 00 

00000000000042f0 <hash_sha512>:
hash_sha512():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:249
 *
 * @digest Array to return digest into. Needs to be pre-allocated 64 bytes.
 */
int
hash_sha512(const void *data, const uint32_t data_len, uint8_t *digest)
{
    42f0:	e8 00 00 00 00       	callq  42f5 <hash_sha512+0x5>
			42f1: R_X86_64_PC32	__fentry__-0x4
    42f5:	55                   	push   %rbp
    42f6:	48 89 e5             	mov    %rsp,%rbp
    42f9:	41 57                	push   %r15
    42fb:	41 56                	push   %r14
    42fd:	41 55                	push   %r13
    42ff:	41 54                	push   %r12
    4301:	49 89 fd             	mov    %rdi,%r13
    4304:	53                   	push   %rbx
    4305:	41 89 f6             	mov    %esi,%r14d
    4308:	49 89 d7             	mov    %rdx,%r15
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:255
    const char *alg_name = "sha512";
    struct crypto_shash *tfm;
    struct shash_desc *desc;
    int ret;

    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    430b:	31 f6                	xor    %esi,%esi
    430d:	ba 80 00 00 00       	mov    $0x80,%edx
    4312:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			4315: R_X86_64_32S	.rodata.str1.1+0x73
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:249
{
    4319:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:255
    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    431d:	e8 00 00 00 00       	callq  4322 <hash_sha512+0x32>
			431e: R_X86_64_PC32	crypto_alloc_shash-0x4
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:256
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    4322:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:255
    tfm = crypto_alloc_shash(alg_name, 0, CRYPTO_ALG_ASYNC);
    4328:	48 89 c3             	mov    %rax,%rbx
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:256
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    432b:	77 60                	ja     438d <hash_sha512+0x9d>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:258

    desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
    432d:	8b 38                	mov    (%rax),%edi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    432f:	be c0 00 40 01       	mov    $0x14000c0,%esi
hash_sha512():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:258
    4334:	48 83 c7 10          	add    $0x10,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4338:	e8 00 00 00 00       	callq  433d <hash_sha512+0x4d>
			4339: R_X86_64_PC32	__kmalloc-0x4
hash_sha512():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:259
    afs_action(desc, ret = -ENOMEM, desc_done, "could not allocate desc [%d]", ret);
    433d:	48 85 c0             	test   %rax,%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4340:	49 89 c4             	mov    %rax,%r12
hash_sha512():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:259
    4343:	74 69                	je     43ae <hash_sha512+0xbe>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:263

    desc->tfm = tfm;
    desc->flags = 0;
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4345:	4c 89 ee             	mov    %r13,%rsi
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:261
    desc->tfm = tfm;
    4348:	48 89 18             	mov    %rbx,(%rax)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:262
    desc->flags = 0;
    434b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:263
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4352:	4c 89 f9             	mov    %r15,%rcx
    4355:	44 89 f2             	mov    %r14d,%edx
    4358:	48 89 c7             	mov    %rax,%rdi
    435b:	e8 00 00 00 00       	callq  4360 <hash_sha512+0x70>
			435c: R_X86_64_PC32	crypto_shash_digest-0x4
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:264
    afs_assert(!ret, compute_done, "error computing sha512 [%d]", ret);
    4360:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:263
    ret = crypto_shash_digest(desc, data, data_len, digest);
    4362:	41 89 c5             	mov    %eax,%r13d
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:264
    afs_assert(!ret, compute_done, "error computing sha512 [%d]", ret);
    4365:	75 6e                	jne    43d5 <hash_sha512+0xe5>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:267

compute_done:
    kfree(desc);
    4367:	4c 89 e7             	mov    %r12,%rdi
    436a:	e8 00 00 00 00       	callq  436f <hash_sha512+0x7f>
			436b: R_X86_64_PC32	kfree-0x4
crypto_shash_tfm():
/usr/src/linux-headers-4.15.0-54-generic/./include/crypto/hash.h:690
    436f:	48 8d 73 08          	lea    0x8(%rbx),%rsi
crypto_free_shash():
/usr/src/linux-headers-4.15.0-54-generic/./include/crypto/hash.h:699
    4373:	48 89 df             	mov    %rbx,%rdi
    4376:	e8 00 00 00 00       	callq  437b <hash_sha512+0x8b>
			4377: R_X86_64_PC32	crypto_destroy_tfm-0x4
hash_sha512():
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:274
desc_done:
    crypto_free_shash(tfm);

tfm_done:
    return ret;
}
    437b:	48 83 c4 08          	add    $0x8,%rsp
    437f:	44 89 e8             	mov    %r13d,%eax
    4382:	5b                   	pop    %rbx
    4383:	41 5c                	pop    %r12
    4385:	41 5d                	pop    %r13
    4387:	41 5e                	pop    %r14
    4389:	41 5f                	pop    %r15
    438b:	5d                   	pop    %rbp
    438c:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:256
    afs_action(!IS_ERR(tfm), ret = PTR_ERR(tfm), tfm_done, "could not allocate tfm [%d]", ret);
    438d:	41 89 c5             	mov    %eax,%r13d
    4390:	89 c1                	mov    %eax,%ecx
    4392:	ba 00 01 00 00       	mov    $0x100,%edx
    4397:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			439a: R_X86_64_32S	.rodata+0x240
    439e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			43a1: R_X86_64_32S	.rodata.str1.8+0x1688
    43a5:	31 c0                	xor    %eax,%eax
    43a7:	e8 00 00 00 00       	callq  43ac <hash_sha512+0xbc>
			43a8: R_X86_64_PC32	printk-0x4
    43ac:	eb cd                	jmp    437b <hash_sha512+0x8b>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:259 (discriminator 1)
    afs_action(desc, ret = -ENOMEM, desc_done, "could not allocate desc [%d]", ret);
    43ae:	b9 f4 ff ff ff       	mov    $0xfffffff4,%ecx
    43b3:	ba 03 01 00 00       	mov    $0x103,%edx
    43b8:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			43bb: R_X86_64_32S	.rodata+0x240
    43bf:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			43c2: R_X86_64_32S	.rodata.str1.8+0x16c0
    43c6:	31 c0                	xor    %eax,%eax
    43c8:	41 bd f4 ff ff ff    	mov    $0xfffffff4,%r13d
    43ce:	e8 00 00 00 00       	callq  43d3 <hash_sha512+0xe3>
			43cf: R_X86_64_PC32	printk-0x4
    43d3:	eb 9a                	jmp    436f <hash_sha512+0x7f>
/home/austen/programming/dm-afs/src/dm_afs_crypto.c:264 (discriminator 1)
    afs_assert(!ret, compute_done, "error computing sha512 [%d]", ret);
    43d5:	89 c1                	mov    %eax,%ecx
    43d7:	ba 08 01 00 00       	mov    $0x108,%edx
    43dc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			43df: R_X86_64_32S	.rodata+0x240
    43e3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			43e6: R_X86_64_32S	.rodata.str1.8+0x1768
    43ea:	31 c0                	xor    %eax,%eax
    43ec:	e8 00 00 00 00       	callq  43f1 <hash_sha512+0x101>
			43ed: R_X86_64_PC32	printk-0x4
    43f1:	e9 71 ff ff ff       	jmpq   4367 <hash_sha512+0x77>
    43f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    43fd:	00 00 00 

0000000000004400 <afs_blkdev_io>:
afs_blkdev_io():
/home/austen/programming/dm-afs/src/dm_afs_io.c:21
 * @return  0       Successfully performed the I/O.
 * @return  <0      Error.
 */
int
afs_blkdev_io(struct afs_io *request)
{
    4400:	e8 00 00 00 00       	callq  4405 <afs_blkdev_io+0x5>
			4401: R_X86_64_PC32	__fentry__-0x4
    4405:	55                   	push   %rbp
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    4406:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 440d <afs_blkdev_io+0xd>
			4409: R_X86_64_PC32	fs_bio_set-0x4
    440d:	be 01 00 00 00       	mov    $0x1,%esi
afs_blkdev_io():
/home/austen/programming/dm-afs/src/dm_afs_io.c:21
    4412:	48 89 e5             	mov    %rsp,%rbp
    4415:	41 54                	push   %r12
    4417:	53                   	push   %rbx
    4418:	49 89 fc             	mov    %rdi,%r12
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    441b:	bf 00 00 40 01       	mov    $0x1400000,%edi
    4420:	e8 00 00 00 00       	callq  4425 <afs_blkdev_io+0x25>
			4421: R_X86_64_PC32	bio_alloc_bioset-0x4
afs_blkdev_io():
/home/austen/programming/dm-afs/src/dm_afs_io.c:27
    const int page_offset = 0;
    int ret;
    struct bio *bio = NULL;

    bio = bio_alloc(GFP_NOIO, 1);
    afs_action(!IS_ERR(bio), ret = PTR_ERR(bio), alloc_err, "could not allocate bio [%d]", ret);
    4425:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
bio_alloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:410
    442b:	48 89 c3             	mov    %rax,%rbx
afs_blkdev_io():
/home/austen/programming/dm-afs/src/dm_afs_io.c:27
    442e:	77 7f                	ja     44af <afs_blkdev_io+0xaf>
/home/austen/programming/dm-afs/src/dm_afs_io.c:29

    switch (request->type) {
    4430:	41 8b 4c 24 1c       	mov    0x1c(%r12),%ecx
    4435:	85 c9                	test   %ecx,%ecx
    4437:	74 0d                	je     4446 <afs_blkdev_io+0x46>
    4439:	83 f9 01             	cmp    $0x1,%ecx
    443c:	0f 85 94 00 00 00    	jne    44d6 <afs_blkdev_io+0xd6>
/home/austen/programming/dm-afs/src/dm_afs_io.c:35
    case IO_READ:
        bio->bi_opf |= REQ_OP_READ;
        break;

    case IO_WRITE:
        bio->bi_opf |= REQ_OP_WRITE;
    4442:	83 48 10 01          	orl    $0x1,0x10(%rax)
/home/austen/programming/dm-afs/src/dm_afs_io.c:42

    default:
        afs_action(0, ret = -EINVAL, invalid_type, "invalid IO type [%d]", request->type);
    }

    bio_set_dev(bio, request->bdev);
    4446:	49 8b 04 24          	mov    (%r12),%rax
    444a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
    4451:	48 39 43 08          	cmp    %rax,0x8(%rbx)
    4455:	74 11                	je     4468 <afs_blkdev_io+0x68>
bio_clear_flag():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/bio.h:273 (discriminator 1)
    4457:	66 81 63 14 ff fd    	andw   $0xfdff,0x14(%rbx)
    445d:	49 8b 04 24          	mov    (%r12),%rax
    4461:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
afs_blkdev_io():
/home/austen/programming/dm-afs/src/dm_afs_io.c:42 (discriminator 3)
    4468:	48 89 43 08          	mov    %rax,0x8(%rbx)
    446c:	49 8b 04 24          	mov    (%r12),%rax
/home/austen/programming/dm-afs/src/dm_afs_io.c:44 (discriminator 3)
    bio->bi_iter.bi_sector = request->io_sector;
    bio_add_page(bio, request->io_page, request->io_size, page_offset);
    4470:	31 c9                	xor    %ecx,%ecx
    4472:	48 89 df             	mov    %rbx,%rdi
/home/austen/programming/dm-afs/src/dm_afs_io.c:42 (discriminator 3)
    bio_set_dev(bio, request->bdev);
    4475:	0f b6 40 6c          	movzbl 0x6c(%rax),%eax
    4479:	88 43 1b             	mov    %al,0x1b(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_io.c:43 (discriminator 3)
    bio->bi_iter.bi_sector = request->io_sector;
    447c:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    4481:	48 89 43 28          	mov    %rax,0x28(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_io.c:44 (discriminator 3)
    bio_add_page(bio, request->io_page, request->io_size, page_offset);
    4485:	41 8b 54 24 18       	mov    0x18(%r12),%edx
    448a:	49 8b 74 24 08       	mov    0x8(%r12),%rsi
/home/austen/programming/dm-afs/src/dm_afs_io.c:48 (discriminator 3)

    submit_bio_wait(bio);
    kfree(bio);
    return 0;
    448f:	45 31 e4             	xor    %r12d,%r12d
/home/austen/programming/dm-afs/src/dm_afs_io.c:44 (discriminator 3)
    bio_add_page(bio, request->io_page, request->io_size, page_offset);
    4492:	e8 00 00 00 00       	callq  4497 <afs_blkdev_io+0x97>
			4493: R_X86_64_PC32	bio_add_page-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:46 (discriminator 3)
    submit_bio_wait(bio);
    4497:	48 89 df             	mov    %rbx,%rdi
    449a:	e8 00 00 00 00       	callq  449f <afs_blkdev_io+0x9f>
			449b: R_X86_64_PC32	submit_bio_wait-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:47 (discriminator 3)
    kfree(bio);
    449f:	48 89 df             	mov    %rbx,%rdi
    44a2:	e8 00 00 00 00       	callq  44a7 <afs_blkdev_io+0xa7>
			44a3: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:55
invalid_type:
    bio_endio(bio);

alloc_err:
    return ret;
}
    44a7:	44 89 e0             	mov    %r12d,%eax
    44aa:	5b                   	pop    %rbx
    44ab:	41 5c                	pop    %r12
    44ad:	5d                   	pop    %rbp
    44ae:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_io.c:27
    afs_action(!IS_ERR(bio), ret = PTR_ERR(bio), alloc_err, "could not allocate bio [%d]", ret);
    44af:	41 89 c4             	mov    %eax,%r12d
    44b2:	89 c1                	mov    %eax,%ecx
    44b4:	ba 1b 00 00 00       	mov    $0x1b,%edx
    44b9:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			44bc: R_X86_64_32S	.rodata+0x22a0
    44c0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			44c3: R_X86_64_32S	.rodata.str1.8+0x17a0
    44c7:	31 c0                	xor    %eax,%eax
    44c9:	e8 00 00 00 00       	callq  44ce <afs_blkdev_io+0xce>
			44ca: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:55
}
    44ce:	44 89 e0             	mov    %r12d,%eax
    44d1:	5b                   	pop    %rbx
    44d2:	41 5c                	pop    %r12
    44d4:	5d                   	pop    %rbp
    44d5:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_io.c:39 (discriminator 1)
        afs_action(0, ret = -EINVAL, invalid_type, "invalid IO type [%d]", request->type);
    44d6:	ba 27 00 00 00       	mov    $0x27,%edx
    44db:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			44de: R_X86_64_32S	.rodata+0x22a0
    44e2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			44e5: R_X86_64_32S	.rodata.str1.8+0x17d8
    44e9:	31 c0                	xor    %eax,%eax
    44eb:	41 bc ea ff ff ff    	mov    $0xffffffea,%r12d
    44f1:	e8 00 00 00 00       	callq  44f6 <afs_blkdev_io+0xf6>
			44f2: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:51 (discriminator 1)
    bio_endio(bio);
    44f6:	48 89 df             	mov    %rbx,%rdi
    44f9:	e8 00 00 00 00       	callq  44fe <afs_blkdev_io+0xfe>
			44fa: R_X86_64_PC32	bio_endio-0x4
    44fe:	eb a7                	jmp    44a7 <afs_blkdev_io+0xa7>

0000000000004500 <read_page>:
read_page():
/home/austen/programming/dm-afs/src/dm_afs_io.c:62
/**
 * Read a single page.
 */
int
read_page(void *page, struct block_device *bdev, uint32_t block_num, uint32_t sector_offset, bool used_vmalloc)
{
    4500:	e8 00 00 00 00       	callq  4505 <read_page+0x5>
			4501: R_X86_64_PC32	__fentry__-0x4
    4505:	55                   	push   %rbp
    4506:	48 89 e5             	mov    %rsp,%rbp
    4509:	53                   	push   %rbx
    450a:	48 83 ec 48          	sub    $0x48,%rsp
    450e:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    4515:	00 00 
    4517:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    451b:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_io.c:69
    struct page *page_structure;
    uint64_t sector_num;
    int ret;

    // Make sure page is aligned.
    afs_action(!((uint64_t)page & (AFS_BLOCK_SIZE - 1)), ret = -EINVAL, done, "page is not aligned [%d]", ret);
    451d:	f7 c7 ff 0f 00 00    	test   $0xfff,%edi
    4523:	0f 85 98 00 00 00    	jne    45c1 <read_page+0xc1>
/home/austen/programming/dm-afs/src/dm_afs_io.c:72

    // Acquire page structure and sector offset.
    page_structure = (used_vmalloc) ? vmalloc_to_page(page) : virt_to_page(page);
    4529:	45 84 c0             	test   %r8b,%r8b
    452c:	75 78                	jne    45a6 <read_page+0xa6>
    452e:	b8 00 00 00 80       	mov    $0x80000000,%eax
    4533:	48 01 c7             	add    %rax,%rdi
    4536:	0f 82 cc 00 00 00    	jb     4608 <read_page+0x108>
__phys_addr_nodebug():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19
    453c:	48 c7 c0 00 00 00 80 	mov    $0xffffffff80000000,%rax
    4543:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # 454a <read_page+0x4a>
			4546: R_X86_64_PC32	page_offset_base-0x4
    454a:	48 01 f8             	add    %rdi,%rax
read_page():
/home/austen/programming/dm-afs/src/dm_afs_io.c:72
    454d:	48 c1 e8 0c          	shr    $0xc,%rax
    4551:	48 c1 e0 06          	shl    $0x6,%rax
    4555:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # 455c <read_page+0x5c>
			4558: R_X86_64_PC32	vmemmap_base-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:73 (discriminator 4)
    sector_num = ((block_num * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE) + sector_offset;
    455c:	c1 e2 0c             	shl    $0xc,%edx
/home/austen/programming/dm-afs/src/dm_afs_io.c:77 (discriminator 4)

    // Build the request.
    request.bdev = bdev;
    request.io_page = page_structure;
    455f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:82 (discriminator 4)
    request.io_sector = sector_num;
    request.io_size = AFS_BLOCK_SIZE;
    request.type = IO_READ;

    ret = afs_blkdev_io(&request);
    4563:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
/home/austen/programming/dm-afs/src/dm_afs_io.c:73 (discriminator 4)
    sector_num = ((block_num * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE) + sector_offset;
    4567:	c1 ea 09             	shr    $0x9,%edx
/home/austen/programming/dm-afs/src/dm_afs_io.c:76 (discriminator 4)
    request.bdev = bdev;
    456a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:79 (discriminator 4)
    request.io_size = AFS_BLOCK_SIZE;
    456e:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:73 (discriminator 4)
    sector_num = ((block_num * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE) + sector_offset;
    4575:	8d 04 11             	lea    (%rcx,%rdx,1),%eax
/home/austen/programming/dm-afs/src/dm_afs_io.c:80 (discriminator 4)
    request.type = IO_READ;
    4578:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:73 (discriminator 4)
    sector_num = ((block_num * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE) + sector_offset;
    457f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:82 (discriminator 4)
    ret = afs_blkdev_io(&request);
    4583:	e8 00 00 00 00       	callq  4588 <read_page+0x88>
			4584: R_X86_64_PC32	afs_blkdev_io-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:83 (discriminator 4)
    afs_assert(!ret, done, "error in reading block device [%d]", ret);
    4588:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_io.c:82 (discriminator 4)
    ret = afs_blkdev_io(&request);
    458a:	89 c3                	mov    %eax,%ebx
/home/austen/programming/dm-afs/src/dm_afs_io.c:83 (discriminator 4)
    afs_assert(!ret, done, "error in reading block device [%d]", ret);
    458c:	75 5c                	jne    45ea <read_page+0xea>
/home/austen/programming/dm-afs/src/dm_afs_io.c:87

done:
    return ret;
}
    458e:	89 d8                	mov    %ebx,%eax
    4590:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
    4594:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    459b:	00 00 
    459d:	75 46                	jne    45e5 <read_page+0xe5>
    459f:	48 83 c4 48          	add    $0x48,%rsp
    45a3:	5b                   	pop    %rbx
    45a4:	5d                   	pop    %rbp
    45a5:	c3                   	retq   
    45a6:	89 4d b0             	mov    %ecx,-0x50(%rbp)
    45a9:	89 55 b4             	mov    %edx,-0x4c(%rbp)
    45ac:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:72 (discriminator 1)
    page_structure = (used_vmalloc) ? vmalloc_to_page(page) : virt_to_page(page);
    45b0:	e8 00 00 00 00       	callq  45b5 <read_page+0xb5>
			45b1: R_X86_64_PC32	vmalloc_to_page-0x4
    45b5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    45b9:	8b 55 b4             	mov    -0x4c(%rbp),%edx
    45bc:	8b 4d b0             	mov    -0x50(%rbp),%ecx
    45bf:	eb 9b                	jmp    455c <read_page+0x5c>
/home/austen/programming/dm-afs/src/dm_afs_io.c:69 (discriminator 1)
    afs_action(!((uint64_t)page & (AFS_BLOCK_SIZE - 1)), ret = -EINVAL, done, "page is not aligned [%d]", ret);
    45c1:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
    45c6:	ba 45 00 00 00       	mov    $0x45,%edx
    45cb:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			45ce: R_X86_64_32S	.rodata+0x2290
    45d2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			45d5: R_X86_64_32S	.rodata.str1.8+0x1808
    45d9:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
    45de:	e8 00 00 00 00       	callq  45e3 <read_page+0xe3>
			45df: R_X86_64_PC32	printk-0x4
    45e3:	eb a9                	jmp    458e <read_page+0x8e>
/home/austen/programming/dm-afs/src/dm_afs_io.c:87
}
    45e5:	e8 00 00 00 00       	callq  45ea <read_page+0xea>
			45e6: R_X86_64_PC32	__stack_chk_fail-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:83 (discriminator 1)
    afs_assert(!ret, done, "error in reading block device [%d]", ret);
    45ea:	89 c1                	mov    %eax,%ecx
    45ec:	ba 53 00 00 00       	mov    $0x53,%edx
    45f1:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			45f4: R_X86_64_32S	.rodata+0x2290
    45f8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			45fb: R_X86_64_32S	.rodata.str1.8+0x1840
    45ff:	31 c0                	xor    %eax,%eax
    4601:	e8 00 00 00 00       	callq  4606 <read_page+0x106>
			4602: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:86 (discriminator 1)
    return ret;
    4606:	eb 86                	jmp    458e <read_page+0x8e>
__phys_addr_nodebug():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19 (discriminator 2)
    4608:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 460f <read_page+0x10f>
			460b: R_X86_64_PC32	phys_base-0x4
    460f:	e9 36 ff ff ff       	jmpq   454a <read_page+0x4a>
read_page():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19 (discriminator 2)
    4614:	66 90                	xchg   %ax,%ax
    4616:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    461d:	00 00 00 

0000000000004620 <write_page>:
write_page():
/home/austen/programming/dm-afs/src/dm_afs_io.c:94
/**
 * Write a single page.
 */
int
write_page(const void *page, struct block_device *bdev, uint32_t block_num, uint32_t sector_offset, bool used_vmalloc)
{
    4620:	e8 00 00 00 00       	callq  4625 <write_page+0x5>
			4621: R_X86_64_PC32	__fentry__-0x4
    4625:	55                   	push   %rbp
    4626:	48 89 e5             	mov    %rsp,%rbp
    4629:	53                   	push   %rbx
    462a:	48 83 ec 48          	sub    $0x48,%rsp
    462e:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    4635:	00 00 
    4637:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    463b:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_io.c:101
    struct page *page_structure;
    uint64_t sector_num;
    int ret;

    // Make sure page is aligned.
    afs_action(!((uint64_t)page & (AFS_BLOCK_SIZE - 1)), ret = -EINVAL, done, "page is not aligned [%d]", ret);
    463d:	f7 c7 ff 0f 00 00    	test   $0xfff,%edi
    4643:	0f 85 98 00 00 00    	jne    46e1 <write_page+0xc1>
/home/austen/programming/dm-afs/src/dm_afs_io.c:104

    // Acquire page structure and sector offset.
    page_structure = (used_vmalloc) ? vmalloc_to_page(page) : virt_to_page(page);
    4649:	45 84 c0             	test   %r8b,%r8b
    464c:	75 78                	jne    46c6 <write_page+0xa6>
    464e:	b8 00 00 00 80       	mov    $0x80000000,%eax
    4653:	48 01 c7             	add    %rax,%rdi
    4656:	0f 82 cc 00 00 00    	jb     4728 <write_page+0x108>
__phys_addr_nodebug():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19
    465c:	48 c7 c0 00 00 00 80 	mov    $0xffffffff80000000,%rax
    4663:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # 466a <write_page+0x4a>
			4666: R_X86_64_PC32	page_offset_base-0x4
    466a:	48 01 f8             	add    %rdi,%rax
write_page():
/home/austen/programming/dm-afs/src/dm_afs_io.c:104
    466d:	48 c1 e8 0c          	shr    $0xc,%rax
    4671:	48 c1 e0 06          	shl    $0x6,%rax
    4675:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # 467c <write_page+0x5c>
			4678: R_X86_64_PC32	vmemmap_base-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:105 (discriminator 4)
    sector_num = ((block_num * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE)  + sector_offset;
    467c:	c1 e2 0c             	shl    $0xc,%edx
/home/austen/programming/dm-afs/src/dm_afs_io.c:109 (discriminator 4)

    // Build the request.
    request.bdev = bdev;
    request.io_page = page_structure;
    467f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:114 (discriminator 4)
    request.io_sector = sector_num;
    request.io_size = AFS_BLOCK_SIZE;
    request.type = IO_WRITE;

    ret = afs_blkdev_io(&request);
    4683:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
/home/austen/programming/dm-afs/src/dm_afs_io.c:105 (discriminator 4)
    sector_num = ((block_num * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE)  + sector_offset;
    4687:	c1 ea 09             	shr    $0x9,%edx
/home/austen/programming/dm-afs/src/dm_afs_io.c:108 (discriminator 4)
    request.bdev = bdev;
    468a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:111 (discriminator 4)
    request.io_size = AFS_BLOCK_SIZE;
    468e:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:105 (discriminator 4)
    sector_num = ((block_num * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE)  + sector_offset;
    4695:	8d 04 11             	lea    (%rcx,%rdx,1),%eax
/home/austen/programming/dm-afs/src/dm_afs_io.c:112 (discriminator 4)
    request.type = IO_WRITE;
    4698:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:105 (discriminator 4)
    sector_num = ((block_num * AFS_BLOCK_SIZE) / AFS_SECTOR_SIZE)  + sector_offset;
    469f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:114 (discriminator 4)
    ret = afs_blkdev_io(&request);
    46a3:	e8 00 00 00 00       	callq  46a8 <write_page+0x88>
			46a4: R_X86_64_PC32	afs_blkdev_io-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:115 (discriminator 4)
    afs_assert(!ret, done, "error in writing block device [%d]", ret);
    46a8:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_io.c:114 (discriminator 4)
    ret = afs_blkdev_io(&request);
    46aa:	89 c3                	mov    %eax,%ebx
/home/austen/programming/dm-afs/src/dm_afs_io.c:115 (discriminator 4)
    afs_assert(!ret, done, "error in writing block device [%d]", ret);
    46ac:	75 5c                	jne    470a <write_page+0xea>
/home/austen/programming/dm-afs/src/dm_afs_io.c:119

done:
    return ret;
}
    46ae:	89 d8                	mov    %ebx,%eax
    46b0:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
    46b4:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    46bb:	00 00 
    46bd:	75 46                	jne    4705 <write_page+0xe5>
    46bf:	48 83 c4 48          	add    $0x48,%rsp
    46c3:	5b                   	pop    %rbx
    46c4:	5d                   	pop    %rbp
    46c5:	c3                   	retq   
    46c6:	89 4d b0             	mov    %ecx,-0x50(%rbp)
    46c9:	89 55 b4             	mov    %edx,-0x4c(%rbp)
    46cc:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_io.c:104 (discriminator 1)
    page_structure = (used_vmalloc) ? vmalloc_to_page(page) : virt_to_page(page);
    46d0:	e8 00 00 00 00       	callq  46d5 <write_page+0xb5>
			46d1: R_X86_64_PC32	vmalloc_to_page-0x4
    46d5:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    46d9:	8b 55 b4             	mov    -0x4c(%rbp),%edx
    46dc:	8b 4d b0             	mov    -0x50(%rbp),%ecx
    46df:	eb 9b                	jmp    467c <write_page+0x5c>
/home/austen/programming/dm-afs/src/dm_afs_io.c:101 (discriminator 1)
    afs_action(!((uint64_t)page & (AFS_BLOCK_SIZE - 1)), ret = -EINVAL, done, "page is not aligned [%d]", ret);
    46e1:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
    46e6:	ba 65 00 00 00       	mov    $0x65,%edx
    46eb:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			46ee: R_X86_64_32S	.rodata+0x2280
    46f2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			46f5: R_X86_64_32S	.rodata.str1.8+0x1808
    46f9:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
    46fe:	e8 00 00 00 00       	callq  4703 <write_page+0xe3>
			46ff: R_X86_64_PC32	printk-0x4
    4703:	eb a9                	jmp    46ae <write_page+0x8e>
/home/austen/programming/dm-afs/src/dm_afs_io.c:119
}
    4705:	e8 00 00 00 00       	callq  470a <write_page+0xea>
			4706: R_X86_64_PC32	__stack_chk_fail-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:115 (discriminator 1)
    afs_assert(!ret, done, "error in writing block device [%d]", ret);
    470a:	89 c1                	mov    %eax,%ecx
    470c:	ba 73 00 00 00       	mov    $0x73,%edx
    4711:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			4714: R_X86_64_32S	.rodata+0x2280
    4718:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			471b: R_X86_64_32S	.rodata.str1.8+0x1880
    471f:	31 c0                	xor    %eax,%eax
    4721:	e8 00 00 00 00       	callq  4726 <write_page+0x106>
			4722: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_io.c:118 (discriminator 1)
    return ret;
    4726:	eb 86                	jmp    46ae <write_page+0x8e>
__phys_addr_nodebug():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/page_64.h:19 (discriminator 2)
    4728:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 472f <write_page+0x10f>
			472b: R_X86_64_PC32	phys_base-0x4
    472f:	e9 36 ff ff ff       	jmpq   466a <write_page+0x4a>
write_page():
    4734:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    473b:	00 00 00 
    473e:	66 90                	xchg   %ax,%ax

0000000000004740 <djb2_hash>:
djb2_hash():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:31

/**
 * Damn black magic
 * http://www.cse.yorku.ca/~oz/hash.html
 */
uint64_t djb2_hash(unsigned char *str){
    4740:	e8 00 00 00 00       	callq  4745 <djb2_hash+0x5>
			4741: R_X86_64_PC32	__fentry__-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    unsigned long hash = 5381;
    int c;

    while((c = *str++)){
    4745:	0f b6 17             	movzbl (%rdi),%edx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:31
uint64_t djb2_hash(unsigned char *str){
    4748:	55                   	push   %rbp
    4749:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    474c:	84 d2                	test   %dl,%dl
    474e:	74 24                	je     4774 <djb2_hash+0x34>
    4750:	48 8d 77 01          	lea    0x1(%rdi),%rsi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:32
    unsigned long hash = 5381;
    4754:	b8 05 15 00 00       	mov    $0x1505,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:36
        hash = ((hash << 5) + hash) + c;
    4759:	48 89 c1             	mov    %rax,%rcx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    475c:	48 83 c6 01          	add    $0x1,%rsi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:36
        hash = ((hash << 5) + hash) + c;
    4760:	48 c1 e1 05          	shl    $0x5,%rcx
    4764:	48 01 ca             	add    %rcx,%rdx
    4767:	48 01 d0             	add    %rdx,%rax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    476a:	0f b6 56 ff          	movzbl -0x1(%rsi),%edx
    476e:	84 d2                	test   %dl,%dl
    4770:	75 e7                	jne    4759 <djb2_hash+0x19>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:39
    }
    return hash;
}
    4772:	5d                   	pop    %rbp
    4773:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:32
    unsigned long hash = 5381;
    4774:	b8 05 15 00 00       	mov    $0x1505,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:39
}
    4779:	5d                   	pop    %rbp
    477a:	c3                   	retq   
    477b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000004780 <file_open>:
file_open():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:44

/**
 * Helper function for opening a file in the kernel
 */
struct file* file_open(char* path, int flags, int rights){
    4780:	e8 00 00 00 00       	callq  4785 <file_open+0x5>
			4781: R_X86_64_PC32	__fentry__-0x4
    4785:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:46
    struct file *filp = NULL;
    filp = filp_open(path, flags, rights);
    4786:	0f b7 d2             	movzwl %dx,%edx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:44
struct file* file_open(char* path, int flags, int rights){
    4789:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:46
    filp = filp_open(path, flags, rights);
    478c:	e8 00 00 00 00       	callq  4791 <file_open+0x11>
			478d: R_X86_64_PC32	filp_open-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:48
    return filp;
}
    4791:	5d                   	pop    %rbp
    4792:	c3                   	retq   
    4793:	0f 1f 00             	nopl   (%rax)
    4796:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    479d:	00 00 00 

00000000000047a0 <file_close>:
file_close():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:53

/**
 * Closing a file in the kernel
 */
void file_close(struct file* file){
    47a0:	e8 00 00 00 00       	callq  47a5 <file_close+0x5>
			47a1: R_X86_64_PC32	__fentry__-0x4
    47a5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:54
    filp_close(file, NULL);
    47a6:	31 f6                	xor    %esi,%esi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:53
void file_close(struct file* file){
    47a8:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:54
    filp_close(file, NULL);
    47ab:	e8 00 00 00 00       	callq  47b0 <file_close+0x10>
			47ac: R_X86_64_PC32	filp_close-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:55
}
    47b0:	5d                   	pop    %rbp
    47b1:	c3                   	retq   
    47b2:	0f 1f 40 00          	nopl   0x0(%rax)
    47b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    47bd:	00 00 00 

00000000000047c0 <insert_entropy_ht>:
insert_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:63
/**
 * Insert something into the entropy hash table
 * vfs_llseek() causes a seg fault
 * vfs_stat() seems to work
 */
int insert_entropy_ht(char *filename){
    47c0:	e8 00 00 00 00       	callq  47c5 <insert_entropy_ht+0x5>
			47c1: R_X86_64_PC32	__fentry__-0x4
    47c5:	55                   	push   %rbp
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    47c6:	ba 28 00 00 00       	mov    $0x28,%edx
    47cb:	be c0 00 40 01       	mov    $0x14000c0,%esi
insert_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:63
    47d0:	48 89 e5             	mov    %rsp,%rbp
    47d3:	41 54                	push   %r12
    47d5:	53                   	push   %rbx
    47d6:	49 89 fc             	mov    %rdi,%r12
    47d9:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    47e0:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 47e7 <insert_entropy_ht+0x27>
			47e3: R_X86_64_PC32	kmalloc_caches+0x2c
insert_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:63
    47e7:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    47ee:	00 00 
    47f0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    47f4:	31 c0                	xor    %eax,%eax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    47f6:	e8 00 00 00 00       	callq  47fb <insert_entropy_ht+0x3b>
			47f7: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
insert_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:69
    uint64_t filename_hash = 0;
    struct kstat stat;
    struct path p;
    struct entropy_hash_entry *entry = kmalloc(sizeof(struct entropy_hash_entry), GFP_KERNEL);

    if(!filename){
    47fb:	4d 85 e4             	test   %r12,%r12
    47fe:	0f 84 cb 00 00 00    	je     48cf <insert_entropy_ht+0x10f>
    4804:	48 89 c3             	mov    %rax,%rbx
djb2_hash():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    4807:	41 0f b6 04 24       	movzbl (%r12),%eax
    480c:	49 8d 74 24 01       	lea    0x1(%r12),%rsi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:32
    unsigned long hash = 5381;
    4811:	b9 05 15 00 00       	mov    $0x1505,%ecx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    4816:	84 c0                	test   %al,%al
    4818:	74 19                	je     4833 <insert_entropy_ht+0x73>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:36
        hash = ((hash << 5) + hash) + c;
    481a:	48 89 ca             	mov    %rcx,%rdx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    481d:	48 83 c6 01          	add    $0x1,%rsi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:36
        hash = ((hash << 5) + hash) + c;
    4821:	48 c1 e2 05          	shl    $0x5,%rdx
    4825:	48 01 d0             	add    %rdx,%rax
    4828:	48 01 c1             	add    %rax,%rcx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    482b:	0f b6 46 ff          	movzbl -0x1(%rsi),%eax
    482f:	84 c0                	test   %al,%al
    4831:	75 e7                	jne    481a <insert_entropy_ht+0x5a>
insert_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:78
    filename_hash = djb2_hash(filename);
    
    entry->key = filename_hash;
    entry->filename = filename;

    kern_path(filename, LOOKUP_FOLLOW, &p);
    4833:	48 8d 95 50 ff ff ff 	lea    -0xb0(%rbp),%rdx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:75
    entry->key = filename_hash;
    483a:	48 89 0b             	mov    %rcx,(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:78
    kern_path(filename, LOOKUP_FOLLOW, &p);
    483d:	4c 89 e7             	mov    %r12,%rdi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:76
    entry->filename = filename;
    4840:	4c 89 63 08          	mov    %r12,0x8(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:78
    kern_path(filename, LOOKUP_FOLLOW, &p);
    4844:	be 01 00 00 00       	mov    $0x1,%esi
    4849:	e8 00 00 00 00       	callq  484e <insert_entropy_ht+0x8e>
			484a: R_X86_64_PC32	kern_path-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:79
    vfs_getattr(&p, &stat, STATX_ALL, KSTAT_QUERY_FLAGS);
    484e:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
    4855:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi
    485c:	b9 00 60 00 00       	mov    $0x6000,%ecx
    4861:	ba ff 0f 00 00       	mov    $0xfff,%edx
    4866:	e8 00 00 00 00       	callq  486b <insert_entropy_ht+0xab>
			4867: R_X86_64_PC32	vfs_getattr-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:80
    entry->file_size = stat.size;
    486b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:82

    hash_add_64(HASH_TABLE_NAME, &entry->hash_list, entry->key);
    486f:	48 8d 4b 18          	lea    0x18(%rbx),%rcx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:80
    entry->file_size = stat.size;
    4873:	48 89 43 10          	mov    %rax,0x10(%rbx)
hash_64_generic():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/hash.h:81
    4877:	48 b8 eb 83 b5 80 46 	movabs $0x61c8864680b583eb,%rax
    487e:	86 c8 61 
    4881:	48 0f af 03          	imul   (%rbx),%rax
    4885:	48 c1 e8 30          	shr    $0x30,%rax
hlist_add_head_rcu():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/rculist.h:480
    4889:	48 8b 14 c5 00 00 00 	mov    0x0(,%rax,8),%rdx
    4890:	00 
			488d: R_X86_64_32S	dm_afs_ht
insert_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:82
    hash_add_64(HASH_TABLE_NAME, &entry->hash_list, entry->key);
    4891:	48 8d 34 c5 00 00 00 	lea    0x0(,%rax,8),%rsi
    4898:	00 
			4895: R_X86_64_32S	dm_afs_ht
hlist_add_head_rcu():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/rculist.h:483
    4899:	48 89 73 20          	mov    %rsi,0x20(%rbx)
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/rculist.h:482
    489d:	48 89 53 18          	mov    %rdx,0x18(%rbx)
__write_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:217
    48a1:	48 89 0c c5 00 00 00 	mov    %rcx,0x0(,%rax,8)
    48a8:	00 
			48a5: R_X86_64_32S	dm_afs_ht
insert_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:83
    return 0;
    48a9:	31 c0                	xor    %eax,%eax
hlist_add_head_rcu():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/rculist.h:485
    48ab:	48 85 d2             	test   %rdx,%rdx
    48ae:	74 04                	je     48b4 <insert_entropy_ht+0xf4>
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/rculist.h:486
    48b0:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
insert_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:84
}
    48b4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
    48b8:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    48bf:	00 00 
    48c1:	75 1f                	jne    48e2 <insert_entropy_ht+0x122>
    48c3:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    48ca:	5b                   	pop    %rbx
    48cb:	41 5c                	pop    %r12
    48cd:	5d                   	pop    %rbp
    48ce:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:70
        printk(KERN_INFO "Filename Null\n");
    48cf:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			48d2: R_X86_64_32S	.rodata.str1.1+0x7a
    48d6:	31 c0                	xor    %eax,%eax
    48d8:	e8 00 00 00 00       	callq  48dd <insert_entropy_ht+0x11d>
			48d9: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:71
	return -1;
    48dd:	83 c8 ff             	or     $0xffffffff,%eax
    48e0:	eb d2                	jmp    48b4 <insert_entropy_ht+0xf4>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:84
}
    48e2:	e8 00 00 00 00       	callq  48e7 <insert_entropy_ht+0x127>
			48e3: R_X86_64_PC32	__stack_chk_fail-0x4
    48e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    48ee:	00 00 

00000000000048f0 <dm_afs_filldir>:
dm_afs_filldir():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:91
/**
 * Filldir function
 * Does the heavy lifting when iterating through a directory
 * Need to make it recursive
 */
static int dm_afs_filldir(struct dir_context *context, const char *name, int name_length, loff_t offset, u64 ino, unsigned d_type){
    48f0:	e8 00 00 00 00       	callq  48f5 <dm_afs_filldir+0x5>
			48f1: R_X86_64_PC32	__fentry__-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:93

    if(ent_context.number_of_files < FILE_LIST_SIZE){
    48f5:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 48fb <dm_afs_filldir+0xb>
			48f7: R_X86_64_PC32	.bss+0x8001c
    48fb:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    4900:	0f 87 c1 00 00 00    	ja     49c7 <dm_afs_filldir+0xd7>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:91
static int dm_afs_filldir(struct dir_context *context, const char *name, int name_length, loff_t offset, u64 ino, unsigned d_type){
    4906:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:94
        size_t full_path_size = name_length + ent_context.directory_name_length + 2;
    4907:	48 63 d2             	movslq %edx,%rdx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:91
static int dm_afs_filldir(struct dir_context *context, const char *name, int name_length, loff_t offset, u64 ino, unsigned d_type){
    490a:	48 89 e5             	mov    %rsp,%rbp
    490d:	41 55                	push   %r13
    490f:	41 54                	push   %r12
    4911:	53                   	push   %rbx
    4912:	48 89 f3             	mov    %rsi,%rbx
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4915:	be c0 00 40 01       	mov    $0x14000c0,%esi
dm_afs_filldir():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:91
    491a:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:94
        size_t full_path_size = name_length + ent_context.directory_name_length + 2;
    491e:	48 8b 0d 00 00 00 00 	mov    0x0(%rip),%rcx        # 4925 <dm_afs_filldir+0x35>
			4921: R_X86_64_PC32	.bss+0x8002c
    4925:	4c 8d 64 11 02       	lea    0x2(%rcx,%rdx,1),%r12
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:95
        ent_context.file_list[ent_context.number_of_files] = kmalloc(sizeof(char) * (full_path_size), GFP_KERNEL);
    492a:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 4931 <dm_afs_filldir+0x41>
			492d: R_X86_64_PC32	.bss+0x80034
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4931:	4c 89 e7             	mov    %r12,%rdi
dm_afs_filldir():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:95
    4934:	4c 8d 2c c2          	lea    (%rdx,%rax,8),%r13
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4938:	e8 00 00 00 00       	callq  493d <dm_afs_filldir+0x4d>
			4939: R_X86_64_PC32	__kmalloc-0x4
dm_afs_filldir():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:96
	strlcpy(ent_context.file_list[ent_context.number_of_files], ent_context.directory_name, full_path_size);
    493d:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 4943 <dm_afs_filldir+0x53>
			493f: R_X86_64_PC32	.bss+0x8001c
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:95
        ent_context.file_list[ent_context.number_of_files] = kmalloc(sizeof(char) * (full_path_size), GFP_KERNEL);
    4943:	49 89 45 00          	mov    %rax,0x0(%r13)
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:96
	strlcpy(ent_context.file_list[ent_context.number_of_files], ent_context.directory_name, full_path_size);
    4947:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 494e <dm_afs_filldir+0x5e>
			494a: R_X86_64_PC32	.bss+0x80034
strlcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:291
    494e:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 4955 <dm_afs_filldir+0x65>
			4951: R_X86_64_PC32	.bss+0x80024
    4955:	48 8b 3c d0          	mov    (%rax,%rdx,8),%rdi
    4959:	4c 89 e2             	mov    %r12,%rdx
    495c:	e8 00 00 00 00       	callq  4961 <dm_afs_filldir+0x71>
			495d: R_X86_64_PC32	strlcpy-0x4
dm_afs_filldir():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:97
	strlcat(ent_context.file_list[ent_context.number_of_files], "/", full_path_size);
    4961:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 4967 <dm_afs_filldir+0x77>
			4963: R_X86_64_PC32	.bss+0x8001c
    4967:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 496e <dm_afs_filldir+0x7e>
			496a: R_X86_64_PC32	.bss+0x80034
    496e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			4971: R_X86_64_32S	.rodata.str1.1+0x8b
    4975:	48 8b 3c d0          	mov    (%rax,%rdx,8),%rdi
    4979:	4c 89 e2             	mov    %r12,%rdx
    497c:	e8 00 00 00 00       	callq  4981 <dm_afs_filldir+0x91>
			497d: R_X86_64_PC32	strlcat-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:98
	strlcat(ent_context.file_list[ent_context.number_of_files], name, full_path_size);
    4981:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 4987 <dm_afs_filldir+0x97>
			4983: R_X86_64_PC32	.bss+0x8001c
    4987:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 498e <dm_afs_filldir+0x9e>
			498a: R_X86_64_PC32	.bss+0x80034
    498e:	48 89 de             	mov    %rbx,%rsi
    4991:	48 8b 3c d0          	mov    (%rax,%rdx,8),%rdi
    4995:	4c 89 e2             	mov    %r12,%rdx
    4998:	e8 00 00 00 00       	callq  499d <dm_afs_filldir+0xad>
			4999: R_X86_64_PC32	strlcat-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:99
	insert_entropy_ht(ent_context.file_list[ent_context.number_of_files]);
    499d:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 49a3 <dm_afs_filldir+0xb3>
			499f: R_X86_64_PC32	.bss+0x8001c
    49a3:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 49aa <dm_afs_filldir+0xba>
			49a6: R_X86_64_PC32	.bss+0x80034
    49aa:	48 8b 3c d0          	mov    (%rax,%rdx,8),%rdi
    49ae:	e8 00 00 00 00       	callq  49b3 <dm_afs_filldir+0xc3>
			49af: R_X86_64_PC32	insert_entropy_ht-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:100
        ent_context.number_of_files++;
    49b3:	83 05 00 00 00 00 01 	addl   $0x1,0x0(%rip)        # 49ba <dm_afs_filldir+0xca>
			49b5: R_X86_64_PC32	.bss+0x8001b
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:103
    }
    return 0;
}
    49ba:	48 83 c4 08          	add    $0x8,%rsp
    49be:	31 c0                	xor    %eax,%eax
    49c0:	5b                   	pop    %rbx
    49c1:	41 5c                	pop    %r12
    49c3:	41 5d                	pop    %r13
    49c5:	5d                   	pop    %rbp
    49c6:	c3                   	retq   
    49c7:	31 c0                	xor    %eax,%eax
    49c9:	c3                   	retq   
    49ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000049d0 <scan_directory>:
scan_directory():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:112
 * Sorcery
 * This scans a directory and returns a list of the files in that directory
 * It could also be possible hook into the system call sys_getdents()
 */
//recursive list, ls $(find <path> -not -path '*/\.*' -type f)
void scan_directory(char* directory_name){
    49d0:	e8 00 00 00 00       	callq  49d5 <scan_directory+0x5>
			49d1: R_X86_64_PC32	__fentry__-0x4
    49d5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:119
    struct dir_context context = {
        .actor = dm_afs_filldir,
        .pos = 0		
    };

    file = filp_open(directory_name, O_RDONLY, 0);
    49d6:	31 d2                	xor    %edx,%edx
    49d8:	31 f6                	xor    %esi,%esi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:112
void scan_directory(char* directory_name){
    49da:	48 89 e5             	mov    %rsp,%rbp
    49dd:	48 83 ec 20          	sub    $0x20,%rsp
    49e1:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    49e8:	00 00 
    49ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    49ee:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:114
    struct dir_context context = {
    49f0:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    49f7:	00 
			49f4: R_X86_64_32S	.text+0x48f0
    49f8:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    49ff:	00 
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:119
    file = filp_open(directory_name, O_RDONLY, 0);
    4a00:	e8 00 00 00 00       	callq  4a05 <scan_directory+0x35>
			4a01: R_X86_64_PC32	filp_open-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:121

    if (file){
    4a05:	48 85 c0             	test   %rax,%rax
    4a08:	74 0c                	je     4a16 <scan_directory+0x46>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:122
        iterate_dir(file, &context);
    4a0a:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
    4a0e:	48 89 c7             	mov    %rax,%rdi
    4a11:	e8 00 00 00 00       	callq  4a16 <scan_directory+0x46>
			4a12: R_X86_64_PC32	iterate_dir-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:124
    }
}
    4a16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    4a1a:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    4a21:	00 00 
    4a23:	75 02                	jne    4a27 <scan_directory+0x57>
    4a25:	c9                   	leaveq 
    4a26:	c3                   	retq   
    4a27:	e8 00 00 00 00       	callq  4a2c <scan_directory+0x5c>
			4a28: R_X86_64_PC32	__stack_chk_fail-0x4
    4a2c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000004a30 <build_entropy_ht>:
build_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:130


/**
 * Entropy hash table constructor
 */
void build_entropy_ht(char* directory_name, size_t name_length){
    4a30:	e8 00 00 00 00       	callq  4a35 <build_entropy_ht+0x5>
			4a31: R_X86_64_PC32	__fentry__-0x4
    4a35:	55                   	push   %rbp
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    4a36:	ba 00 20 00 00       	mov    $0x2000,%edx
build_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:130
    4a3b:	48 89 e5             	mov    %rsp,%rbp
    4a3e:	41 55                	push   %r13
    4a40:	41 54                	push   %r12
    4a42:	53                   	push   %rbx
    4a43:	49 89 f4             	mov    %rsi,%r12
    4a46:	48 89 fb             	mov    %rdi,%rbx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:134

    //TODO experiment with setting it to this size
    ent_context.file_list = kmalloc(sizeof(char*) * FILE_LIST_SIZE, GFP_KERNEL);
    ent_context.directory_name = kmalloc(sizeof(char) * name_length + 1, GFP_KERNEL);
    4a49:	4d 8d 6c 24 01       	lea    0x1(%r12),%r13
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    4a4e:	be c0 00 40 01       	mov    $0x14000c0,%esi
build_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:130
void build_entropy_ht(char* directory_name, size_t name_length){
    4a53:	48 83 ec 08          	sub    $0x8,%rsp
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    4a57:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4a5e <build_entropy_ht+0x2e>
			4a5a: R_X86_64_PC32	kmalloc_caches+0x64
    4a5e:	e8 00 00 00 00       	callq  4a63 <build_entropy_ht+0x33>
			4a5f: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4a63:	be c0 00 40 01       	mov    $0x14000c0,%esi
    4a68:	4c 89 ef             	mov    %r13,%rdi
build_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:133
    ent_context.file_list = kmalloc(sizeof(char*) * FILE_LIST_SIZE, GFP_KERNEL);
    4a6b:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 4a72 <build_entropy_ht+0x42>
			4a6e: R_X86_64_PC32	.bss+0x80034
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    4a72:	e8 00 00 00 00       	callq  4a77 <build_entropy_ht+0x47>
			4a73: R_X86_64_PC32	__kmalloc-0x4
strlcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:291
    4a77:	4c 89 ea             	mov    %r13,%rdx
    4a7a:	48 89 de             	mov    %rbx,%rsi
    4a7d:	48 89 c7             	mov    %rax,%rdi
build_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:134
    ent_context.directory_name = kmalloc(sizeof(char) * name_length + 1, GFP_KERNEL);
    4a80:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 4a87 <build_entropy_ht+0x57>
			4a83: R_X86_64_PC32	.bss+0x80024
strlcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:291
    4a87:	e8 00 00 00 00       	callq  4a8c <build_entropy_ht+0x5c>
			4a88: R_X86_64_PC32	strlcpy-0x4
    4a8c:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
			4a8f: R_X86_64_32S	dm_afs_ht
build_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:136
    strlcpy(ent_context.directory_name, directory_name, name_length + 1);
    ent_context.directory_name_length = name_length;    
    4a93:	4c 89 25 00 00 00 00 	mov    %r12,0x0(%rip)        # 4a9a <build_entropy_ht+0x6a>
			4a96: R_X86_64_PC32	.bss+0x8002c
    4a9a:	48 8d 90 00 00 08 00 	lea    0x80000(%rax),%rdx
__hash_init():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/hashtable.h:39
    4aa1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    4aa8:	48 83 c0 08          	add    $0x8,%rax
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/hashtable.h:38
    4aac:	48 39 d0             	cmp    %rdx,%rax
    4aaf:	75 f0                	jne    4aa1 <build_entropy_ht+0x71>
build_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:141
    
    //initialize hash table
    hash_init(HASH_TABLE_NAME);

    scan_directory(directory_name);
    4ab1:	48 89 df             	mov    %rbx,%rdi
    4ab4:	e8 00 00 00 00       	callq  4ab9 <build_entropy_ht+0x89>
			4ab5: R_X86_64_PC32	scan_directory-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:142
}
    4ab9:	48 83 c4 08          	add    $0x8,%rsp
    4abd:	5b                   	pop    %rbx
    4abe:	41 5c                	pop    %r12
    4ac0:	41 5d                	pop    %r13
    4ac2:	5d                   	pop    %rbp
    4ac3:	c3                   	retq   
    4ac4:	66 90                	xchg   %ax,%ax
    4ac6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    4acd:	00 00 00 

0000000000004ad0 <cleanup_entropy_ht>:
cleanup_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:148


/**
 * Entropy hash table destructor
 */
void cleanup_entropy_ht(void){
    4ad0:	e8 00 00 00 00       	callq  4ad5 <cleanup_entropy_ht+0x5>
			4ad1: R_X86_64_PC32	__fentry__-0x4
    4ad5:	55                   	push   %rbp
    4ad6:	48 89 e5             	mov    %rsp,%rbp
    4ad9:	41 55                	push   %r13
    4adb:	41 54                	push   %r12
    4add:	53                   	push   %rbx
    4ade:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:152
    int bucket, i;
    struct entropy_hash_entry *entry;

    for(i = 0; i < ent_context.number_of_files; i++){
    4ae2:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 4ae8 <cleanup_entropy_ht+0x18>
			4ae4: R_X86_64_PC32	.bss+0x8001c
    4ae8:	85 c0                	test   %eax,%eax
    4aea:	74 25                	je     4b11 <cleanup_entropy_ht+0x41>
    4aec:	31 db                	xor    %ebx,%ebx
    4aee:	49 c7 c4 00 00 00 00 	mov    $0x0,%r12
			4af1: R_X86_64_32S	.bss+0x80020
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:153 (discriminator 3)
        kfree(ent_context.file_list[i]);
    4af5:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 4afc <cleanup_entropy_ht+0x2c>
			4af8: R_X86_64_PC32	.bss+0x80034
    4afc:	48 63 d3             	movslq %ebx,%rdx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:152 (discriminator 3)
    for(i = 0; i < ent_context.number_of_files; i++){
    4aff:	83 c3 01             	add    $0x1,%ebx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:153 (discriminator 3)
        kfree(ent_context.file_list[i]);
    4b02:	48 8b 3c d0          	mov    (%rax,%rdx,8),%rdi
    4b06:	e8 00 00 00 00       	callq  4b0b <cleanup_entropy_ht+0x3b>
			4b07: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:152 (discriminator 3)
    for(i = 0; i < ent_context.number_of_files; i++){
    4b0b:	41 39 1c 24          	cmp    %ebx,(%r12)
    4b0f:	77 e4                	ja     4af5 <cleanup_entropy_ht+0x25>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:155
    } 
    kfree(ent_context.file_list);
    4b11:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4b18 <cleanup_entropy_ht+0x48>
			4b14: R_X86_64_PC32	.bss+0x80034
    4b18:	49 c7 c4 00 00 00 00 	mov    $0x0,%r12
			4b1b: R_X86_64_32S	dm_afs_ht
    4b1f:	4d 8d ac 24 00 00 08 	lea    0x80000(%r12),%r13
    4b26:	00 
    4b27:	e8 00 00 00 00       	callq  4b2c <cleanup_entropy_ht+0x5c>
			4b28: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:156
    kfree(ent_context.directory_name);
    4b2c:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4b33 <cleanup_entropy_ht+0x63>
			4b2f: R_X86_64_PC32	.bss+0x80024
    4b33:	e8 00 00 00 00       	callq  4b38 <cleanup_entropy_ht+0x68>
			4b34: R_X86_64_PC32	kfree-0x4
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188 (discriminator 2)
    4b38:	49 8b 3c 24          	mov    (%r12),%rdi
cleanup_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:158 (discriminator 2)

    hash_for_each_rcu(HASH_TABLE_NAME, bucket, entry, hash_list){
    4b3c:	48 85 ff             	test   %rdi,%rdi
    4b3f:	74 25                	je     4b66 <cleanup_entropy_ht+0x96>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:158 (discriminator 10)
    4b41:	48 83 ef 18          	sub    $0x18,%rdi
    4b45:	48 89 fb             	mov    %rdi,%rbx
    4b48:	75 0b                	jne    4b55 <cleanup_entropy_ht+0x85>
    4b4a:	eb 1a                	jmp    4b66 <cleanup_entropy_ht+0x96>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:158 (discriminator 22)
    4b4c:	48 89 fb             	mov    %rdi,%rbx
    4b4f:	48 83 eb 18          	sub    $0x18,%rbx
    4b53:	74 11                	je     4b66 <cleanup_entropy_ht+0x96>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:161 (discriminator 26)
	//TODO Check here for memory leaks
	//kfree(entry->filename);
	kfree(entry);
    4b55:	48 89 df             	mov    %rbx,%rdi
    4b58:	e8 00 00 00 00       	callq  4b5d <cleanup_entropy_ht+0x8d>
			4b59: R_X86_64_PC32	kfree-0x4
__read_once_size():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/compiler.h:188 (discriminator 26)
    4b5d:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
cleanup_entropy_ht():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:158 (discriminator 26)
    hash_for_each_rcu(HASH_TABLE_NAME, bucket, entry, hash_list){
    4b61:	48 85 ff             	test   %rdi,%rdi
    4b64:	75 e6                	jne    4b4c <cleanup_entropy_ht+0x7c>
    4b66:	49 83 c4 08          	add    $0x8,%r12
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:158
    4b6a:	4d 39 e5             	cmp    %r12,%r13
    4b6d:	75 c9                	jne    4b38 <cleanup_entropy_ht+0x68>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:163
    }
}
    4b6f:	48 83 c4 08          	add    $0x8,%rsp
    4b73:	5b                   	pop    %rbx
    4b74:	41 5c                	pop    %r12
    4b76:	41 5d                	pop    %r13
    4b78:	5d                   	pop    %rbp
    4b79:	c3                   	retq   
    4b7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000004b80 <retrieve_file_data>:
retrieve_file_data():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:168

/**
 * Retrieve a full file name from the hash table
 */
struct entropy_hash_entry*  retrieve_file_data(uint64_t filename_hash){
    4b80:	e8 00 00 00 00       	callq  4b85 <retrieve_file_data+0x5>
			4b81: R_X86_64_PC32	__fentry__-0x4
hash_64_generic():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/hash.h:81
    4b85:	48 b8 eb 83 b5 80 46 	movabs $0x61c8864680b583eb,%rax
    4b8c:	86 c8 61 
retrieve_file_data():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:168
    4b8f:	55                   	push   %rbp
hash_64_generic():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/hash.h:81
    4b90:	48 0f af c7          	imul   %rdi,%rax
retrieve_file_data():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:168
    4b94:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:170
    struct entropy_hash_entry *entry;
    hash_for_each_possible(HASH_TABLE_NAME, entry, hash_list, filename_hash){
    4b97:	48 c1 e8 30          	shr    $0x30,%rax
    4b9b:	48 8b 14 c5 00 00 00 	mov    0x0(,%rax,8),%rdx
    4ba2:	00 
			4b9f: R_X86_64_32S	dm_afs_ht
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:175
        if(filename_hash == entry->key){
            return entry;
        }
    }
    return NULL;
    4ba3:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:170
    hash_for_each_possible(HASH_TABLE_NAME, entry, hash_list, filename_hash){
    4ba5:	48 85 d2             	test   %rdx,%rdx
    4ba8:	74 2a                	je     4bd4 <retrieve_file_data+0x54>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:170 (discriminator 5)
    4baa:	48 89 d0             	mov    %rdx,%rax
    4bad:	48 83 e8 18          	sub    $0x18,%rax
    4bb1:	74 21                	je     4bd4 <retrieve_file_data+0x54>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:171
        if(filename_hash == entry->key){
    4bb3:	48 3b 7a e8          	cmp    -0x18(%rdx),%rdi
    4bb7:	75 11                	jne    4bca <retrieve_file_data+0x4a>
    4bb9:	eb 19                	jmp    4bd4 <retrieve_file_data+0x54>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:170 (discriminator 13)
    hash_for_each_possible(HASH_TABLE_NAME, entry, hash_list, filename_hash){
    4bbb:	48 89 d0             	mov    %rdx,%rax
    4bbe:	48 83 e8 18          	sub    $0x18,%rax
    4bc2:	74 10                	je     4bd4 <retrieve_file_data+0x54>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:171
        if(filename_hash == entry->key){
    4bc4:	48 39 7a e8          	cmp    %rdi,-0x18(%rdx)
    4bc8:	74 0a                	je     4bd4 <retrieve_file_data+0x54>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:170
    hash_for_each_possible(HASH_TABLE_NAME, entry, hash_list, filename_hash){
    4bca:	48 8b 12             	mov    (%rdx),%rdx
    4bcd:	48 85 d2             	test   %rdx,%rdx
    4bd0:	75 e9                	jne    4bbb <retrieve_file_data+0x3b>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:175
    return NULL;
    4bd2:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:176
}
    4bd4:	5d                   	pop    %rbp
    4bd5:	c3                   	retq   
    4bd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    4bdd:	00 00 00 

0000000000004be0 <read_entropy>:
read_entropy():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:204
}

/**
 * Read a specific entropy block with assistance from the filename
 */
int read_entropy(uint64_t filename_hash, uint32_t block_pointer, uint8_t* block){
    4be0:	e8 00 00 00 00       	callq  4be5 <read_entropy+0x5>
			4be1: R_X86_64_PC32	__fentry__-0x4
    4be5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:208
    int ret = 0;
    struct entropy_hash_entry* entry = NULL;
    struct file* file = NULL;
    loff_t offset = block_pointer * BLOCK_LENGTH;
    4be6:	c1 e6 0c             	shl    $0xc,%esi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:204
int read_entropy(uint64_t filename_hash, uint32_t block_pointer, uint8_t* block){
    4be9:	48 89 e5             	mov    %rsp,%rbp
    4bec:	41 54                	push   %r12
    4bee:	53                   	push   %rbx
    4bef:	48 83 ec 10          	sub    $0x10,%rsp
    4bf3:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    4bfa:	00 00 
    4bfc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    4c00:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:208
    loff_t offset = block_pointer * BLOCK_LENGTH;
    4c02:	89 f0                	mov    %esi,%eax
    4c04:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
hash_64_generic():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/hash.h:81
    4c08:	48 b8 eb 83 b5 80 46 	movabs $0x61c8864680b583eb,%rax
    4c0f:	86 c8 61 
    4c12:	48 0f af c7          	imul   %rdi,%rax
retrieve_file_data():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:170
    hash_for_each_possible(HASH_TABLE_NAME, entry, hash_list, filename_hash){
    4c16:	48 c1 e8 30          	shr    $0x30,%rax
    4c1a:	48 8b 04 c5 00 00 00 	mov    0x0(,%rax,8),%rax
    4c21:	00 
			4c1e: R_X86_64_32S	dm_afs_ht
    4c22:	48 85 c0             	test   %rax,%rax
    4c25:	74 6a                	je     4c91 <read_entropy+0xb1>
    4c27:	48 89 d3             	mov    %rdx,%rbx
    4c2a:	eb 08                	jmp    4c34 <read_entropy+0x54>
    4c2c:	48 8b 00             	mov    (%rax),%rax
    4c2f:	48 85 c0             	test   %rax,%rax
    4c32:	74 5d                	je     4c91 <read_entropy+0xb1>
    4c34:	48 89 c2             	mov    %rax,%rdx
    4c37:	48 83 ea 18          	sub    $0x18,%rdx
    4c3b:	74 54                	je     4c91 <read_entropy+0xb1>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:171
        if(filename_hash == entry->key){
    4c3d:	48 3b 78 e8          	cmp    -0x18(%rax),%rdi
    4c41:	75 e9                	jne    4c2c <read_entropy+0x4c>
file_open():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:46
    filp = filp_open(path, flags, rights);
    4c43:	48 8b 7a 08          	mov    0x8(%rdx),%rdi
    4c47:	31 f6                	xor    %esi,%esi
    4c49:	31 d2                	xor    %edx,%edx
    4c4b:	e8 00 00 00 00       	callq  4c50 <read_entropy+0x70>
			4c4c: R_X86_64_PC32	filp_open-0x4
read_entropy():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:214

    entry = retrieve_file_data(filename_hash);

    if(entry != NULL){
	file = file_open(entry->filename, O_RDONLY, 0);
        ret = kernel_read(file, block, BLOCK_LENGTH, &offset);
    4c50:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
    4c54:	48 89 de             	mov    %rbx,%rsi
    4c57:	ba 00 10 00 00       	mov    $0x1000,%edx
    4c5c:	48 89 c7             	mov    %rax,%rdi
file_open():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:46
    filp = filp_open(path, flags, rights);
    4c5f:	49 89 c4             	mov    %rax,%r12
read_entropy():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:214
        ret = kernel_read(file, block, BLOCK_LENGTH, &offset);
    4c62:	e8 00 00 00 00       	callq  4c67 <read_entropy+0x87>
			4c63: R_X86_64_PC32	kernel_read-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:215
	if (ret < 0){
    4c67:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:214
        ret = kernel_read(file, block, BLOCK_LENGTH, &offset);
    4c69:	89 c3                	mov    %eax,%ebx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:215
	if (ret < 0){
    4c6b:	78 39                	js     4ca6 <read_entropy+0xc6>
file_close():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:54
    filp_close(file, NULL);
    4c6d:	31 f6                	xor    %esi,%esi
    4c6f:	4c 89 e7             	mov    %r12,%rdi
    4c72:	e8 00 00 00 00       	callq  4c77 <read_entropy+0x97>
			4c73: R_X86_64_PC32	filp_close-0x4
read_entropy():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:225
        printk(KERN_INFO "Could not read hash table entry\n");
	ret = -1;
    }

    return ret;
}
    4c77:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    4c7b:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    4c82:	00 00 
    4c84:	89 d8                	mov    %ebx,%eax
    4c86:	75 30                	jne    4cb8 <read_entropy+0xd8>
    4c88:	48 83 c4 10          	add    $0x10,%rsp
    4c8c:	5b                   	pop    %rbx
    4c8d:	41 5c                	pop    %r12
    4c8f:	5d                   	pop    %rbp
    4c90:	c3                   	retq   
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:220
        printk(KERN_INFO "Could not read hash table entry\n");
    4c91:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			4c94: R_X86_64_32S	.rodata.str1.8+0x18c0
    4c98:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:221
	ret = -1;
    4c9a:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:220
        printk(KERN_INFO "Could not read hash table entry\n");
    4c9f:	e8 00 00 00 00       	callq  4ca4 <read_entropy+0xc4>
			4ca0: R_X86_64_PC32	printk-0x4
    4ca4:	eb d1                	jmp    4c77 <read_entropy+0x97>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:216
            printk(KERN_INFO "Kernel Read Failed: %d\n", ret);
    4ca6:	89 c6                	mov    %eax,%esi
    4ca8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			4cab: R_X86_64_32S	.rodata.str1.1+0x8d
    4caf:	31 c0                	xor    %eax,%eax
    4cb1:	e8 00 00 00 00       	callq  4cb6 <read_entropy+0xd6>
			4cb2: R_X86_64_PC32	printk-0x4
    4cb6:	eb b5                	jmp    4c6d <read_entropy+0x8d>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:225
}
    4cb8:	e8 00 00 00 00       	callq  4cbd <read_entropy+0xdd>
			4cb9: R_X86_64_PC32	__stack_chk_fail-0x4
    4cbd:	0f 1f 00             	nopl   (%rax)

0000000000004cc0 <allocate_entropy>:
allocate_entropy():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:181
void allocate_entropy(uint64_t *filename_hash, uint32_t *block_pointer, uint8_t *entropy_block){
    4cc0:	e8 00 00 00 00       	callq  4cc5 <allocate_entropy+0x5>
			4cc1: R_X86_64_PC32	__fentry__-0x4
    4cc5:	55                   	push   %rbp
    4cc6:	48 89 e5             	mov    %rsp,%rbp
    4cc9:	41 56                	push   %r14
    4ccb:	41 55                	push   %r13
    4ccd:	41 54                	push   %r12
    4ccf:	53                   	push   %rbx
    4cd0:	48 89 fb             	mov    %rdi,%rbx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:186
    get_random_bytes(&file_index, sizeof(int));
    4cd3:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:181
void allocate_entropy(uint64_t *filename_hash, uint32_t *block_pointer, uint8_t *entropy_block){
    4cd7:	49 89 f4             	mov    %rsi,%r12
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:186
    get_random_bytes(&file_index, sizeof(int));
    4cda:	be 04 00 00 00       	mov    $0x4,%esi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:181
void allocate_entropy(uint64_t *filename_hash, uint32_t *block_pointer, uint8_t *entropy_block){
    4cdf:	48 83 ec 10          	sub    $0x10,%rsp
    4ce3:	49 89 d5             	mov    %rdx,%r13
    4ce6:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    4ced:	00 00 
    4cef:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4cf3:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:186
    get_random_bytes(&file_index, sizeof(int));
    4cf5:	e8 00 00 00 00       	callq  4cfa <allocate_entropy+0x3a>
			4cf6: R_X86_64_PC32	get_random_bytes-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:187
    get_random_bytes(&block_index, sizeof(int));
    4cfa:	48 8d 7d d4          	lea    -0x2c(%rbp),%rdi
    4cfe:	be 04 00 00 00       	mov    $0x4,%esi
    4d03:	e8 00 00 00 00       	callq  4d08 <allocate_entropy+0x48>
			4d04: R_X86_64_PC32	get_random_bytes-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:190
    file_index = file_index % ent_context.number_of_files;
    4d08:	8b 45 d0             	mov    -0x30(%rbp),%eax
    4d0b:	31 d2                	xor    %edx,%edx
    4d0d:	f7 35 00 00 00 00    	divl   0x0(%rip)        # 4d13 <allocate_entropy+0x53>
			4d0f: R_X86_64_PC32	.bss+0x8001c
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:191
    entry = retrieve_file_data(djb2_hash(ent_context.file_list[file_index]));
    4d13:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 4d1a <allocate_entropy+0x5a>
			4d16: R_X86_64_PC32	.bss+0x80034
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:190
    file_index = file_index % ent_context.number_of_files;
    4d1a:	89 55 d0             	mov    %edx,-0x30(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:191
    entry = retrieve_file_data(djb2_hash(ent_context.file_list[file_index]));
    4d1d:	48 63 d2             	movslq %edx,%rdx
    4d20:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
djb2_hash():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    4d24:	48 8d 70 01          	lea    0x1(%rax),%rsi
    4d28:	0f b6 00             	movzbl (%rax),%eax
    4d2b:	84 c0                	test   %al,%al
    4d2d:	0f 84 a8 00 00 00    	je     4ddb <allocate_entropy+0x11b>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:32
    unsigned long hash = 5381;
    4d33:	ba 05 15 00 00       	mov    $0x1505,%edx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:36
        hash = ((hash << 5) + hash) + c;
    4d38:	48 89 d1             	mov    %rdx,%rcx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    4d3b:	48 83 c6 01          	add    $0x1,%rsi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:36
        hash = ((hash << 5) + hash) + c;
    4d3f:	48 c1 e1 05          	shl    $0x5,%rcx
    4d43:	48 01 c8             	add    %rcx,%rax
    4d46:	48 01 c2             	add    %rax,%rdx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    4d49:	0f b6 46 ff          	movzbl -0x1(%rsi),%eax
    4d4d:	84 c0                	test   %al,%al
    4d4f:	75 e7                	jne    4d38 <allocate_entropy+0x78>
    4d51:	48 b8 eb 83 b5 80 46 	movabs $0x61c8864680b583eb,%rax
    4d58:	86 c8 61 
    4d5b:	48 0f af c2          	imul   %rdx,%rax
    4d5f:	48 c1 e8 30          	shr    $0x30,%rax
retrieve_file_data():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:170
    hash_for_each_possible(HASH_TABLE_NAME, entry, hash_list, filename_hash){
    4d63:	89 c0                	mov    %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:175
    return NULL;
    4d65:	45 31 f6             	xor    %r14d,%r14d
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:170
    hash_for_each_possible(HASH_TABLE_NAME, entry, hash_list, filename_hash){
    4d68:	48 8b 04 c5 00 00 00 	mov    0x0(,%rax,8),%rax
    4d6f:	00 
			4d6c: R_X86_64_32S	dm_afs_ht
    4d70:	48 85 c0             	test   %rax,%rax
    4d73:	75 0a                	jne    4d7f <allocate_entropy+0xbf>
    4d75:	eb 17                	jmp    4d8e <allocate_entropy+0xce>
    4d77:	48 8b 00             	mov    (%rax),%rax
    4d7a:	48 85 c0             	test   %rax,%rax
    4d7d:	74 57                	je     4dd6 <allocate_entropy+0x116>
    4d7f:	49 89 c6             	mov    %rax,%r14
    4d82:	49 83 ee 18          	sub    $0x18,%r14
    4d86:	74 06                	je     4d8e <allocate_entropy+0xce>
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:171
        if(filename_hash == entry->key){
    4d88:	48 39 50 e8          	cmp    %rdx,-0x18(%rax)
    4d8c:	75 e9                	jne    4d77 <allocate_entropy+0xb7>
allocate_entropy():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:194
    block_index = (block_index % entry->file_size) / BLOCK_LENGTH;
    4d8e:	48 63 45 d4          	movslq -0x2c(%rbp),%rax
    4d92:	31 d2                	xor    %edx,%edx
    4d94:	49 f7 76 10          	divq   0x10(%r14)
    4d98:	48 89 d6             	mov    %rdx,%rsi
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:195
    read_entropy(entry->key, block_index, entropy_block);
    4d9b:	4c 89 ea             	mov    %r13,%rdx
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:194
    block_index = (block_index % entry->file_size) / BLOCK_LENGTH;
    4d9e:	48 c1 ee 0c          	shr    $0xc,%rsi
    4da2:	89 75 d4             	mov    %esi,-0x2c(%rbp)
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:195
    read_entropy(entry->key, block_index, entropy_block);
    4da5:	49 8b 3e             	mov    (%r14),%rdi
    4da8:	e8 00 00 00 00       	callq  4dad <allocate_entropy+0xed>
			4da9: R_X86_64_PC32	read_entropy-0x4
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:197
    *block_pointer = block_index;
    4dad:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    4db0:	41 89 04 24          	mov    %eax,(%r12)
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:198
    *filename_hash = entry->key;
    4db4:	49 8b 06             	mov    (%r14),%rax
    4db7:	48 89 03             	mov    %rax,(%rbx)
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:199
}
    4dba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    4dbe:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    4dc5:	00 00 
    4dc7:	75 21                	jne    4dea <allocate_entropy+0x12a>
    4dc9:	48 83 c4 10          	add    $0x10,%rsp
    4dcd:	5b                   	pop    %rbx
    4dce:	41 5c                	pop    %r12
    4dd0:	41 5d                	pop    %r13
    4dd2:	41 5e                	pop    %r14
    4dd4:	5d                   	pop    %rbp
    4dd5:	c3                   	retq   
retrieve_file_data():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:175
    return NULL;
    4dd6:	45 31 f6             	xor    %r14d,%r14d
    4dd9:	eb b3                	jmp    4d8e <allocate_entropy+0xce>
djb2_hash():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:35
    while((c = *str++)){
    4ddb:	b8 ee 5b 00 00       	mov    $0x5bee,%eax
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:32
    unsigned long hash = 5381;
    4de0:	ba 05 15 00 00       	mov    $0x1505,%edx
    4de5:	e9 79 ff ff ff       	jmpq   4d63 <allocate_entropy+0xa3>
allocate_entropy():
/home/austen/programming/dm-afs/src/dm_afs_entropy.c:199
}
    4dea:	e8 00 00 00 00       	callq  4def <allocate_entropy+0x12f>
			4deb: R_X86_64_PC32	__stack_chk_fail-0x4
    4def:	90                   	nop

0000000000004df0 <bit_vector_create>:
bit_vector_create():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:20
 * @return  A bit vector
 * @return  NULL        Not enough memory.
 */
bit_vector_t *
bit_vector_create(uint64_t length)
{
    4df0:	e8 00 00 00 00       	callq  4df5 <bit_vector_create+0x5>
			4df1: R_X86_64_PC32	__fentry__-0x4
    4df5:	55                   	push   %rbp
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    4df6:	ba 18 00 00 00       	mov    $0x18,%edx
    4dfb:	be c0 00 40 01       	mov    $0x14000c0,%esi
bit_vector_create():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:20
    4e00:	48 89 e5             	mov    %rsp,%rbp
    4e03:	41 55                	push   %r13
    4e05:	41 54                	push   %r12
    4e07:	53                   	push   %rbx
    4e08:	49 89 fd             	mov    %rdi,%r13
    4e0b:	48 83 ec 08          	sub    $0x8,%rsp
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    4e0f:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 4e16 <bit_vector_create+0x26>
			4e12: R_X86_64_PC32	kmalloc_caches+0x24
    4e16:	e8 00 00 00 00       	callq  4e1b <bit_vector_create+0x2b>
			4e17: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
bit_vector_create():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:26
    bit_vector_t *vector;
    uint64_t temp_length;

    temp_length = length;
    vector = kmalloc(sizeof *vector, GFP_KERNEL);
    if (!vector) {
    4e1b:	48 85 c0             	test   %rax,%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    4e1e:	48 89 c3             	mov    %rax,%rbx
bit_vector_create():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:26
    4e21:	74 33                	je     4e56 <bit_vector_create+0x66>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:30
        return NULL;
    }

    vector->array = vmalloc(BIT_VECTOR_BITS_TO_BYTES(temp_length) * sizeof(*(vector->array)));
    4e23:	4d 89 ec             	mov    %r13,%r12
    4e26:	49 c1 ec 03          	shr    $0x3,%r12
    4e2a:	49 83 c4 01          	add    $0x1,%r12
    4e2e:	4c 89 e7             	mov    %r12,%rdi
    4e31:	e8 00 00 00 00       	callq  4e36 <bit_vector_create+0x46>
			4e32: R_X86_64_PC32	vmalloc-0x4
/home/austen/programming/dm-afs/src/lib/bit_vector.c:31
    if (!(vector->array)) {
    4e36:	48 85 c0             	test   %rax,%rax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:30
    vector->array = vmalloc(BIT_VECTOR_BITS_TO_BYTES(temp_length) * sizeof(*(vector->array)));
    4e39:	48 89 03             	mov    %rax,(%rbx)
/home/austen/programming/dm-afs/src/lib/bit_vector.c:31
    if (!(vector->array)) {
    4e3c:	74 26                	je     4e64 <bit_vector_create+0x74>
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    4e3e:	4c 89 e2             	mov    %r12,%rdx
    4e41:	31 f6                	xor    %esi,%esi
    4e43:	48 89 c7             	mov    %rax,%rdi
    4e46:	e8 00 00 00 00       	callq  4e4b <bit_vector_create+0x5b>
			4e47: R_X86_64_PC32	memset-0x4
bit_vector_create():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:36
        kfree(vector);
        return NULL;
    }
    memset(vector->array, 0, BIT_VECTOR_BITS_TO_BYTES(temp_length) * sizeof(*(vector->array)));
    vector->length = temp_length;
    4e4b:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
/home/austen/programming/dm-afs/src/lib/bit_vector.c:39

    // Initialize spin lock.
    spin_lock_init(&vector->lock);
    4e4f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%rbx)
/home/austen/programming/dm-afs/src/lib/bit_vector.c:42

    return vector;
}
    4e56:	48 83 c4 08          	add    $0x8,%rsp
    4e5a:	48 89 d8             	mov    %rbx,%rax
    4e5d:	5b                   	pop    %rbx
    4e5e:	41 5c                	pop    %r12
    4e60:	41 5d                	pop    %r13
    4e62:	5d                   	pop    %rbp
    4e63:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/bit_vector.c:32
        kfree(vector);
    4e64:	48 89 df             	mov    %rbx,%rdi
/home/austen/programming/dm-afs/src/lib/bit_vector.c:33
        return NULL;
    4e67:	31 db                	xor    %ebx,%ebx
/home/austen/programming/dm-afs/src/lib/bit_vector.c:32
        kfree(vector);
    4e69:	e8 00 00 00 00       	callq  4e6e <bit_vector_create+0x7e>
			4e6a: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/bit_vector.c:33
        return NULL;
    4e6e:	eb e6                	jmp    4e56 <bit_vector_create+0x66>

0000000000004e70 <bit_vector_free>:
bit_vector_free():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:51
 *
 * @param   vector      The bit vector to free
 */
void
bit_vector_free(bit_vector_t *vector)
{
    4e70:	e8 00 00 00 00       	callq  4e75 <bit_vector_free+0x5>
			4e71: R_X86_64_PC32	__fentry__-0x4
    4e75:	55                   	push   %rbp
    4e76:	48 89 e5             	mov    %rsp,%rbp
    4e79:	53                   	push   %rbx
    4e7a:	48 89 fb             	mov    %rdi,%rbx
    4e7d:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/bit_vector.c:52
    vfree(vector->array);
    4e81:	48 8b 3f             	mov    (%rdi),%rdi
    4e84:	e8 00 00 00 00       	callq  4e89 <bit_vector_free+0x19>
			4e85: R_X86_64_PC32	vfree-0x4
/home/austen/programming/dm-afs/src/lib/bit_vector.c:53
    kfree(vector);
    4e89:	48 89 df             	mov    %rbx,%rdi
    4e8c:	e8 00 00 00 00       	callq  4e91 <bit_vector_free+0x21>
			4e8d: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/bit_vector.c:54
}
    4e91:	48 83 c4 08          	add    $0x8,%rsp
    4e95:	5b                   	pop    %rbx
    4e96:	5d                   	pop    %rbp
    4e97:	c3                   	retq   
    4e98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    4e9f:	00 

0000000000004ea0 <bit_vector_set>:
bit_vector_set():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:69
 *  EINVAL: vector is NULL.
 *  EINVAL: index is beyond vector length.
 */
int
bit_vector_set(bit_vector_t *vector, uint64_t index)
{
    4ea0:	e8 00 00 00 00       	callq  4ea5 <bit_vector_set+0x5>
			4ea1: R_X86_64_PC32	__fentry__-0x4
    4ea5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/bit_vector.c:72
//    uint8_t or_bits;

    if (!vector || index > vector->length) {
    4ea6:	48 85 ff             	test   %rdi,%rdi
/home/austen/programming/dm-afs/src/lib/bit_vector.c:69
{
    4ea9:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/bit_vector.c:72
    if (!vector || index > vector->length) {
    4eac:	74 06                	je     4eb4 <bit_vector_set+0x14>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:72 (discriminator 1)
    4eae:	48 39 77 08          	cmp    %rsi,0x8(%rdi)
    4eb2:	73 11                	jae    4ec5 <bit_vector_set+0x25>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:73
        afs_debug("vector: %p | index: %llu", vector, index);
    4eb4:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 4eba <bit_vector_set+0x1a>
			4eb6: R_X86_64_PC32	afs_debug_mode-0x4
    4eba:	85 c0                	test   %eax,%eax
    4ebc:	75 13                	jne    4ed1 <bit_vector_set+0x31>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:74
        return -EINVAL;
    4ebe:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:84
    //vector->array[BIT_VECTOR_GET_BYTE_INDEX(index)] |= or_bits;
    //spin_unlock(&vector->lock);
    set_bit(index, (volatile unsigned long*)vector->array);

    return 0;
}
    4ec3:	5d                   	pop    %rbp
    4ec4:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/bit_vector.c:81
    set_bit(index, (volatile unsigned long*)vector->array);
    4ec5:	48 8b 07             	mov    (%rdi),%rax
set_bit():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/bitops.h:81
    4ec8:	f0 48 0f ab 30       	lock bts %rsi,(%rax)
bit_vector_set():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:83
    return 0;
    4ecd:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:84
}
    4ecf:	5d                   	pop    %rbp
    4ed0:	c3                   	retq   
    4ed1:	49 89 f0             	mov    %rsi,%r8
    4ed4:	48 89 f9             	mov    %rdi,%rcx
/home/austen/programming/dm-afs/src/lib/bit_vector.c:73 (discriminator 1)
        afs_debug("vector: %p | index: %llu", vector, index);
    4ed7:	ba 49 00 00 00       	mov    $0x49,%edx
    4edc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			4edf: R_X86_64_32S	.rodata+0x22c0
    4ee3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			4ee6: R_X86_64_32S	.rodata.str1.8+0x18e8
    4eea:	31 c0                	xor    %eax,%eax
    4eec:	e8 00 00 00 00       	callq  4ef1 <bit_vector_set+0x51>
			4eed: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/lib/bit_vector.c:74 (discriminator 1)
        return -EINVAL;
    4ef1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:84 (discriminator 1)
}
    4ef6:	5d                   	pop    %rbp
    4ef7:	c3                   	retq   
    4ef8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    4eff:	00 

0000000000004f00 <bit_vector_clear>:
bit_vector_clear():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:99
 *  EINVAL: vector is NULL.
 *  EINVAL: index is beyond vector length.
 */
int
bit_vector_clear(bit_vector_t *vector, uint64_t index)
{
    4f00:	e8 00 00 00 00       	callq  4f05 <bit_vector_clear+0x5>
			4f01: R_X86_64_PC32	__fentry__-0x4
/home/austen/programming/dm-afs/src/lib/bit_vector.c:102
//    uint8_t and_bits;

    if (!vector || index > vector->length) {
    4f05:	48 85 ff             	test   %rdi,%rdi
    4f08:	74 16                	je     4f20 <bit_vector_clear+0x20>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:102 (discriminator 1)
    4f0a:	48 39 77 08          	cmp    %rsi,0x8(%rdi)
    4f0e:	72 10                	jb     4f20 <bit_vector_clear+0x20>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:99
{
    4f10:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/bit_vector.c:110

    //spin_lock(&vector->lock);
    //and_bits = ~(1 << BIT_VECTOR_GET_BIT_INDEX(index));
    //vector->array[BIT_VECTOR_GET_BYTE_INDEX(index)] &= and_bits;
    //spin_unlock(&vector->lock);
    clear_bit(index, (volatile unsigned long*)vector->array);
    4f11:	48 8b 07             	mov    (%rdi),%rax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:99
{
    4f14:	48 89 e5             	mov    %rsp,%rbp
clear_bit():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/bitops.h:118
    4f17:	f0 48 0f b3 30       	lock btr %rsi,(%rax)
bit_vector_clear():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:112

    return 0;
    4f1c:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:113
}
    4f1e:	5d                   	pop    %rbp
    4f1f:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/bit_vector.c:103
        return -EINVAL;
    4f20:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:113
}
    4f25:	c3                   	retq   
    4f26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    4f2d:	00 00 00 

0000000000004f30 <bit_vector_get>:
bit_vector_get():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:129
 *  EINVAL: vector is NULL.
 *  EINVAL: index is beyond vector length.
 */
int
bit_vector_get(bit_vector_t *vector, uint64_t index)
{
    4f30:	e8 00 00 00 00       	callq  4f35 <bit_vector_get+0x5>
			4f31: R_X86_64_PC32	__fentry__-0x4
    4f35:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/bit_vector.c:133
    uint8_t return_bits;
//    uint8_t and_bits;

    if (!vector || index > vector->length) {
    4f36:	48 85 ff             	test   %rdi,%rdi
/home/austen/programming/dm-afs/src/lib/bit_vector.c:129
{
    4f39:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/bit_vector.c:133
    if (!vector || index > vector->length) {
    4f3c:	74 06                	je     4f44 <bit_vector_get+0x14>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:133 (discriminator 1)
    4f3e:	48 39 77 08          	cmp    %rsi,0x8(%rdi)
    4f42:	73 11                	jae    4f55 <bit_vector_get+0x25>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:134
        afs_debug("vector: %p | index: %llu", vector, index);
    4f44:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 4f4a <bit_vector_get+0x1a>
			4f46: R_X86_64_PC32	afs_debug_mode-0x4
    4f4a:	85 c0                	test   %eax,%eax
    4f4c:	75 16                	jne    4f64 <bit_vector_get+0x34>
/home/austen/programming/dm-afs/src/lib/bit_vector.c:135
        return -EINVAL;
    4f4e:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:145
    //return_bits = vector->array[BIT_VECTOR_GET_BYTE_INDEX(index)] & and_bits;
    //spin_unlock(&vector->lock);
    return_bits = test_bit(index, (volatile unsigned long*)vector->array);

    return !!return_bits;
}
    4f53:	5d                   	pop    %rbp
    4f54:	c3                   	retq   
variable_test_bit():
/usr/src/linux-headers-4.15.0-54-generic/./arch/x86/include/asm/bitops.h:332
    4f55:	48 8b 07             	mov    (%rdi),%rax
    4f58:	48 0f a3 30          	bt     %rsi,(%rax)
bit_vector_get():
/home/austen/programming/dm-afs/src/lib/bit_vector.c:144
    return !!return_bits;
    4f5c:	0f 92 c0             	setb   %al
    4f5f:	0f b6 c0             	movzbl %al,%eax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:145
}
    4f62:	5d                   	pop    %rbp
    4f63:	c3                   	retq   
    4f64:	49 89 f0             	mov    %rsi,%r8
    4f67:	48 89 f9             	mov    %rdi,%rcx
/home/austen/programming/dm-afs/src/lib/bit_vector.c:134 (discriminator 1)
        afs_debug("vector: %p | index: %llu", vector, index);
    4f6a:	ba 86 00 00 00       	mov    $0x86,%edx
    4f6f:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			4f72: R_X86_64_32S	.rodata+0x22b0
    4f76:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			4f79: R_X86_64_32S	.rodata.str1.8+0x18e8
    4f7d:	31 c0                	xor    %eax,%eax
    4f7f:	e8 00 00 00 00       	callq  4f84 <bit_vector_get+0x54>
			4f80: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/lib/bit_vector.c:135 (discriminator 1)
        return -EINVAL;
    4f84:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
/home/austen/programming/dm-afs/src/lib/bit_vector.c:145 (discriminator 1)
}
    4f89:	5d                   	pop    %rbp
    4f8a:	c3                   	retq   
    4f8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000004f90 <gf_init>:
gf_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:496
    for (i = 0; i < 4; ++i)
        type.CharArray[i] = kLittleEndianTestData[i];
    return 0x01020304 == type.IntValue;
}

int gf_init(void) {
    4f90:	e8 00 00 00 00       	callq  4f95 <gf_init+0x5>
			4f91: R_X86_64_PC32	__fentry__-0x4
    4f95:	4c 8d 54 24 08       	lea    0x8(%rsp),%r10
    4f9a:	48 83 e4 e0          	and    $0xffffffffffffffe0,%rsp
    4f9e:	41 ff 72 f8          	pushq  -0x8(%r10)
    4fa2:	55                   	push   %rbp
    4fa3:	48 89 e5             	mov    %rsp,%rbp
    4fa6:	41 57                	push   %r15
    4fa8:	41 56                	push   %r14
    4faa:	41 55                	push   %r13
    4fac:	41 54                	push   %r12
    4fae:	41 52                	push   %r10
    4fb0:	53                   	push   %rbx
    4fb1:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
    4fb5:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    4fbc:	00 00 
    4fbe:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4fc2:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:498
    // Avoid multiple initialization
    if (Initialized) {
    4fc4:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 4fcb <gf_init+0x3b>
			4fc6: R_X86_64_PC32	.bss+0xa685b
    4fcb:	0f 85 42 03 00 00    	jne    5313 <gf_init+0x383>
_cpuid():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:137
    __asm__ __volatile__ ("xchgq %%rbx, %q1; cpuid; xchgq %%rbx, %q1" :
    4fd1:	31 f6                	xor    %esi,%esi
gf_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:502
        printk(KERN_INFO "Already initialized\n");
        return 0;
    }
    Initialized = true;
    4fd3:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 4fda <gf_init+0x4a>
			4fd5: R_X86_64_PC32	.bss+0xa685b
_cpuid():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:137
    __asm__ __volatile__ ("xchgq %%rbx, %q1; cpuid; xchgq %%rbx, %q1" :
    4fda:	b8 01 00 00 00       	mov    $0x1,%eax
    4fdf:	89 f1                	mov    %esi,%ecx
    4fe1:	48 87 df             	xchg   %rbx,%rdi
    4fe4:	0f a2                	cpuid  
    4fe6:	48 87 df             	xchg   %rbx,%rdi
gf_architecture_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:201
    CpuHasSSSE3 = ((cpu_info[2] & CPUID_ECX_SSSE3) != 0);
    4fe9:	89 c8                	mov    %ecx,%eax
_cpuid():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:137
    __asm__ __volatile__ ("xchgq %%rbx, %q1; cpuid; xchgq %%rbx, %q1" :
    4feb:	89 f1                	mov    %esi,%ecx
gf_architecture_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:201
    CpuHasSSSE3 = ((cpu_info[2] & CPUID_ECX_SSSE3) != 0);
    4fed:	c1 e8 09             	shr    $0x9,%eax
    4ff0:	83 e0 01             	and    $0x1,%eax
    4ff3:	88 05 00 00 00 00    	mov    %al,0x0(%rip)        # 4ff9 <gf_init+0x69>
			4ff5: R_X86_64_PC32	.bss+0xa685d
_cpuid():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:137
    __asm__ __volatile__ ("xchgq %%rbx, %q1; cpuid; xchgq %%rbx, %q1" :
    4ff9:	b8 07 00 00 00       	mov    $0x7,%eax
    4ffe:	48 87 de             	xchg   %rbx,%rsi
    5001:	0f a2                	cpuid  
    5003:	48 87 de             	xchg   %rbx,%rsi
gf_architecture_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:205
    CpuHasAVX2 = ((cpu_info[1] & CPUID_EBX_AVX2) != 0);
    5006:	c1 ee 05             	shr    $0x5,%esi
gf_explog_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:257
    logtab[0] = 512;
    5009:	b9 00 02 00 00       	mov    $0x200,%ecx
gf_poly_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:243
    GFContext.Polynomial = (GF_GEN_POLY[polynomialIndex] << 1) | 1;
    500e:	c7 05 00 00 00 00 4d 	movl   $0x14d,0x0(%rip)        # 5018 <gf_init+0x88>
    5015:	01 00 00 
			5010: R_X86_64_PC32	GFContext+0x267fc
gf_architecture_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:205
    CpuHasAVX2 = ((cpu_info[1] & CPUID_EBX_AVX2) != 0);
    5018:	41 89 f5             	mov    %esi,%r13d
gf_explog_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:257
    logtab[0] = 512;
    501b:	66 89 0d 00 00 00 00 	mov    %cx,0x0(%rip)        # 5022 <gf_init+0x92>
			501e: R_X86_64_PC32	GFContext+0x261fc
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:258
    exptab[0] = 1;
    5022:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 5029 <gf_init+0x99>
			5024: R_X86_64_PC32	GFContext+0x263fb
gf_architecture_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:205
    CpuHasAVX2 = ((cpu_info[1] & CPUID_EBX_AVX2) != 0);
    5029:	41 83 e5 01          	and    $0x1,%r13d
gf_explog_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:258
    exptab[0] = 1;
    502d:	ba 01 00 00 00       	mov    $0x1,%edx
    5032:	b8 01 00 00 00       	mov    $0x1,%eax
gf_architecture_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:205
    CpuHasAVX2 = ((cpu_info[1] & CPUID_EBX_AVX2) != 0);
    5037:	44 88 2d 00 00 00 00 	mov    %r13b,0x0(%rip)        # 503e <gf_init+0xae>
			503a: R_X86_64_PC32	.bss+0xa685e
    503e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			5041: R_X86_64_32S	GFContext+0x26400
    5045:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			5048: R_X86_64_32S	GFContext+0x26200
    504c:	eb 07                	jmp    5055 <gf_init+0xc5>
    504e:	0f b6 82 00 00 00 00 	movzbl 0x0(%rdx),%eax
			5051: R_X86_64_32S	GFContext+0x263ff
gf_explog_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:260
        unsigned next = (unsigned)exptab[jj - 1] * 2;
    5055:	01 c0                	add    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:262
            next ^= poly;
    5057:	89 c1                	mov    %eax,%ecx
    5059:	81 f1 4d 01 00 00    	xor    $0x14d,%ecx
    505f:	3d ff 00 00 00       	cmp    $0xff,%eax
    5064:	48 0f 47 c1          	cmova  %rcx,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:265
        exptab[jj] = (uint8_t)( next );
    5068:	88 04 16             	mov    %al,(%rsi,%rdx,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:266
        logtab[exptab[jj]] = (uint16_t)( jj );
    506b:	66 89 14 47          	mov    %dx,(%rdi,%rax,2)
    506f:	48 83 c2 01          	add    $0x1,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:259
    for (jj = 1; jj < 255; ++jj) {
    5073:	48 81 fa ff 00 00 00 	cmp    $0xff,%rdx
    507a:	75 d2                	jne    504e <gf_init+0xbe>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:268
    exptab[255] = exptab[0];
    507c:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # 5083 <gf_init+0xf3>
			507f: R_X86_64_PC32	GFContext+0x263fc
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:269
    logtab[exptab[255]] = 255;
    5083:	ba ff 00 00 00       	mov    $0xff,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:271
        exptab[jj] = exptab[jj % 255];
    5088:	bf 81 80 80 80       	mov    $0x80808081,%edi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:268
    exptab[255] = exptab[0];
    508d:	88 05 00 00 00 00    	mov    %al,0x0(%rip)        # 5093 <gf_init+0x103>
			508f: R_X86_64_PC32	GFContext+0x264fb
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:269
    logtab[exptab[255]] = 255;
    5093:	66 89 94 00 00 00 00 	mov    %dx,0x0(%rax,%rax,1)
    509a:	00 
			5097: R_X86_64_32S	GFContext+0x26200
    509b:	ba 00 01 00 00       	mov    $0x100,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:271
        exptab[jj] = exptab[jj % 255];
    50a0:	89 d0                	mov    %edx,%eax
    50a2:	48 0f af c7          	imul   %rdi,%rax
    50a6:	48 c1 e8 27          	shr    $0x27,%rax
    50aa:	89 c1                	mov    %eax,%ecx
    50ac:	c1 e1 08             	shl    $0x8,%ecx
    50af:	29 c1                	sub    %eax,%ecx
    50b1:	89 c8                	mov    %ecx,%eax
    50b3:	89 d1                	mov    %edx,%ecx
    50b5:	29 c1                	sub    %eax,%ecx
    50b7:	0f b6 04 0e          	movzbl (%rsi,%rcx,1),%eax
    50bb:	88 04 16             	mov    %al,(%rsi,%rdx,1)
    50be:	48 83 c2 01          	add    $0x1,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:270
    for (jj = 256; jj < 2 * 255; ++jj) {
    50c2:	48 81 fa fe 01 00 00 	cmp    $0x1fe,%rdx
    50c9:	75 d5                	jne    50a0 <gf_init+0x110>
    50cb:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
			50ce: R_X86_64_32S	GFContext+0x265ff
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:273
    exptab[2 * 255] = 1;
    50d2:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 50d9 <gf_init+0x149>
			50d4: R_X86_64_PC32	GFContext+0x265f9
    50d9:	48 8d 90 fd 01 00 00 	lea    0x1fd(%rax),%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:275
        exptab[jj] = 0;
    50e0:	c6 00 00             	movb   $0x0,(%rax)
    50e3:	48 83 c0 01          	add    $0x1,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:274
    for (jj = 2 * 255 + 1; jj < 4 * 255; ++jj) {
    50e7:	48 39 c2             	cmp    %rax,%rdx
    50ea:	75 f4                	jne    50e0 <gf_init+0x150>
    50ec:	49 c7 c2 00 00 00 00 	mov    $0x0,%r10
			50ef: R_X86_64_32S	GFContext+0x6000
    50f3:	49 8d 92 00 01 00 00 	lea    0x100(%r10),%rdx
    50fa:	4c 89 d0             	mov    %r10,%rax
gf_muldiv_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:292
        m[x] = d[x] = 0;
    50fd:	c6 80 00 00 01 00 00 	movb   $0x0,0x10000(%rax)
    5104:	c6 00 00             	movb   $0x0,(%rax)
    5107:	48 83 c0 01          	add    $0x1,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:291
    for (x = 0; x < 256; ++x) {
    510b:	48 39 c2             	cmp    %rax,%rdx
    510e:	75 ed                	jne    50fd <gf_init+0x16d>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:286
    uint8_t* m = GFContext.GF_MUL_TABLE;
    5110:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			5113: R_X86_64_32S	GFContext+0x6000
    5117:	49 c7 c3 00 00 00 00 	mov    $0x0,%r11
			511a: R_X86_64_32S	GFContext+0x26202
    511e:	48 c7 c3 00 00 00 00 	mov    $0x0,%rbx
			5121: R_X86_64_32S	GFContext
    5125:	48 8d be 00 00 02 00 	lea    0x20000(%rsi),%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:298
        const uint8_t log_y = (uint8_t)(GFContext.GF_LOG_TABLE[y]);
    512c:	41 0f b7 0b          	movzwl (%r11),%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:302
        m += 256, d += 256;
    5130:	4c 8d a6 00 01 00 00 	lea    0x100(%rsi),%r12
    5137:	4c 8d 8e 00 00 01 00 	lea    0x10000(%rsi),%r9
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:305
        m[0] = 0, d[0] = 0;
    513e:	c6 86 00 01 00 00 00 	movb   $0x0,0x100(%rsi)
    5145:	ba 01 01 00 00       	mov    $0x101,%edx
    514a:	41 c6 84 24 00 00 01 	movb   $0x0,0x10000(%r12)
    5151:	00 00 
    5153:	44 0f b6 c1          	movzbl %cl,%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:299
        const uint8_t log_yn = 255 - log_y;
    5157:	f7 d1                	not    %ecx
    5159:	0f b6 c9             	movzbl %cl,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:311
            m[x] = GFContext.GF_EXP_TABLE[log_x + log_y];
    515c:	0f b7 04 57          	movzwl (%rdi,%rdx,2),%eax
    5160:	46 8d 34 00          	lea    (%rax,%r8,1),%r14d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:312
            d[x] = GFContext.GF_EXP_TABLE[log_x + log_yn];
    5164:	01 c8                	add    %ecx,%eax
    5166:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:311
            m[x] = GFContext.GF_EXP_TABLE[log_x + log_y];
    5168:	4d 63 f6             	movslq %r14d,%r14
    516b:	46 0f b6 b4 33 00 64 	movzbl 0x26400(%rbx,%r14,1),%r14d
    5172:	02 00 
    5174:	44 88 34 16          	mov    %r14b,(%rsi,%rdx,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:312
            d[x] = GFContext.GF_EXP_TABLE[log_x + log_yn];
    5178:	0f b6 84 03 00 64 02 	movzbl 0x26400(%rbx,%rax,1),%eax
    517f:	00 
    5180:	41 88 04 11          	mov    %al,(%r9,%rdx,1)
    5184:	48 83 c2 01          	add    $0x1,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:308
        for (x = 1; x < 256; ++x) {
    5188:	48 81 fa 00 02 00 00 	cmp    $0x200,%rdx
    518f:	75 cb                	jne    515c <gf_init+0x1cc>
    5191:	49 83 c3 02          	add    $0x2,%r11
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:296
    for (y = 1; y < 256; ++y) {
    5195:	49 81 fc 00 00 00 00 	cmp    $0x0,%r12
			5198: R_X86_64_32S	GFContext+0x15f00
    519c:	4c 89 e6             	mov    %r12,%rsi
    519f:	75 8b                	jne    512c <gf_init+0x19c>
    51a1:	31 c0                	xor    %eax,%eax
    51a3:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
			51a6: R_X86_64_32S	GFContext+0x16001
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
}

//Galois Field divide
static FORCE_INLINE uint8_t gf_div(uint8_t x, uint8_t y)
{
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    51aa:	48 89 c2             	mov    %rax,%rdx
    51ad:	48 c1 e2 08          	shl    $0x8,%rdx
    51b1:	0f b6 14 11          	movzbl (%rcx,%rdx,1),%edx
gf_inv_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:325
        GFContext.GF_INV_TABLE[x] = gf_div(1, (uint8_t)(x));
    51b5:	88 14 07             	mov    %dl,(%rdi,%rax,1)
    51b8:	48 83 c0 01          	add    $0x1,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:324
    for (x = 0; x < 256; ++x) {
    51bc:	48 3d 00 01 00 00    	cmp    $0x100,%rax
    51c2:	75 e6                	jne    51aa <gf_init+0x21a>
    51c4:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
			51c7: R_X86_64_32S	GFContext+0x26100
    51cb:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
			51ce: R_X86_64_32S	GFContext+0x16100
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166
    return GFContext.GF_MUL_TABLE[((unsigned)y << 8) + x];
    51d2:	41 0f b6 12          	movzbl (%r10),%edx
    51d6:	49 81 c2 01 01 00 00 	add    $0x101,%r10
    51dd:	48 83 c0 01          	add    $0x1,%rax
gf_sqr_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:337
        GFContext.GF_SQR_TABLE[x] = gf_mul((uint8_t)(x), (uint8_t)(x));
    51e1:	88 50 ff             	mov    %dl,-0x1(%rax)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:336
    for (x = 0; x < 256; ++x) {
    51e4:	4c 39 d1             	cmp    %r10,%rcx
    51e7:	75 e9                	jne    51d2 <gf_init+0x242>
    51e9:	49 c7 c4 00 00 00 00 	mov    $0x0,%r12
			51ec: R_X86_64_32S	.bss+0xa6880
    51f0:	45 31 ff             	xor    %r15d,%r15d
    51f3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			51f6: R_X86_64_32S	GFContext+0x1000
    51fa:	4d 8d 74 24 40       	lea    0x40(%r12),%r14
    51ff:	44 89 f9             	mov    %r15d,%ecx
gf_muldiv_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:296
    for (y = 1; y < 256; ++y) {
    5202:	31 d2                	xor    %edx,%edx
    5204:	c1 e1 04             	shl    $0x4,%ecx
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166
    5207:	8d 04 11             	lea    (%rcx,%rdx,1),%eax
gf_mul_mem_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:445
            lo[x] = gf_mul(x, (uint8_t)( y ));
    520a:	0f b6 84 03 00 60 00 	movzbl 0x6000(%rbx,%rax,1),%eax
    5211:	00 
    5212:	41 88 04 14          	mov    %al,(%r12,%rdx,1)
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166
    5216:	89 d0                	mov    %edx,%eax
    5218:	c1 e0 04             	shl    $0x4,%eax
    521b:	0f b6 c0             	movzbl %al,%eax
    521e:	01 c8                	add    %ecx,%eax
gf_mul_mem_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:446
            hi[x] = gf_mul(x << 4, (uint8_t)( y ));
    5220:	0f b6 84 03 00 60 00 	movzbl 0x6000(%rbx,%rax,1),%eax
    5227:	00 
    5228:	41 88 04 16          	mov    %al,(%r14,%rdx,1)
    522c:	48 83 c2 01          	add    $0x1,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:444
        for (x = 0; x < 16; ++x) {
    5230:	48 83 fa 10          	cmp    $0x10,%rdx
    5234:	75 d1                	jne    5207 <gf_init+0x277>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:457
	table_lo = *(M128*)lo;
    5236:	c4 c1 79 6f 0c 24    	vmovdqa (%r12),%xmm1
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:463
        if (CpuHasAVX2) {
    523c:	45 84 ed             	test   %r13b,%r13b
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:458
	table_hi = *(M128*)hi;
    523f:	c5 f9 6f 05 00 00 00 	vmovdqa 0x0(%rip),%xmm0        # 5247 <gf_init+0x2b7>
    5246:	00 
			5243: R_X86_64_PC32	.bss+0xa68bc
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:460
        *(GFContext.MM128.TABLE_LO_Y + y) = table_lo;
    5247:	c4 a1 78 29 0c 3b    	vmovaps %xmm1,(%rbx,%r15,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:461
	*(GFContext.MM128.TABLE_HI_Y + y) = table_hi;
    524d:	c4 a1 78 29 04 3e    	vmovaps %xmm0,(%rsi,%r15,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:463
        if (CpuHasAVX2) {
    5253:	75 1b                	jne    5270 <gf_init+0x2e0>
    5255:	49 83 c7 10          	add    $0x10,%r15
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:441
    for (y = 0; y < 256; ++y) {
    5259:	49 81 ff 00 10 00 00 	cmp    $0x1000,%r15
    5260:	0f 84 87 00 00 00    	je     52ed <gf_init+0x35d>
    5266:	44 0f b6 2d 00 00 00 	movzbl 0x0(%rip),%r13d        # 526e <gf_init+0x2de>
    526d:	00 
			526a: R_X86_64_PC32	.bss+0xa685e
    526e:	eb 8f                	jmp    51ff <gf_init+0x26f>
    5270:	c5 f8 29 45 b0       	vmovaps %xmm0,-0x50(%rbp)
    5275:	48 89 b5 68 ff ff ff 	mov    %rsi,-0x98(%rbp)
    527c:	c5 f8 29 4d 90       	vmovaps %xmm1,-0x70(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:465
            kernel_fpu_begin();
    5281:	e8 00 00 00 00       	callq  5286 <gf_init+0x2f6>
			5282: R_X86_64_PC32	kernel_fpu_begin-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:466
            table_lo2 = (M256)__builtin_ia32_vbroadcastsi256((__v2di)table_lo);
    5286:	c5 f9 6f 4d 90       	vmovdqa -0x70(%rbp),%xmm1
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:467
            table_hi2 = (M256)__builtin_ia32_vbroadcastsi256((__v2di)table_hi);
    528b:	c5 f9 6f 45 b0       	vmovdqa -0x50(%rbp),%xmm0
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:466
            table_lo2 = (M256)__builtin_ia32_vbroadcastsi256((__v2di)table_lo);
    5290:	c4 e3 75 38 c9 01    	vinserti128 $0x1,%xmm1,%ymm1,%ymm1
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:467
            table_hi2 = (M256)__builtin_ia32_vbroadcastsi256((__v2di)table_hi);
    5296:	c4 e3 7d 38 c0 01    	vinserti128 $0x1,%xmm0,%ymm0,%ymm0
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:466
            table_lo2 = (M256)__builtin_ia32_vbroadcastsi256((__v2di)table_lo);
    529c:	c5 fd 7f 8d 70 ff ff 	vmovdqa %ymm1,-0x90(%rbp)
    52a3:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:467
            table_hi2 = (M256)__builtin_ia32_vbroadcastsi256((__v2di)table_hi);
    52a4:	c5 fd 7f 45 90       	vmovdqa %ymm0,-0x70(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:468
            kernel_fpu_end();
    52a9:	c5 f8 77             	vzeroupper 
    52ac:	e8 00 00 00 00       	callq  52b1 <gf_init+0x321>
			52ad: R_X86_64_PC32	kernel_fpu_end-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:470
            *(GFContext.MM256.TABLE_HI_Y + y) = table_hi2;
    52b1:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:469
            *(GFContext.MM256.TABLE_LO_Y + y) = table_lo2;
    52b8:	c5 fd 6f 8d 70 ff ff 	vmovdqa -0x90(%rbp),%ymm1
    52bf:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:470
            *(GFContext.MM256.TABLE_HI_Y + y) = table_hi2;
    52c0:	c5 fd 6f 45 90       	vmovdqa -0x70(%rbp),%ymm0
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:469
            *(GFContext.MM256.TABLE_LO_Y + y) = table_lo2;
    52c5:	c4 81 7d 7f 8c 3f 00 	vmovdqa %ymm1,0x0(%r15,%r15,1)
    52cc:	00 00 00 
			52cb: R_X86_64_32S	GFContext+0x2000
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:470
            *(GFContext.MM256.TABLE_HI_Y + y) = table_hi2;
    52cf:	c4 81 7d 7f 84 3f 00 	vmovdqa %ymm0,0x0(%r15,%r15,1)
    52d6:	00 00 00 
			52d5: R_X86_64_32S	GFContext+0x4000
    52d9:	c5 f8 77             	vzeroupper 
    52dc:	49 83 c7 10          	add    $0x10,%r15
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:441
    for (y = 0; y < 256; ++y) {
    52e0:	49 81 ff 00 10 00 00 	cmp    $0x1000,%r15
    52e7:	0f 85 79 ff ff ff    	jne    5266 <gf_init+0x2d6>
gf_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:518
    gf_inv_init();
    gf_sqr_init();
    gf_mul_mem_init();

    return 0;
}
    52ed:	31 c0                	xor    %eax,%eax
    52ef:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    52f3:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    52fa:	00 00 
    52fc:	75 23                	jne    5321 <gf_init+0x391>
    52fe:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
    5302:	5b                   	pop    %rbx
    5303:	41 5a                	pop    %r10
    5305:	41 5c                	pop    %r12
    5307:	41 5d                	pop    %r13
    5309:	41 5e                	pop    %r14
    530b:	41 5f                	pop    %r15
    530d:	5d                   	pop    %rbp
    530e:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    5312:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:499
        printk(KERN_INFO "Already initialized\n");
    5313:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			5316: R_X86_64_32S	.rodata.str1.1+0xa7
    531a:	e8 00 00 00 00       	callq  531f <gf_init+0x38f>
			531b: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:500
        return 0;
    531f:	eb cc                	jmp    52ed <gf_init+0x35d>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:518
}
    5321:	e8 00 00 00 00       	callq  5326 <gf_init+0x396>
			5322: R_X86_64_PC32	__stack_chk_fail-0x4
    5326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    532d:	00 00 00 

0000000000005330 <gf_add_mem>:
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:574
    return __extension__ (M128)(__v16qi){x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x};
}



void gf_add_mem(void * __restrict vx, const void * __restrict vy, int bytes){
    5330:	e8 00 00 00 00       	callq  5335 <gf_add_mem+0x5>
			5331: R_X86_64_PC32	__fentry__-0x4
    5335:	4c 8d 54 24 08       	lea    0x8(%rsp),%r10
    533a:	48 83 e4 e0          	and    $0xffffffffffffffe0,%rsp
    533e:	41 ff 72 f8          	pushq  -0x8(%r10)
    5342:	55                   	push   %rbp
    5343:	48 89 e5             	mov    %rsp,%rbp
    5346:	41 52                	push   %r10
    5348:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:635
        bytes -= (count * 8);
    }
#else // GF_ARM

# if defined(GF_AVX2)
    if (CpuHasAVX2) {
    534c:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 5353 <gf_add_mem+0x23>
			534e: R_X86_64_PC32	.bss+0xa685d
    5353:	0f 85 fe 00 00 00    	jne    5457 <gf_add_mem+0x127>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:667
        y16 = (const M128 *)(y32);
    }
    else
# endif // GF_AVX2
    {
        while (bytes >= 64) {
    5359:	83 fa 3f             	cmp    $0x3f,%edx
    535c:	7e 6f                	jle    53cd <gf_add_mem+0x9d>
    535e:	83 ea 40             	sub    $0x40,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:577
    const M128 * __restrict y16 = (const M128 *)(vy);
    5361:	48 89 f0             	mov    %rsi,%rax
    5364:	41 89 d1             	mov    %edx,%r9d
    5367:	41 c1 e9 06          	shr    $0x6,%r9d
    536b:	45 89 c8             	mov    %r9d,%r8d
    536e:	49 83 c0 01          	add    $0x1,%r8
    5372:	49 c1 e0 06          	shl    $0x6,%r8
    5376:	4a 8d 0c 07          	lea    (%rdi,%r8,1),%rcx
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    537a:	c5 f9 6f 57 10       	vmovdqa 0x10(%rdi),%xmm2
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:679
	    *x16 = x0;
	    *(x16+1) = x1;
	    *(x16+2) = x2;
	    *(x16+3) = x3;

            bytes -= 64, x16 += 4, y16 += 4;
    537f:	48 83 c7 40          	add    $0x40,%rdi
    5383:	48 83 c0 40          	add    $0x40,%rax
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    5387:	c5 f9 6f 4f e0       	vmovdqa -0x20(%rdi),%xmm1
    538c:	c5 e9 ef 50 d0       	vpxor  -0x30(%rax),%xmm2,%xmm2
    5391:	c5 f9 6f 47 f0       	vmovdqa -0x10(%rdi),%xmm0
    5396:	c5 f1 ef 48 e0       	vpxor  -0x20(%rax),%xmm1,%xmm1
    539b:	c5 f9 6f 5f c0       	vmovdqa -0x40(%rdi),%xmm3
    53a0:	c5 f9 ef 40 f0       	vpxor  -0x10(%rax),%xmm0,%xmm0
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:675
	    *(x16+1) = x1;
    53a5:	c5 f8 29 57 d0       	vmovaps %xmm2,-0x30(%rdi)
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    53aa:	c5 e1 ef 58 c0       	vpxor  -0x40(%rax),%xmm3,%xmm3
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:676
	    *(x16+2) = x2;
    53af:	c5 f8 29 4f e0       	vmovaps %xmm1,-0x20(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:677
	    *(x16+3) = x3;
    53b4:	c5 f8 29 47 f0       	vmovaps %xmm0,-0x10(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:674
	    *x16 = x0;
    53b9:	c5 f8 29 5f c0       	vmovaps %xmm3,-0x40(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:667
        while (bytes >= 64) {
    53be:	48 39 cf             	cmp    %rcx,%rdi
    53c1:	75 b7                	jne    537a <gf_add_mem+0x4a>
    53c3:	41 c1 e1 06          	shl    $0x6,%r9d
    53c7:	4c 01 c6             	add    %r8,%rsi
    53ca:	44 29 ca             	sub    %r9d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:686
    }
#endif // GF_ARM

#if !defined(GF_ARM)
    // Handle multiples of 16 bytes
    while (bytes >= 16) {
    53cd:	83 fa 0f             	cmp    $0xf,%edx
    53d0:	7e 3c                	jle    540e <gf_add_mem+0xde>
    53d2:	83 ea 10             	sub    $0x10,%edx
    53d5:	31 c0                	xor    %eax,%eax
    53d7:	41 89 d0             	mov    %edx,%r8d
    53da:	41 c1 e8 04          	shr    $0x4,%r8d
    53de:	44 89 c1             	mov    %r8d,%ecx
    53e1:	48 83 c1 01          	add    $0x1,%rcx
    53e5:	48 c1 e1 04          	shl    $0x4,%rcx
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    53e9:	c5 f9 6f 04 07       	vmovdqa (%rdi,%rax,1),%xmm0
    53ee:	c5 f9 ef 04 06       	vpxor  (%rsi,%rax,1),%xmm0,%xmm0
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:688
        // x[i] = x[i] xor y[i]
	    *x16 = vector_xor(*x16, *y16);
    53f3:	c5 f8 29 04 07       	vmovaps %xmm0,(%rdi,%rax,1)
    53f8:	48 83 c0 10          	add    $0x10,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:686
    while (bytes >= 16) {
    53fc:	48 39 c1             	cmp    %rax,%rcx
    53ff:	75 e8                	jne    53e9 <gf_add_mem+0xb9>
    5401:	41 c1 e0 04          	shl    $0x4,%r8d
    5405:	48 01 cf             	add    %rcx,%rdi
    5408:	48 01 ce             	add    %rcx,%rsi
    540b:	44 29 c2             	sub    %r8d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:698
    x1 = (uint8_t *)(x16);
    y1 = (uint8_t *)(y16);

    // Handle a block of 8 bytes
    eight = bytes & 8;
    if (eight) {
    540e:	89 d0                	mov    %edx,%eax
    5410:	83 e0 08             	and    $0x8,%eax
    5413:	74 06                	je     541b <gf_add_mem+0xeb>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:701
        uint64_t * __restrict x8 = (uint64_t *)(x1);
        const uint64_t * __restrict y8 = (const uint64_t *)(y1);
        *x8 ^= *y8;
    5415:	48 8b 0e             	mov    (%rsi),%rcx
    5418:	48 31 0f             	xor    %rcx,(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:706
    }

    // Handle a block of 4 bytes
    four = bytes & 4;
    if (four) {
    541b:	f6 c2 04             	test   $0x4,%dl
    541e:	74 08                	je     5428 <gf_add_mem+0xf8>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:707
        uint32_t * __restrict x4 = (uint32_t *)(x1 + eight);
    5420:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:709
        const uint32_t * __restrict y4 = (const uint32_t *)(y1 + eight);
        *x4 ^= *y4;
    5422:	8b 0c 06             	mov    (%rsi,%rax,1),%ecx
    5425:	31 0c 07             	xor    %ecx,(%rdi,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:713
    }

    // Handle final bytes
    offset = eight + four;
    5428:	89 d0                	mov    %edx,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:714
    switch (bytes & 3) {
    542a:	83 e2 03             	and    $0x3,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:713
    offset = eight + four;
    542d:	83 e0 0c             	and    $0xc,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:714
    switch (bytes & 3) {
    5430:	83 fa 02             	cmp    $0x2,%edx
    5433:	0f 84 06 01 00 00    	je     553f <gf_add_mem+0x20f>
    5439:	83 fa 03             	cmp    $0x3,%edx
    543c:	0f 84 e7 00 00 00    	je     5529 <gf_add_mem+0x1f9>
    5442:	83 fa 01             	cmp    $0x1,%edx
    5445:	0f 84 c9 00 00 00    	je     5514 <gf_add_mem+0x1e4>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:721
        case 2: x1[offset + 1] ^= y1[offset + 1];
        case 1: x1[offset] ^= y1[offset];
        default:
            break;
    }
}
    544b:	48 83 c4 08          	add    $0x8,%rsp
    544f:	41 5a                	pop    %r10
    5451:	5d                   	pop    %rbp
    5452:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    5456:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:639
        while (bytes >= 128) {
    5457:	83 fa 7f             	cmp    $0x7f,%edx
    545a:	7e 6f                	jle    54cb <gf_add_mem+0x19b>
    545c:	83 c2 80             	add    $0xffffff80,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:637
        const M256 * __restrict y32 = (const M256 *)(y16);
    545f:	48 89 f0             	mov    %rsi,%rax
    5462:	41 89 d1             	mov    %edx,%r9d
    5465:	41 c1 e9 07          	shr    $0x7,%r9d
    5469:	45 89 c8             	mov    %r9d,%r8d
    546c:	49 83 c0 01          	add    $0x1,%r8
    5470:	49 c1 e0 07          	shl    $0x7,%r8
    5474:	4a 8d 0c 07          	lea    (%rdi,%r8,1),%rcx
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    5478:	c5 fd 6f 4f 40       	vmovdqa 0x40(%rdi),%ymm1
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:651
            bytes -= 128, x32 += 4, y32 += 4;
    547d:	48 83 ef 80          	sub    $0xffffffffffffff80,%rdi
    5481:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    5485:	c5 fd 6f 5f 80       	vmovdqa -0x80(%rdi),%ymm3
    548a:	c5 fd 6f 50 a0       	vmovdqa -0x60(%rax),%ymm2
    548f:	c5 fd 6f 40 e0       	vmovdqa -0x20(%rax),%ymm0
    5494:	c5 ed ef 57 a0       	vpxor  -0x60(%rdi),%ymm2,%ymm2
    5499:	c5 f5 ef 48 c0       	vpxor  -0x40(%rax),%ymm1,%ymm1
    549e:	c5 fd ef 47 e0       	vpxor  -0x20(%rdi),%ymm0,%ymm0
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:647
            *(x32 + 1) = x1;
    54a3:	c5 fd 7f 57 a0       	vmovdqa %ymm2,-0x60(%rdi)
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    54a8:	c5 e5 ef 58 80       	vpxor  -0x80(%rax),%ymm3,%ymm3
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:648
            *(x32 + 2) = x2;
    54ad:	c5 fd 7f 4f c0       	vmovdqa %ymm1,-0x40(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:649
            *(x32 + 3) = x3;
    54b2:	c5 fd 7f 47 e0       	vmovdqa %ymm0,-0x20(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:646
            *(x32) = x0;
    54b7:	c5 fd 7f 5f 80       	vmovdqa %ymm3,-0x80(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:639
        while (bytes >= 128) {
    54bc:	48 39 f9             	cmp    %rdi,%rcx
    54bf:	75 b7                	jne    5478 <gf_add_mem+0x148>
    54c1:	41 c1 e1 07          	shl    $0x7,%r9d
    54c5:	4c 01 c6             	add    %r8,%rsi
    54c8:	44 29 ca             	sub    %r9d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:655
        while (bytes >= 32) {
    54cb:	83 fa 1f             	cmp    $0x1f,%edx
    54ce:	7e 73                	jle    5543 <gf_add_mem+0x213>
    54d0:	83 ea 20             	sub    $0x20,%edx
    54d3:	31 c0                	xor    %eax,%eax
    54d5:	41 89 d0             	mov    %edx,%r8d
    54d8:	41 c1 e8 05          	shr    $0x5,%r8d
    54dc:	44 89 c1             	mov    %r8d,%ecx
    54df:	48 83 c1 01          	add    $0x1,%rcx
    54e3:	48 c1 e1 05          	shl    $0x5,%rcx
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    54e7:	c5 fd 6f 04 07       	vmovdqa (%rdi,%rax,1),%ymm0
    54ec:	c5 fd ef 04 06       	vpxor  (%rsi,%rax,1),%ymm0,%ymm0
gf_add_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:657
            *(x32) = vector_xor_256(*x32, *y32);
    54f1:	c5 fd 7f 04 07       	vmovdqa %ymm0,(%rdi,%rax,1)
    54f6:	48 83 c0 20          	add    $0x20,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:655
        while (bytes >= 32) {
    54fa:	48 39 c1             	cmp    %rax,%rcx
    54fd:	75 e8                	jne    54e7 <gf_add_mem+0x1b7>
    54ff:	41 c1 e0 05          	shl    $0x5,%r8d
    5503:	48 01 cf             	add    %rcx,%rdi
    5506:	48 01 ce             	add    %rcx,%rsi
    5509:	44 29 c2             	sub    %r8d,%edx
    550c:	c5 f8 77             	vzeroupper 
    550f:	e9 b9 fe ff ff       	jmpq   53cd <gf_add_mem+0x9d>
    5514:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:717
        case 1: x1[offset] ^= y1[offset];
    5516:	0f b6 14 06          	movzbl (%rsi,%rax,1),%edx
    551a:	30 14 07             	xor    %dl,(%rdi,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:721
}
    551d:	48 83 c4 08          	add    $0x8,%rsp
    5521:	41 5a                	pop    %r10
    5523:	5d                   	pop    %rbp
    5524:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    5528:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:715
        case 3: x1[offset + 2] ^= y1[offset + 2];
    5529:	48 98                	cltq   
    552b:	0f b6 54 06 02       	movzbl 0x2(%rsi,%rax,1),%edx
    5530:	30 54 07 02          	xor    %dl,0x2(%rdi,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:716
        case 2: x1[offset + 1] ^= y1[offset + 1];
    5534:	0f b6 54 06 01       	movzbl 0x1(%rsi,%rax,1),%edx
    5539:	30 54 07 01          	xor    %dl,0x1(%rdi,%rax,1)
    553d:	eb d7                	jmp    5516 <gf_add_mem+0x1e6>
    553f:	48 98                	cltq   
    5541:	eb f1                	jmp    5534 <gf_add_mem+0x204>
    5543:	c5 f8 77             	vzeroupper 
    5546:	e9 82 fe ff ff       	jmpq   53cd <gf_add_mem+0x9d>
    554b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000005550 <gf_add2_mem>:
gf_add2_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:723

void gf_add2_mem(void * __restrict vz, const void * __restrict vx, const void * __restrict vy, int bytes) {
    5550:	e8 00 00 00 00       	callq  5555 <gf_add2_mem+0x5>
			5551: R_X86_64_PC32	__fentry__-0x4
    5555:	4c 8d 54 24 08       	lea    0x8(%rsp),%r10
    555a:	48 83 e4 e0          	and    $0xffffffffffffffe0,%rsp
    555e:	41 ff 72 f8          	pushq  -0x8(%r10)
    5562:	55                   	push   %rbp
    5563:	48 89 e5             	mov    %rsp,%rbp
    5566:	41 52                	push   %r10
    5568:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:773

        bytes -= (count * 8);
    }
#else // GF_ARM
# if defined(GF_AVX2)
    if (CpuHasAVX2) {
    556c:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 5573 <gf_add2_mem+0x23>
			556e: R_X86_64_PC32	.bss+0xa685d
    5573:	74 56                	je     55cb <gf_add2_mem+0x7b>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:779
	unsigned i;
        M256 * __restrict z32 = (M256 *)(z16);
        const M256 * __restrict x32 = (const M256 *)(x16);
        const M256 * __restrict y32 = (const M256 *)(y16);

        const unsigned count = bytes / 32;
    5575:	44 8d 41 1f          	lea    0x1f(%rcx),%r8d
    5579:	85 c9                	test   %ecx,%ecx
    557b:	44 0f 49 c1          	cmovns %ecx,%r8d
    557f:	41 c1 f8 05          	sar    $0x5,%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:780
        for (i = 0; i < count; ++i) {
    5583:	45 85 c0             	test   %r8d,%r8d
    5586:	74 2e                	je     55b6 <gf_add2_mem+0x66>
    5588:	45 8d 48 ff          	lea    -0x1(%r8),%r9d
    558c:	31 c0                	xor    %eax,%eax
    558e:	49 83 c1 01          	add    $0x1,%r9
    5592:	49 c1 e1 05          	shl    $0x5,%r9
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527 (discriminator 3)
    return (M256) ((__v4du)x ^ (__v4du)y);
    5596:	c5 fd 6f 04 06       	vmovdqa (%rsi,%rax,1),%ymm0
    559b:	c5 fd ef 04 02       	vpxor  (%rdx,%rax,1),%ymm0,%ymm0
    55a0:	c5 fd ef 04 07       	vpxor  (%rdi,%rax,1),%ymm0,%ymm0
gf_add2_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:781 (discriminator 3)
            *(z32 + i) = vector_xor_256(*(z32 + i), vector_xor_256(*(x32 + i), *(y32 + i)));
    55a5:	c5 fd 7f 04 07       	vmovdqa %ymm0,(%rdi,%rax,1)
    55aa:	48 83 c0 20          	add    $0x20,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:780 (discriminator 3)
        for (i = 0; i < count; ++i) {
    55ae:	49 39 c1             	cmp    %rax,%r9
    55b1:	75 e3                	jne    5596 <gf_add2_mem+0x46>
    55b3:	c5 f8 77             	vzeroupper 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:784
        }

        bytes -= count * 32;
    55b6:	44 89 c0             	mov    %r8d,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:785
        z16 = (M128 *)(z32 + count);
    55b9:	49 c1 e0 05          	shl    $0x5,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:784
        bytes -= count * 32;
    55bd:	c1 e0 05             	shl    $0x5,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:785
        z16 = (M128 *)(z32 + count);
    55c0:	4c 01 c7             	add    %r8,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:786
        x16 = (const M128 *)(x32 + count);
    55c3:	4c 01 c6             	add    %r8,%rsi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:784
        bytes -= count * 32;
    55c6:	29 c1                	sub    %eax,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:787
        y16 = (const M128 *)(y32 + count);
    55c8:	4c 01 c2             	add    %r8,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:792
    }
# endif // GF_AVX2

    // Handle multiples of 16 bytes
    while (bytes >= 16) {
    55cb:	83 f9 0f             	cmp    $0xf,%ecx
    55ce:	7e 44                	jle    5614 <gf_add2_mem+0xc4>
    55d0:	83 e9 10             	sub    $0x10,%ecx
    55d3:	31 c0                	xor    %eax,%eax
    55d5:	41 89 c9             	mov    %ecx,%r9d
    55d8:	41 c1 e9 04          	shr    $0x4,%r9d
    55dc:	45 89 c8             	mov    %r9d,%r8d
    55df:	49 83 c0 01          	add    $0x1,%r8
    55e3:	49 c1 e0 04          	shl    $0x4,%r8
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    55e7:	c5 f9 6f 04 06       	vmovdqa (%rsi,%rax,1),%xmm0
    55ec:	c5 f9 ef 04 02       	vpxor  (%rdx,%rax,1),%xmm0,%xmm0
    55f1:	c5 f9 ef 04 07       	vpxor  (%rdi,%rax,1),%xmm0,%xmm0
gf_add2_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:794
        // z[i] = z[i] xor x[i] xor y[i]
        *z16 = vector_xor(*z16, vector_xor(*x16, *y16));
    55f6:	c5 f8 29 04 07       	vmovaps %xmm0,(%rdi,%rax,1)
    55fb:	48 83 c0 10          	add    $0x10,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:792
    while (bytes >= 16) {
    55ff:	49 39 c0             	cmp    %rax,%r8
    5602:	75 e3                	jne    55e7 <gf_add2_mem+0x97>
    5604:	41 c1 e1 04          	shl    $0x4,%r9d
    5608:	4c 01 c6             	add    %r8,%rsi
    560b:	4c 01 c2             	add    %r8,%rdx
    560e:	44 29 c9             	sub    %r9d,%ecx
    5611:	4c 01 c7             	add    %r8,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:806
    x1 = (uint8_t *)(x16);
    y1 = (uint8_t *)(y16);

    // Handle a block of 8 bytes
    eight = bytes & 8;
    if (eight) {
    5614:	89 c8                	mov    %ecx,%eax
    5616:	83 e0 08             	and    $0x8,%eax
    5619:	74 0c                	je     5627 <gf_add2_mem+0xd7>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:810
        uint64_t * __restrict z8 = (uint64_t *)(z1);
        const uint64_t * __restrict x8 = (const uint64_t *)(x1);
        const uint64_t * __restrict y8 = (const uint64_t *)(y1);
        *z8 ^= *x8 ^ *y8;
    561b:	4c 8b 07             	mov    (%rdi),%r8
    561e:	4c 33 06             	xor    (%rsi),%r8
    5621:	4c 33 02             	xor    (%rdx),%r8
    5624:	4c 89 07             	mov    %r8,(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:815
    }

    // Handle a block of 4 bytes
    four = bytes & 4;
    if (four) {
    5627:	f6 c1 04             	test   $0x4,%cl
    562a:	74 14                	je     5640 <gf_add2_mem+0xf0>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:816
        uint32_t * __restrict z4 = (uint32_t *)(z1 + eight);
    562c:	48 98                	cltq   
    562e:	4c 8d 0c 07          	lea    (%rdi,%rax,1),%r9
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:819
        const uint32_t * __restrict x4 = (const uint32_t *)(x1 + eight);
        const uint32_t * __restrict y4 = (const uint32_t *)(y1 + eight);
        *z4 ^= *x4 ^ *y4;
    5632:	44 8b 04 06          	mov    (%rsi,%rax,1),%r8d
    5636:	45 33 01             	xor    (%r9),%r8d
    5639:	44 33 04 02          	xor    (%rdx,%rax,1),%r8d
    563d:	45 89 01             	mov    %r8d,(%r9)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:823
    }

    // Handle final bytes
    offset = eight + four;
    5640:	89 c8                	mov    %ecx,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:824
    switch (bytes & 3) {
    5642:	83 e1 03             	and    $0x3,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:823
    offset = eight + four;
    5645:	83 e0 0c             	and    $0xc,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:824
    switch (bytes & 3) {
    5648:	83 f9 02             	cmp    $0x2,%ecx
    564b:	74 5e                	je     56ab <gf_add2_mem+0x15b>
    564d:	83 f9 03             	cmp    $0x3,%ecx
    5650:	74 2d                	je     567f <gf_add2_mem+0x12f>
    5652:	83 f9 01             	cmp    $0x1,%ecx
    5655:	74 0c                	je     5663 <gf_add2_mem+0x113>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:831
        case 2: z1[offset + 1] ^= x1[offset + 1] ^ y1[offset + 1];
        case 1: z1[offset] ^= x1[offset] ^ y1[offset];
        default:
            break;
    }
}
    5657:	48 83 c4 08          	add    $0x8,%rsp
    565b:	41 5a                	pop    %r10
    565d:	5d                   	pop    %rbp
    565e:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    5662:	c3                   	retq   
    5663:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:827
        case 1: z1[offset] ^= x1[offset] ^ y1[offset];
    5665:	48 01 c7             	add    %rax,%rdi
    5668:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
    566c:	32 0f                	xor    (%rdi),%cl
    566e:	32 0c 02             	xor    (%rdx,%rax,1),%cl
    5671:	88 0f                	mov    %cl,(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:831
}
    5673:	48 83 c4 08          	add    $0x8,%rsp
    5677:	41 5a                	pop    %r10
    5679:	5d                   	pop    %rbp
    567a:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    567e:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:825
        case 3: z1[offset + 2] ^= x1[offset + 2] ^ y1[offset + 2];
    567f:	48 98                	cltq   
    5681:	4c 8d 44 07 02       	lea    0x2(%rdi,%rax,1),%r8
    5686:	0f b6 4c 06 02       	movzbl 0x2(%rsi,%rax,1),%ecx
    568b:	41 32 08             	xor    (%r8),%cl
    568e:	32 4c 02 02          	xor    0x2(%rdx,%rax,1),%cl
    5692:	41 88 08             	mov    %cl,(%r8)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:826
        case 2: z1[offset + 1] ^= x1[offset + 1] ^ y1[offset + 1];
    5695:	4c 8d 44 07 01       	lea    0x1(%rdi,%rax,1),%r8
    569a:	0f b6 4c 06 01       	movzbl 0x1(%rsi,%rax,1),%ecx
    569f:	41 32 08             	xor    (%r8),%cl
    56a2:	32 4c 02 01          	xor    0x1(%rdx,%rax,1),%cl
    56a6:	41 88 08             	mov    %cl,(%r8)
    56a9:	eb ba                	jmp    5665 <gf_add2_mem+0x115>
    56ab:	48 98                	cltq   
    56ad:	eb e6                	jmp    5695 <gf_add2_mem+0x145>
    56af:	90                   	nop

00000000000056b0 <gf_addset_mem>:
gf_addset_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:833

void gf_addset_mem(void * __restrict vz, const void * __restrict vx, const void * __restrict vy, int bytes) {
    56b0:	e8 00 00 00 00       	callq  56b5 <gf_addset_mem+0x5>
			56b1: R_X86_64_PC32	__fentry__-0x4
    56b5:	4c 8d 54 24 08       	lea    0x8(%rsp),%r10
    56ba:	48 83 e4 e0          	and    $0xffffffffffffffe0,%rsp
    56be:	41 ff 72 f8          	pushq  -0x8(%r10)
    56c2:	55                   	push   %rbp
    56c3:	48 89 e5             	mov    %rsp,%rbp
    56c6:	41 52                	push   %r10
    56c8:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:900

        bytes -= (count * 8);
    }
#else // GF_ARM
# if defined(GF_AVX2)
    if (CpuHasAVX2) {
    56cc:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 56d3 <gf_addset_mem+0x23>
			56ce: R_X86_64_PC32	.bss+0xa685d
    56d3:	0f 85 13 01 00 00    	jne    57ec <gf_addset_mem+0x13c>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:919
    }
    else
# endif // GF_AVX2
    {
        // Handle multiples of 64 bytes
        while (bytes >= 64) {
    56d9:	83 f9 3f             	cmp    $0x3f,%ecx
    56dc:	7e 7c                	jle    575a <gf_addset_mem+0xaa>
    56de:	83 e9 40             	sub    $0x40,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:836
    const M128 * __restrict y16 = (const M128*)(vy);
    56e1:	49 89 d0             	mov    %rdx,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:835
    const M128 * __restrict x16 = (const M128*)(vx);
    56e4:	48 89 f0             	mov    %rsi,%rax
    56e7:	41 89 cb             	mov    %ecx,%r11d
    56ea:	41 c1 eb 06          	shr    $0x6,%r11d
    56ee:	45 89 d9             	mov    %r11d,%r9d
    56f1:	49 83 c1 01          	add    $0x1,%r9
    56f5:	49 c1 e1 06          	shl    $0x6,%r9
    56f9:	4e 8d 14 0f          	lea    (%rdi,%r9,1),%r10
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    56fd:	c5 f9 6f 00          	vmovdqa (%rax),%xmm0
gf_addset_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:925
            *z16 = vector_xor(*x16, *y16);
            *(z16 + 1) = vector_xor(*(x16 + 1), *(y16 + 1));
            *(z16 + 2) = vector_xor(*(x16 + 2), *(y16 + 2));
            *(z16 + 3) = vector_xor(*(x16 + 3), *(y16 + 3));

            bytes -= 64, x16 += 4, y16 += 4, z16 += 4;
    5701:	48 83 c7 40          	add    $0x40,%rdi
    5705:	48 83 c0 40          	add    $0x40,%rax
    5709:	49 83 c0 40          	add    $0x40,%r8
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    570d:	c4 c1 79 ef 40 c0    	vpxor  -0x40(%r8),%xmm0,%xmm0
gf_addset_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:920
            *z16 = vector_xor(*x16, *y16);
    5713:	c5 f8 29 47 c0       	vmovaps %xmm0,-0x40(%rdi)
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    5718:	c5 f9 6f 40 d0       	vmovdqa -0x30(%rax),%xmm0
    571d:	c4 c1 79 ef 40 d0    	vpxor  -0x30(%r8),%xmm0,%xmm0
gf_addset_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:921
            *(z16 + 1) = vector_xor(*(x16 + 1), *(y16 + 1));
    5723:	c5 f8 29 47 d0       	vmovaps %xmm0,-0x30(%rdi)
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    5728:	c5 f9 6f 40 e0       	vmovdqa -0x20(%rax),%xmm0
    572d:	c4 c1 79 ef 40 e0    	vpxor  -0x20(%r8),%xmm0,%xmm0
gf_addset_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:922
            *(z16 + 2) = vector_xor(*(x16 + 2), *(y16 + 2));
    5733:	c5 f8 29 47 e0       	vmovaps %xmm0,-0x20(%rdi)
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    5738:	c5 f9 6f 40 f0       	vmovdqa -0x10(%rax),%xmm0
    573d:	c4 c1 79 ef 40 f0    	vpxor  -0x10(%r8),%xmm0,%xmm0
gf_addset_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:923
            *(z16 + 3) = vector_xor(*(x16 + 3), *(y16 + 3));
    5743:	c5 f8 29 47 f0       	vmovaps %xmm0,-0x10(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:919
        while (bytes >= 64) {
    5748:	4c 39 d7             	cmp    %r10,%rdi
    574b:	75 b0                	jne    56fd <gf_addset_mem+0x4d>
    574d:	41 c1 e3 06          	shl    $0x6,%r11d
    5751:	4c 01 ce             	add    %r9,%rsi
    5754:	4c 01 ca             	add    %r9,%rdx
    5757:	44 29 d9             	sub    %r11d,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:930
        }
    }

    // Handle multiples of 16 bytes
    while (bytes >= 16) {
    575a:	83 f9 0f             	cmp    $0xf,%ecx
    575d:	7e 3f                	jle    579e <gf_addset_mem+0xee>
    575f:	83 e9 10             	sub    $0x10,%ecx
    5762:	31 c0                	xor    %eax,%eax
    5764:	41 89 c9             	mov    %ecx,%r9d
    5767:	41 c1 e9 04          	shr    $0x4,%r9d
    576b:	45 89 c8             	mov    %r9d,%r8d
    576e:	49 83 c0 01          	add    $0x1,%r8
    5772:	49 c1 e0 04          	shl    $0x4,%r8
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    5776:	c5 f9 6f 04 06       	vmovdqa (%rsi,%rax,1),%xmm0
    577b:	c5 f9 ef 04 02       	vpxor  (%rdx,%rax,1),%xmm0,%xmm0
gf_addset_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:932
        // z[i] = x[i] xor y[i]
        *z16 = vector_xor(*x16, *y16);
    5780:	c5 f8 29 04 07       	vmovaps %xmm0,(%rdi,%rax,1)
    5785:	48 83 c0 10          	add    $0x10,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:930
    while (bytes >= 16) {
    5789:	49 39 c0             	cmp    %rax,%r8
    578c:	75 e8                	jne    5776 <gf_addset_mem+0xc6>
    578e:	41 c1 e1 04          	shl    $0x4,%r9d
    5792:	4c 01 c6             	add    %r8,%rsi
    5795:	4c 01 c2             	add    %r8,%rdx
    5798:	44 29 c9             	sub    %r9d,%ecx
    579b:	4c 01 c7             	add    %r8,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:943
    x1 = (uint8_t *)(x16);
    y1 = (uint8_t *)(y16);

    // Handle a block of 8 bytes
    eight = bytes & 8;
    if (eight) {
    579e:	89 c8                	mov    %ecx,%eax
    57a0:	83 e0 08             	and    $0x8,%eax
    57a3:	74 09                	je     57ae <gf_addset_mem+0xfe>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:947
        uint64_t * __restrict z8 = (uint64_t *)(z1);
        const uint64_t * __restrict x8 = (const uint64_t *)(x1);
        const uint64_t * __restrict y8 = (const uint64_t *)(y1);
        *z8 = *x8 ^ *y8;
    57a5:	4c 8b 06             	mov    (%rsi),%r8
    57a8:	4c 33 02             	xor    (%rdx),%r8
    57ab:	4c 89 07             	mov    %r8,(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:952
    }

    // Handle a block of 4 bytes
    four = bytes & 4;
    if (four) {
    57ae:	f6 c1 04             	test   $0x4,%cl
    57b1:	74 0e                	je     57c1 <gf_addset_mem+0x111>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:953
        uint32_t * __restrict z4 = (uint32_t *)(z1 + eight);
    57b3:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:956
        const uint32_t * __restrict x4 = (const uint32_t *)(x1 + eight);
        const uint32_t * __restrict y4 = (const uint32_t *)(y1 + eight);
        *z4 = *x4 ^ *y4;
    57b5:	44 8b 04 06          	mov    (%rsi,%rax,1),%r8d
    57b9:	44 33 04 02          	xor    (%rdx,%rax,1),%r8d
    57bd:	44 89 04 07          	mov    %r8d,(%rdi,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:960
    }

    // Handle final bytes
    offset = eight + four;
    57c1:	89 c8                	mov    %ecx,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:961
    switch (bytes & 3) {
    57c3:	83 e1 03             	and    $0x3,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:960
    offset = eight + four;
    57c6:	83 e0 0c             	and    $0xc,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:961
    switch (bytes & 3) {
    57c9:	83 f9 02             	cmp    $0x2,%ecx
    57cc:	0f 84 88 00 00 00    	je     585a <gf_addset_mem+0x1aa>
    57d2:	83 f9 03             	cmp    $0x3,%ecx
    57d5:	0f 84 90 00 00 00    	je     586b <gf_addset_mem+0x1bb>
    57db:	83 f9 01             	cmp    $0x1,%ecx
    57de:	74 62                	je     5842 <gf_addset_mem+0x192>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:968
        case 2: z1[offset + 1] = x1[offset + 1] ^ y1[offset + 1];
        case 1: z1[offset] = x1[offset] ^ y1[offset];
        default:
            break;
    }
}
    57e0:	48 83 c4 08          	add    $0x8,%rsp
    57e4:	41 5a                	pop    %r10
    57e6:	5d                   	pop    %rbp
    57e7:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    57eb:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:905
        const unsigned count = bytes / 32;
    57ec:	44 8d 41 1f          	lea    0x1f(%rcx),%r8d
    57f0:	85 c9                	test   %ecx,%ecx
    57f2:	44 0f 49 c1          	cmovns %ecx,%r8d
    57f6:	41 c1 f8 05          	sar    $0x5,%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:906
        for (i = 0; i < count; ++i) {
    57fa:	45 85 c0             	test   %r8d,%r8d
    57fd:	74 29                	je     5828 <gf_addset_mem+0x178>
    57ff:	45 8d 48 ff          	lea    -0x1(%r8),%r9d
    5803:	31 c0                	xor    %eax,%eax
    5805:	49 83 c1 01          	add    $0x1,%r9
    5809:	49 c1 e1 05          	shl    $0x5,%r9
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527 (discriminator 3)
    return (M256) ((__v4du)x ^ (__v4du)y);
    580d:	c5 fd 6f 04 02       	vmovdqa (%rdx,%rax,1),%ymm0
    5812:	c5 fd ef 04 06       	vpxor  (%rsi,%rax,1),%ymm0,%ymm0
gf_addset_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:907 (discriminator 3)
            *(z32 + i) = vector_xor_256(*(x32 + i), *(y32 + i));
    5817:	c5 fd 7f 04 07       	vmovdqa %ymm0,(%rdi,%rax,1)
    581c:	48 83 c0 20          	add    $0x20,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:906 (discriminator 3)
        for (i = 0; i < count; ++i) {
    5820:	4c 39 c8             	cmp    %r9,%rax
    5823:	75 e8                	jne    580d <gf_addset_mem+0x15d>
    5825:	c5 f8 77             	vzeroupper 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:910
        bytes -= count * 32;
    5828:	44 89 c0             	mov    %r8d,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:911
        z16 = (M128 *)(z32 + count);
    582b:	49 c1 e0 05          	shl    $0x5,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:910
        bytes -= count * 32;
    582f:	c1 e0 05             	shl    $0x5,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:911
        z16 = (M128 *)(z32 + count);
    5832:	4c 01 c7             	add    %r8,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:912
        x16 = (const M128 *)(x32 + count);
    5835:	4c 01 c6             	add    %r8,%rsi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:910
        bytes -= count * 32;
    5838:	29 c1                	sub    %eax,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:913
        y16 = (const M128 *)(y32 + count);
    583a:	4c 01 c2             	add    %r8,%rdx
    583d:	e9 18 ff ff ff       	jmpq   575a <gf_addset_mem+0xaa>
    5842:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:964
        case 1: z1[offset] = x1[offset] ^ y1[offset];
    5844:	0f b6 0c 06          	movzbl (%rsi,%rax,1),%ecx
    5848:	32 0c 02             	xor    (%rdx,%rax,1),%cl
    584b:	88 0c 07             	mov    %cl,(%rdi,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:968
}
    584e:	48 83 c4 08          	add    $0x8,%rsp
    5852:	41 5a                	pop    %r10
    5854:	5d                   	pop    %rbp
    5855:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    5859:	c3                   	retq   
    585a:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:963
        case 2: z1[offset + 1] = x1[offset + 1] ^ y1[offset + 1];
    585c:	0f b6 4c 06 01       	movzbl 0x1(%rsi,%rax,1),%ecx
    5861:	32 4c 02 01          	xor    0x1(%rdx,%rax,1),%cl
    5865:	88 4c 07 01          	mov    %cl,0x1(%rdi,%rax,1)
    5869:	eb d9                	jmp    5844 <gf_addset_mem+0x194>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:962
        case 3: z1[offset + 2] = x1[offset + 2] ^ y1[offset + 2];
    586b:	48 98                	cltq   
    586d:	0f b6 4c 06 02       	movzbl 0x2(%rsi,%rax,1),%ecx
    5872:	32 4c 02 02          	xor    0x2(%rdx,%rax,1),%cl
    5876:	88 4c 07 02          	mov    %cl,0x2(%rdi,%rax,1)
    587a:	eb e0                	jmp    585c <gf_addset_mem+0x1ac>
    587c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000005880 <gf_mul_mem>:
gf_mul_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:970

void gf_mul_mem(void * __restrict vz, const void * __restrict vx, uint8_t y, int bytes) {
    5880:	e8 00 00 00 00       	callq  5885 <gf_mul_mem+0x5>
			5881: R_X86_64_PC32	__fentry__-0x4
    5885:	4c 8d 54 24 08       	lea    0x8(%rsp),%r10
    588a:	48 83 e4 e0          	and    $0xffffffffffffffe0,%rsp
    588e:	41 ff 72 f8          	pushq  -0x8(%r10)
    5892:	55                   	push   %rbp
    5893:	48 89 e5             	mov    %rsp,%rbp
    5896:	41 57                	push   %r15
    5898:	41 56                	push   %r14
    589a:	41 55                	push   %r13
    589c:	41 54                	push   %r12
    589e:	49 89 ff             	mov    %rdi,%r15
    58a1:	41 52                	push   %r10
    58a3:	53                   	push   %rbx
    58a4:	49 89 f5             	mov    %rsi,%r13
    58a7:	89 d3                	mov    %edx,%ebx
    58a9:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:979
    uint8_t * __restrict z1;
    uint8_t * __restrict x1;
    uint8_t * __restrict table;
    int offset, four;
    // Use a single if-statement to handle special cases
    if (y <= 1) {
    58b0:	80 fa 01             	cmp    $0x1,%dl
    58b3:	0f 86 49 03 00 00    	jbe    5c02 <gf_mul_mem+0x382>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1018
        } while (bytes >= 16);
    }
#endif
#else
# if defined(GF_AVX2)
    if (bytes >= 32 && CpuHasAVX2) {
    58b9:	83 f9 1f             	cmp    $0x1f,%ecx
    58bc:	44 0f b6 e2          	movzbl %dl,%r12d
    58c0:	0f 8f 58 01 00 00    	jg     5a1e <gf_mul_mem+0x19e>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1052

        z16 = (M128 *)(z32);
        x16 = (const M128 *)(x32);
    }
# endif // GF_AVX2
    if (bytes >= 16 && CpuHasSSSE3) {
    58c6:	83 f9 0f             	cmp    $0xf,%ecx
    58c9:	0f 8f 4d 02 00 00    	jg     5b1c <gf_mul_mem+0x29c>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1082
    }
#endif

    z1 = (uint8_t*)(z16);
    x1 = (uint8_t*)(x16);
    table = GFContext.GF_MUL_TABLE + ((unsigned)y << 8);
    58cf:	48 c1 e3 08          	shl    $0x8,%rbx
    58d3:	81 e3 00 ff 00 00    	and    $0xff00,%ebx
    58d9:	48 81 c3 00 00 00 00 	add    $0x0,%rbx
			58dc: R_X86_64_32S	GFContext+0x6000
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1084
    // Handle blocks of 8 bytes
    while (bytes >= 8) {
    58e0:	83 f9 07             	cmp    $0x7,%ecx
    58e3:	0f 8e ba 00 00 00    	jle    59a3 <gf_mul_mem+0x123>
    58e9:	83 e9 08             	sub    $0x8,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1056
        table_hi_y = *(GFContext.MM128.TABLE_HI_Y + y);
    58ec:	4c 89 fa             	mov    %r15,%rdx
    58ef:	41 89 c9             	mov    %ecx,%r9d
    58f2:	41 c1 e9 03          	shr    $0x3,%r9d
    58f6:	44 89 c8             	mov    %r9d,%eax
    58f9:	4c 8d 14 c5 08 00 00 	lea    0x8(,%rax,8),%r10
    5900:	00 
    5901:	4f 8d 44 15 00       	lea    0x0(%r13,%r10,1),%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1086
        uint64_t * __restrict z8 = (uint64_t *)(z1);
        uint64_t word = table[x1[0]];
    5906:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1088
        word |= (uint64_t)table[x1[1]] << 8;
        word |= (uint64_t)table[x1[2]] << 16;
    590b:	45 0f b6 5d 02       	movzbl 0x2(%r13),%r11d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1096
        word |= (uint64_t)table[x1[5]] << 40;
        word |= (uint64_t)table[x1[6]] << 48;
        word |= (uint64_t)table[x1[7]] << 56;
        *z8 = word;

        bytes -= 8, x1 += 8, z1 += 8;
    5910:	49 83 c5 08          	add    $0x8,%r13
    5914:	48 83 c2 08          	add    $0x8,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1086
        uint64_t word = table[x1[0]];
    5918:	44 0f b6 24 03       	movzbl (%rbx,%rax,1),%r12d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1087
        word |= (uint64_t)table[x1[1]] << 8;
    591d:	41 0f b6 45 f9       	movzbl -0x7(%r13),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1088
        word |= (uint64_t)table[x1[2]] << 16;
    5922:	46 0f b6 1c 1b       	movzbl (%rbx,%r11,1),%r11d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1087
        word |= (uint64_t)table[x1[1]] << 8;
    5927:	0f b6 04 03          	movzbl (%rbx,%rax,1),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1088
        word |= (uint64_t)table[x1[2]] << 16;
    592b:	49 c1 e3 10          	shl    $0x10,%r11
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1087
        word |= (uint64_t)table[x1[1]] << 8;
    592f:	48 c1 e0 08          	shl    $0x8,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1088
        word |= (uint64_t)table[x1[2]] << 16;
    5933:	4c 09 d8             	or     %r11,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1089
        word |= (uint64_t)table[x1[3]] << 24;
    5936:	45 0f b6 5d fb       	movzbl -0x5(%r13),%r11d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1088
        word |= (uint64_t)table[x1[2]] << 16;
    593b:	4c 09 e0             	or     %r12,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1089
        word |= (uint64_t)table[x1[3]] << 24;
    593e:	46 0f b6 1c 1b       	movzbl (%rbx,%r11,1),%r11d
    5943:	49 c1 e3 18          	shl    $0x18,%r11
    5947:	4c 09 d8             	or     %r11,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1090
        word |= (uint64_t)table[x1[4]] << 32;
    594a:	45 0f b6 5d fc       	movzbl -0x4(%r13),%r11d
    594f:	46 0f b6 1c 1b       	movzbl (%rbx,%r11,1),%r11d
    5954:	49 c1 e3 20          	shl    $0x20,%r11
    5958:	4c 09 d8             	or     %r11,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1091
        word |= (uint64_t)table[x1[5]] << 40;
    595b:	45 0f b6 5d fd       	movzbl -0x3(%r13),%r11d
    5960:	46 0f b6 1c 1b       	movzbl (%rbx,%r11,1),%r11d
    5965:	49 c1 e3 28          	shl    $0x28,%r11
    5969:	49 09 c3             	or     %rax,%r11
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1092
        word |= (uint64_t)table[x1[6]] << 48;
    596c:	41 0f b6 45 fe       	movzbl -0x2(%r13),%eax
    5971:	0f b6 04 03          	movzbl (%rbx,%rax,1),%eax
    5975:	48 c1 e0 30          	shl    $0x30,%rax
    5979:	49 09 c3             	or     %rax,%r11
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1093
        word |= (uint64_t)table[x1[7]] << 56;
    597c:	41 0f b6 45 ff       	movzbl -0x1(%r13),%eax
    5981:	0f b6 04 03          	movzbl (%rbx,%rax,1),%eax
    5985:	48 c1 e0 38          	shl    $0x38,%rax
    5989:	4c 09 d8             	or     %r11,%rax
    598c:	48 89 42 f8          	mov    %rax,-0x8(%rdx)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1084
    while (bytes >= 8) {
    5990:	4d 39 c5             	cmp    %r8,%r13
    5993:	0f 85 6d ff ff ff    	jne    5906 <gf_mul_mem+0x86>
    5999:	41 f7 d9             	neg    %r9d
    599c:	4d 01 d7             	add    %r10,%r15
    599f:	42 8d 0c c9          	lea    (%rcx,%r9,8),%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1101
    }

    // Handle a block of 4 bytes
    four = bytes & 4;
    if (four) {
    59a3:	89 c8                	mov    %ecx,%eax
    59a5:	83 e0 04             	and    $0x4,%eax
    59a8:	74 3e                	je     59e8 <gf_mul_mem+0x168>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1103
        uint32_t * __restrict z4 = (uint32_t *)(z1);
        uint32_t word = table[x1[0]];
    59aa:	41 0f b6 55 00       	movzbl 0x0(%r13),%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1105
        word |= (uint32_t)table[x1[1]] << 8;
        word |= (uint32_t)table[x1[2]] << 16;
    59af:	45 0f b6 45 02       	movzbl 0x2(%r13),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1103
        uint32_t word = table[x1[0]];
    59b4:	44 0f b6 0c 13       	movzbl (%rbx,%rdx,1),%r9d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1104
        word |= (uint32_t)table[x1[1]] << 8;
    59b9:	41 0f b6 55 01       	movzbl 0x1(%r13),%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1105
        word |= (uint32_t)table[x1[2]] << 16;
    59be:	46 0f b6 04 03       	movzbl (%rbx,%r8,1),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1104
        word |= (uint32_t)table[x1[1]] << 8;
    59c3:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1105
        word |= (uint32_t)table[x1[2]] << 16;
    59c7:	41 c1 e0 10          	shl    $0x10,%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1104
        word |= (uint32_t)table[x1[1]] << 8;
    59cb:	c1 e2 08             	shl    $0x8,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1105
        word |= (uint32_t)table[x1[2]] << 16;
    59ce:	44 09 c2             	or     %r8d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1106
        word |= (uint32_t)table[x1[3]] << 24;
    59d1:	45 0f b6 45 03       	movzbl 0x3(%r13),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1105
        word |= (uint32_t)table[x1[2]] << 16;
    59d6:	44 09 ca             	or     %r9d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1106
        word |= (uint32_t)table[x1[3]] << 24;
    59d9:	46 0f b6 04 03       	movzbl (%rbx,%r8,1),%r8d
    59de:	41 c1 e0 18          	shl    $0x18,%r8d
    59e2:	44 09 c2             	or     %r8d,%edx
    59e5:	41 89 17             	mov    %edx,(%r15)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1112
        *z4 = word;
    }

    // Handle single bytes
    offset = four;
    switch (bytes & 3) {
    59e8:	83 e1 03             	and    $0x3,%ecx
    59eb:	83 f9 02             	cmp    $0x2,%ecx
    59ee:	0f 84 84 02 00 00    	je     5c78 <gf_mul_mem+0x3f8>
    59f4:	83 f9 03             	cmp    $0x3,%ecx
    59f7:	0f 84 59 02 00 00    	je     5c56 <gf_mul_mem+0x3d6>
    59fd:	83 f9 01             	cmp    $0x1,%ecx
    5a00:	0f 84 3b 02 00 00    	je     5c41 <gf_mul_mem+0x3c1>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1119
        case 2: z1[offset + 1] = table[x1[offset + 1]];
        case 1: z1[offset] = table[x1[offset]];
        default:
            break;
    }
}
    5a06:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    5a0d:	5b                   	pop    %rbx
    5a0e:	41 5a                	pop    %r10
    5a10:	41 5c                	pop    %r12
    5a12:	41 5d                	pop    %r13
    5a14:	41 5e                	pop    %r14
    5a16:	41 5f                	pop    %r15
    5a18:	5d                   	pop    %rbp
    5a19:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    5a1d:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1018 (discriminator 1)
    if (bytes >= 32 && CpuHasAVX2) {
    5a1e:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 5a25 <gf_mul_mem+0x1a5>
			5a20: R_X86_64_PC32	.bss+0xa685d
    5a25:	0f 84 f1 00 00 00    	je     5b1c <gf_mul_mem+0x29c>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1023
        table_lo_y = *(GFContext.MM256.TABLE_LO_Y + y);
    5a2b:	41 0f b6 c4          	movzbl %r12b,%eax
    5a2f:	48 c1 e0 05          	shl    $0x5,%rax
    5a33:	c5 fd 6f b0 00 00 00 	vmovdqa 0x0(%rax),%ymm6
    5a3a:	00 
			5a37: R_X86_64_32S	GFContext+0x4000
    5a3b:	c5 fd 6f b8 00 00 00 	vmovdqa 0x0(%rax),%ymm7
    5a42:	00 
			5a3f: R_X86_64_32S	GFContext+0x2000
    5a43:	8d 41 e0             	lea    -0x20(%rcx),%eax
    5a46:	c5 fd 7f b5 50 ff ff 	vmovdqa %ymm6,-0xb0(%rbp)
    5a4d:	ff 
    5a4e:	89 85 70 ff ff ff    	mov    %eax,-0x90(%rbp)
    5a54:	c1 e8 05             	shr    $0x5,%eax
    5a57:	c5 fd 7f bd 30 ff ff 	vmovdqa %ymm7,-0xd0(%rbp)
    5a5e:	ff 
    5a5f:	41 89 c6             	mov    %eax,%r14d
    5a62:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
    5a68:	49 83 c6 01          	add    $0x1,%r14
    5a6c:	49 c1 e6 05          	shl    $0x5,%r14
    5a70:	4a 8d 04 37          	lea    (%rdi,%r14,1),%rax
    5a74:	4c 89 b5 78 ff ff ff 	mov    %r14,-0x88(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1024
        table_hi_y = *(GFContext.MM256.TABLE_HI_Y + y);
    5a7b:	49 89 f6             	mov    %rsi,%r14
    5a7e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1035 (discriminator 1)
            x0 = *(x32);
    5a82:	c4 c1 7d 6f 06       	vmovdqa (%r14),%ymm0
    5a87:	c5 fd 7f 45 b0       	vmovdqa %ymm0,-0x50(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1037 (discriminator 1)
            kernel_fpu_begin();
    5a8c:	c5 f8 77             	vzeroupper 
    5a8f:	e8 00 00 00 00       	callq  5a94 <gf_mul_mem+0x214>
			5a90: R_X86_64_PC32	kernel_fpu_begin-0x4
vector_srli_epi64_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:535 (discriminator 1)
    return (M256) __builtin_ia32_psrlqi256 ((__v4di)x, y);
    5a94:	c5 fd 6f 45 b0       	vmovdqa -0x50(%rbp),%ymm0
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539 (discriminator 1)
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    5a99:	c5 fd 6f 9d 30 ff ff 	vmovdqa -0xd0(%rbp),%ymm3
    5aa0:	ff 
vector_srli_epi64_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:535 (discriminator 1)
    return (M256) __builtin_ia32_psrlqi256 ((__v4di)x, y);
    5aa1:	c5 f5 73 d0 04       	vpsrlq $0x4,%ymm0,%ymm1
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531 (discriminator 1)
    return (M256) ((__v4du)x & (__v4du)y);
    5aa6:	c5 fd db 05 00 00 00 	vpand  0x0(%rip),%ymm0,%ymm0        # 5aae <gf_mul_mem+0x22e>
    5aad:	00 
			5aaa: R_X86_64_PC32	.LC2-0x4
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539 (discriminator 1)
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    5aae:	c5 fd 6f ad 50 ff ff 	vmovdqa -0xb0(%rbp),%ymm5
    5ab5:	ff 
    5ab6:	c4 e2 65 00 d0       	vpshufb %ymm0,%ymm3,%ymm2
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531 (discriminator 1)
    return (M256) ((__v4du)x & (__v4du)y);
    5abb:	c5 f5 db 05 00 00 00 	vpand  0x0(%rip),%ymm1,%ymm0        # 5ac3 <gf_mul_mem+0x243>
    5ac2:	00 
			5abf: R_X86_64_PC32	.LC2-0x4
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539 (discriminator 1)
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    5ac3:	c5 fd 7f 55 b0       	vmovdqa %ymm2,-0x50(%rbp)
    5ac8:	c4 e2 55 00 e0       	vpshufb %ymm0,%ymm5,%ymm4
    5acd:	c5 fd 7f 65 90       	vmovdqa %ymm4,-0x70(%rbp)
gf_mul_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1042 (discriminator 1)
            kernel_fpu_end();
    5ad2:	c5 f8 77             	vzeroupper 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1045 (discriminator 1)
            bytes -= 32, ++x32, ++z32;
    5ad5:	49 83 c6 20          	add    $0x20,%r14
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1042 (discriminator 1)
            kernel_fpu_end();
    5ad9:	e8 00 00 00 00       	callq  5ade <gf_mul_mem+0x25e>
			5ada: R_X86_64_PC32	kernel_fpu_end-0x4
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527 (discriminator 1)
    return (M256) ((__v4du)x ^ (__v4du)y);
    5ade:	c5 fd 6f 75 90       	vmovdqa -0x70(%rbp),%ymm6
gf_mul_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1045 (discriminator 1)
            bytes -= 32, ++x32, ++z32;
    5ae3:	49 83 c7 20          	add    $0x20,%r15
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527 (discriminator 1)
    return (M256) ((__v4du)x ^ (__v4du)y);
    5ae7:	c5 cd ef 45 b0       	vpxor  -0x50(%rbp),%ymm6,%ymm0
gf_mul_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1043 (discriminator 1)
            *(z32) = vector_xor_256(l0, h0);
    5aec:	c4 c1 7d 7f 47 e0    	vmovdqa %ymm0,-0x20(%r15)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1046 (discriminator 1)
        } while (bytes >= 32);
    5af2:	4c 3b 7d 80          	cmp    -0x80(%rbp),%r15
    5af6:	75 8a                	jne    5a82 <gf_mul_mem+0x202>
    5af8:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
    5afe:	8b 8d 70 ff ff ff    	mov    -0x90(%rbp),%ecx
    5b04:	4c 03 ad 78 ff ff ff 	add    -0x88(%rbp),%r13
    5b0b:	c1 e0 05             	shl    $0x5,%eax
    5b0e:	29 c1                	sub    %eax,%ecx
    5b10:	c5 f8 77             	vzeroupper 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1052
    if (bytes >= 16 && CpuHasSSSE3) {
    5b13:	83 f9 0f             	cmp    $0xf,%ecx
    5b16:	0f 8e b3 fd ff ff    	jle    58cf <gf_mul_mem+0x4f>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1052 (discriminator 1)
    5b1c:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 5b23 <gf_mul_mem+0x2a3>
			5b1e: R_X86_64_PC32	.bss+0xa685c
    5b23:	0f 84 02 01 00 00    	je     5c2b <gf_mul_mem+0x3ab>
    5b29:	8d 41 f0             	lea    -0x10(%rcx),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1055
        table_lo_y = *(GFContext.MM128.TABLE_LO_Y + y);
    5b2c:	49 c1 e4 04          	shl    $0x4,%r12
    5b30:	c4 c1 79 6f b4 24 00 	vmovdqa 0x0(%r12),%xmm6
    5b37:	00 00 00 
			5b36: R_X86_64_32S	GFContext+0x1000
    5b3a:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
    5b40:	c1 e8 04             	shr    $0x4,%eax
    5b43:	c4 c1 79 6f bc 24 00 	vmovdqa 0x0(%r12),%xmm7
    5b4a:	00 00 00 
			5b49: R_X86_64_32S	GFContext
    5b4d:	41 89 c6             	mov    %eax,%r14d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1056
        table_hi_y = *(GFContext.MM128.TABLE_HI_Y + y);
    5b50:	4d 89 ec             	mov    %r13,%r12
    5b53:	49 83 c6 01          	add    $0x1,%r14
    5b57:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
    5b5d:	c5 f8 29 75 80       	vmovaps %xmm6,-0x80(%rbp)
    5b62:	49 c1 e6 04          	shl    $0x4,%r14
    5b66:	c5 f8 29 bd 50 ff ff 	vmovaps %xmm7,-0xb0(%rbp)
    5b6d:	ff 
    5b6e:	4c 89 b5 30 ff ff ff 	mov    %r14,-0xd0(%rbp)
    5b75:	4d 01 fe             	add    %r15,%r14
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1065 (discriminator 1)
            x0 = *(x16);
    5b78:	c4 c1 79 6f 04 24    	vmovdqa (%r12),%xmm0
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1075 (discriminator 1)
            bytes -= 16, ++x16, ++z16;
    5b7e:	49 83 c7 10          	add    $0x10,%r15
    5b82:	49 83 c4 10          	add    $0x10,%r12
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1065 (discriminator 1)
            x0 = *(x16);
    5b86:	c5 f8 29 45 b0       	vmovaps %xmm0,-0x50(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1067 (discriminator 1)
            kernel_fpu_begin();
    5b8b:	e8 00 00 00 00       	callq  5b90 <gf_mul_mem+0x310>
			5b8c: R_X86_64_PC32	kernel_fpu_begin-0x4
vector_srli_epi64():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:559 (discriminator 1)
    return (M128)__builtin_ia32_psrlqi128 ((__v2di)x, y);
    5b90:	c5 f9 6f 45 b0       	vmovdqa -0x50(%rbp),%xmm0
    5b95:	c5 f1 73 d0 04       	vpsrlq $0x4,%xmm0,%xmm1
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554 (discriminator 1)
    return (M128)((__v2du)x & (__v2du)y);
    5b9a:	c5 f9 db 05 00 00 00 	vpand  0x0(%rip),%xmm0,%xmm0        # 5ba2 <gf_mul_mem+0x322>
    5ba1:	00 
			5b9e: R_X86_64_PC32	.LC3-0x4
vector_shuffle_epi8():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:564 (discriminator 1)
    return (M128)__builtin_ia32_pshufb128((__v16qi)x, (__v16qi)y);
    5ba2:	c5 f9 6f 95 50 ff ff 	vmovdqa -0xb0(%rbp),%xmm2
    5ba9:	ff 
    5baa:	c5 f9 6f 65 80       	vmovdqa -0x80(%rbp),%xmm4
    5baf:	c4 e2 69 00 f8       	vpshufb %xmm0,%xmm2,%xmm7
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554 (discriminator 1)
    return (M128)((__v2du)x & (__v2du)y);
    5bb4:	c5 f1 db 05 00 00 00 	vpand  0x0(%rip),%xmm1,%xmm0        # 5bbc <gf_mul_mem+0x33c>
    5bbb:	00 
			5bb8: R_X86_64_PC32	.LC3-0x4
vector_shuffle_epi8():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:564 (discriminator 1)
    return (M128)__builtin_ia32_pshufb128((__v16qi)x, (__v16qi)y);
    5bbc:	c5 f8 29 7d b0       	vmovaps %xmm7,-0x50(%rbp)
    5bc1:	c4 e2 59 00 d8       	vpshufb %xmm0,%xmm4,%xmm3
    5bc6:	c5 f8 29 5d 90       	vmovaps %xmm3,-0x70(%rbp)
gf_mul_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1072 (discriminator 1)
            kernel_fpu_end();
    5bcb:	e8 00 00 00 00       	callq  5bd0 <gf_mul_mem+0x350>
			5bcc: R_X86_64_PC32	kernel_fpu_end-0x4
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549 (discriminator 1)
    return (M128)((__v2du)x ^ (__v2du)y);
    5bd0:	c5 f9 6f 6d 90       	vmovdqa -0x70(%rbp),%xmm5
    5bd5:	c5 d1 ef 45 b0       	vpxor  -0x50(%rbp),%xmm5,%xmm0
gf_mul_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1073 (discriminator 1)
            *(z16) =  vector_xor(l0, h0);
    5bda:	c4 c1 78 29 47 f0    	vmovaps %xmm0,-0x10(%r15)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1076 (discriminator 1)
        } while (bytes >= 16);
    5be0:	4d 39 f7             	cmp    %r14,%r15
    5be3:	75 93                	jne    5b78 <gf_mul_mem+0x2f8>
    5be5:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
    5beb:	8b 8d 74 ff ff ff    	mov    -0x8c(%rbp),%ecx
    5bf1:	4c 03 ad 30 ff ff ff 	add    -0xd0(%rbp),%r13
    5bf8:	c1 e0 04             	shl    $0x4,%eax
    5bfb:	29 c1                	sub    %eax,%ecx
    5bfd:	e9 cd fc ff ff       	jmpq   58cf <gf_mul_mem+0x4f>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:980
        if (y == 0) {
    5c02:	84 d2                	test   %dl,%dl
    5c04:	74 16                	je     5c1c <gf_mul_mem+0x39c>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:982
        } else if (vz != vx) {
    5c06:	48 39 f7             	cmp    %rsi,%rdi
    5c09:	0f 84 f7 fd ff ff    	je     5a06 <gf_mul_mem+0x186>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:983
            memcpy(vz, vx, bytes);
    5c0f:	48 63 d1             	movslq %ecx,%rdx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    5c12:	e8 00 00 00 00       	callq  5c17 <gf_mul_mem+0x397>
			5c13: R_X86_64_PC32	memcpy-0x4
    5c17:	e9 ea fd ff ff       	jmpq   5a06 <gf_mul_mem+0x186>
gf_mul_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:981
            memset(vz, 0, bytes);
    5c1c:	48 63 d1             	movslq %ecx,%rdx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    5c1f:	31 f6                	xor    %esi,%esi
    5c21:	e8 00 00 00 00       	callq  5c26 <gf_mul_mem+0x3a6>
			5c22: R_X86_64_PC32	memset-0x4
    5c26:	e9 db fd ff ff       	jmpq   5a06 <gf_mul_mem+0x186>
gf_mul_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1082
    table = GFContext.GF_MUL_TABLE + ((unsigned)y << 8);
    5c2b:	48 c1 e3 08          	shl    $0x8,%rbx
    5c2f:	81 e3 00 ff 00 00    	and    $0xff00,%ebx
    5c35:	48 81 c3 00 00 00 00 	add    $0x0,%rbx
			5c38: R_X86_64_32S	GFContext+0x6000
    5c3c:	e9 a8 fc ff ff       	jmpq   58e9 <gf_mul_mem+0x69>
    5c41:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1115
        case 1: z1[offset] = table[x1[offset]];
    5c43:	41 0f b6 54 05 00    	movzbl 0x0(%r13,%rax,1),%edx
    5c49:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    5c4d:	41 88 14 07          	mov    %dl,(%r15,%rax,1)
    5c51:	e9 b0 fd ff ff       	jmpq   5a06 <gf_mul_mem+0x186>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1113
        case 3: z1[offset + 2] = table[x1[offset + 2]];
    5c56:	48 98                	cltq   
    5c58:	41 0f b6 54 05 02    	movzbl 0x2(%r13,%rax,1),%edx
    5c5e:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    5c62:	41 88 54 07 02       	mov    %dl,0x2(%r15,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1114
        case 2: z1[offset + 1] = table[x1[offset + 1]];
    5c67:	41 0f b6 54 05 01    	movzbl 0x1(%r13,%rax,1),%edx
    5c6d:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    5c71:	41 88 54 07 01       	mov    %dl,0x1(%r15,%rax,1)
    5c76:	eb cb                	jmp    5c43 <gf_mul_mem+0x3c3>
    5c78:	48 98                	cltq   
    5c7a:	eb eb                	jmp    5c67 <gf_mul_mem+0x3e7>
    5c7c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000005c80 <gf_muladd_mem>:
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1121

void gf_muladd_mem(void * __restrict vz, uint8_t y, const void * __restrict vx, int bytes) {
    5c80:	e8 00 00 00 00       	callq  5c85 <gf_muladd_mem+0x5>
			5c81: R_X86_64_PC32	__fentry__-0x4
    5c85:	4c 8d 54 24 08       	lea    0x8(%rsp),%r10
    5c8a:	48 83 e4 e0          	and    $0xffffffffffffffe0,%rsp
    5c8e:	41 ff 72 f8          	pushq  -0x8(%r10)
    5c92:	55                   	push   %rbp
    5c93:	48 89 e5             	mov    %rsp,%rbp
    5c96:	41 57                	push   %r15
    5c98:	41 56                	push   %r14
    5c9a:	41 55                	push   %r13
    5c9c:	41 54                	push   %r12
    5c9e:	49 89 ff             	mov    %rdi,%r15
    5ca1:	41 52                	push   %r10
    5ca3:	53                   	push   %rbx
    5ca4:	49 89 d6             	mov    %rdx,%r14
    5ca7:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1130
    uint8_t * __restrict z1;
    uint8_t * __restrict x1;
    uint8_t * __restrict table;
    int four, offset;
    // Use a single if-statement to handle special cases
    if (y <= 1) {
    5cae:	40 80 fe 01          	cmp    $0x1,%sil
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1121
void gf_muladd_mem(void * __restrict vz, uint8_t y, const void * __restrict vx, int bytes) {
    5cb2:	40 88 b5 10 ff ff ff 	mov    %sil,-0xf0(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1130
    if (y <= 1) {
    5cb9:	0f 86 75 03 00 00    	jbe    6034 <gf_muladd_mem+0x3b4>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1170
        } while (bytes >= 16);
    }
#endif
#else // GF_ARM
# if defined(GF_AVX2)
    if (bytes >= 32 && CpuHasAVX2) {
    5cbf:	83 f9 1f             	cmp    $0x1f,%ecx
    5cc2:	89 f3                	mov    %esi,%ebx
    5cc4:	0f 8f 57 01 00 00    	jg     5e21 <gf_muladd_mem+0x1a1>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1241

        z16 = (M128 *)(z32);
        x16 = (const M128 *)(x32);
    }
# endif // GF_AVX2
    if (bytes >= 16 && CpuHasSSSE3) {
    5cca:	83 f9 0f             	cmp    $0xf,%ecx
    5ccd:	0f 8f 40 05 00 00    	jg     6213 <gf_muladd_mem+0x593>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1307
    }
#endif // GF_ARM

    z1 = (uint8_t*)(z16);
    x1 = (uint8_t*)(x16);
    table = GFContext.GF_MUL_TABLE + ((unsigned)y << 8);
    5cd3:	48 c1 e3 08          	shl    $0x8,%rbx
    5cd7:	81 e3 00 ff 00 00    	and    $0xff00,%ebx
    5cdd:	48 81 c3 00 00 00 00 	add    $0x0,%rbx
			5ce0: R_X86_64_32S	GFContext+0x6000
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1311
    

    // Handle blocks of 8 bytes
    while (bytes >= 8) {
    5ce4:	83 f9 07             	cmp    $0x7,%ecx
    5ce7:	0f 8e ba 00 00 00    	jle    5da7 <gf_muladd_mem+0x127>
    5ced:	83 e9 08             	sub    $0x8,%ecx
    5cf0:	41 89 c9             	mov    %ecx,%r9d
    5cf3:	41 c1 e9 03          	shr    $0x3,%r9d
    5cf7:	44 89 c8             	mov    %r9d,%eax
    5cfa:	4c 8d 14 c5 08 00 00 	lea    0x8(,%rax,8),%r10
    5d01:	00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1121
void gf_muladd_mem(void * __restrict vz, uint8_t y, const void * __restrict vx, int bytes) {
    5d02:	4c 89 f0             	mov    %r14,%rax
    5d05:	4b 8d 14 17          	lea    (%r15,%r10,1),%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1313
        uint64_t * __restrict z8 = (uint64_t *)(z1);
        uint64_t word = table[x1[0]];
    5d09:	44 0f b6 00          	movzbl (%rax),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1315
        word |= (uint64_t)table[x1[1]] << 8;
        word |= (uint64_t)table[x1[2]] << 16;
    5d0d:	44 0f b6 58 02       	movzbl 0x2(%rax),%r11d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1323
        word |= (uint64_t)table[x1[5]] << 40;
        word |= (uint64_t)table[x1[6]] << 48;
        word |= (uint64_t)table[x1[7]] << 56;
        *z8 ^= word;

        bytes -= 8, x1 += 8, z1 += 8;
    5d12:	48 83 c0 08          	add    $0x8,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1313
        uint64_t word = table[x1[0]];
    5d16:	46 0f b6 24 03       	movzbl (%rbx,%r8,1),%r12d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1314
        word |= (uint64_t)table[x1[1]] << 8;
    5d1b:	44 0f b6 40 f9       	movzbl -0x7(%rax),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1315
        word |= (uint64_t)table[x1[2]] << 16;
    5d20:	46 0f b6 1c 1b       	movzbl (%rbx,%r11,1),%r11d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1314
        word |= (uint64_t)table[x1[1]] << 8;
    5d25:	46 0f b6 04 03       	movzbl (%rbx,%r8,1),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1315
        word |= (uint64_t)table[x1[2]] << 16;
    5d2a:	49 c1 e3 10          	shl    $0x10,%r11
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1314
        word |= (uint64_t)table[x1[1]] << 8;
    5d2e:	49 c1 e0 08          	shl    $0x8,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1315
        word |= (uint64_t)table[x1[2]] << 16;
    5d32:	4d 09 d8             	or     %r11,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1316
        word |= (uint64_t)table[x1[3]] << 24;
    5d35:	44 0f b6 58 fb       	movzbl -0x5(%rax),%r11d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1315
        word |= (uint64_t)table[x1[2]] << 16;
    5d3a:	4d 09 e0             	or     %r12,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1316
        word |= (uint64_t)table[x1[3]] << 24;
    5d3d:	46 0f b6 1c 1b       	movzbl (%rbx,%r11,1),%r11d
    5d42:	49 c1 e3 18          	shl    $0x18,%r11
    5d46:	4d 09 d8             	or     %r11,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1317
        word |= (uint64_t)table[x1[4]] << 32;
    5d49:	44 0f b6 58 fc       	movzbl -0x4(%rax),%r11d
    5d4e:	46 0f b6 1c 1b       	movzbl (%rbx,%r11,1),%r11d
    5d53:	49 c1 e3 20          	shl    $0x20,%r11
    5d57:	4d 09 d8             	or     %r11,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1318
        word |= (uint64_t)table[x1[5]] << 40;
    5d5a:	44 0f b6 58 fd       	movzbl -0x3(%rax),%r11d
    5d5f:	46 0f b6 1c 1b       	movzbl (%rbx,%r11,1),%r11d
    5d64:	49 c1 e3 28          	shl    $0x28,%r11
    5d68:	4d 09 c3             	or     %r8,%r11
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1319
        word |= (uint64_t)table[x1[6]] << 48;
    5d6b:	44 0f b6 40 fe       	movzbl -0x2(%rax),%r8d
    5d70:	46 0f b6 04 03       	movzbl (%rbx,%r8,1),%r8d
    5d75:	49 c1 e0 30          	shl    $0x30,%r8
    5d79:	4d 09 c3             	or     %r8,%r11
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1320
        word |= (uint64_t)table[x1[7]] << 56;
    5d7c:	44 0f b6 40 ff       	movzbl -0x1(%rax),%r8d
    5d81:	46 0f b6 04 03       	movzbl (%rbx,%r8,1),%r8d
    5d86:	49 c1 e0 38          	shl    $0x38,%r8
    5d8a:	4d 09 d8             	or     %r11,%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1321
        *z8 ^= word;
    5d8d:	4d 31 07             	xor    %r8,(%r15)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1323
        bytes -= 8, x1 += 8, z1 += 8;
    5d90:	49 83 c7 08          	add    $0x8,%r15
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1311
    while (bytes >= 8) {
    5d94:	49 39 d7             	cmp    %rdx,%r15
    5d97:	0f 85 6c ff ff ff    	jne    5d09 <gf_muladd_mem+0x89>
    5d9d:	41 f7 d9             	neg    %r9d
    5da0:	4d 01 d6             	add    %r10,%r14
    5da3:	42 8d 0c c9          	lea    (%rcx,%r9,8),%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1328
    }

    // Handle a block of 4 bytes
    four = bytes & 4;
    if (four) {
    5da7:	89 c8                	mov    %ecx,%eax
    5da9:	83 e0 04             	and    $0x4,%eax
    5dac:	74 3d                	je     5deb <gf_muladd_mem+0x16b>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1330
        uint32_t * __restrict z4 = (uint32_t *)(z1);
        uint32_t word = table[x1[0]];
    5dae:	41 0f b6 16          	movzbl (%r14),%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1332
        word |= (uint32_t)table[x1[1]] << 8;
        word |= (uint32_t)table[x1[2]] << 16;
    5db2:	45 0f b6 46 02       	movzbl 0x2(%r14),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1330
        uint32_t word = table[x1[0]];
    5db7:	44 0f b6 0c 13       	movzbl (%rbx,%rdx,1),%r9d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1331
        word |= (uint32_t)table[x1[1]] << 8;
    5dbc:	41 0f b6 56 01       	movzbl 0x1(%r14),%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1332
        word |= (uint32_t)table[x1[2]] << 16;
    5dc1:	46 0f b6 04 03       	movzbl (%rbx,%r8,1),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1331
        word |= (uint32_t)table[x1[1]] << 8;
    5dc6:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1332
        word |= (uint32_t)table[x1[2]] << 16;
    5dca:	41 c1 e0 10          	shl    $0x10,%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1331
        word |= (uint32_t)table[x1[1]] << 8;
    5dce:	c1 e2 08             	shl    $0x8,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1332
        word |= (uint32_t)table[x1[2]] << 16;
    5dd1:	44 09 c2             	or     %r8d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1333
        word |= (uint32_t)table[x1[3]] << 24;
    5dd4:	45 0f b6 46 03       	movzbl 0x3(%r14),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1332
        word |= (uint32_t)table[x1[2]] << 16;
    5dd9:	44 09 ca             	or     %r9d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1333
        word |= (uint32_t)table[x1[3]] << 24;
    5ddc:	46 0f b6 04 03       	movzbl (%rbx,%r8,1),%r8d
    5de1:	41 c1 e0 18          	shl    $0x18,%r8d
    5de5:	44 09 c2             	or     %r8d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1334
        *z4 ^= word;
    5de8:	41 31 17             	xor    %edx,(%r15)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1339
    }

    // Handle single bytes
    offset = four;
    switch (bytes & 3) {
    5deb:	83 e1 03             	and    $0x3,%ecx
    5dee:	83 f9 02             	cmp    $0x2,%ecx
    5df1:	0f 84 b7 04 00 00    	je     62ae <gf_muladd_mem+0x62e>
    5df7:	83 f9 03             	cmp    $0x3,%ecx
    5dfa:	0f 84 8c 04 00 00    	je     628c <gf_muladd_mem+0x60c>
    5e00:	83 f9 01             	cmp    $0x1,%ecx
    5e03:	0f 84 6f 04 00 00    	je     6278 <gf_muladd_mem+0x5f8>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1346
        case 2: z1[offset + 1] ^= table[x1[offset + 1]];
        case 1: z1[offset] ^= table[x1[offset]];
        default:
            break;
    }
}
    5e09:	48 81 c4 20 01 00 00 	add    $0x120,%rsp
    5e10:	5b                   	pop    %rbx
    5e11:	41 5a                	pop    %r10
    5e13:	41 5c                	pop    %r12
    5e15:	41 5d                	pop    %r13
    5e17:	41 5e                	pop    %r14
    5e19:	41 5f                	pop    %r15
    5e1b:	5d                   	pop    %rbp
    5e1c:	49 8d 62 f8          	lea    -0x8(%r10),%rsp
    5e20:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1170
    if (bytes >= 32 && CpuHasAVX2) {
    5e21:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 5e28 <gf_muladd_mem+0x1a8>
			5e23: R_X86_64_PC32	.bss+0xa685d
    5e28:	0f 85 1b 02 00 00    	jne    6049 <gf_muladd_mem+0x3c9>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1241
    if (bytes >= 16 && CpuHasSSSE3) {
    5e2e:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 5e35 <gf_muladd_mem+0x1b5>
			5e30: R_X86_64_PC32	.bss+0xa685c
    5e35:	0f 84 27 04 00 00    	je     6262 <gf_muladd_mem+0x5e2>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1244
        table_lo_y = *(GFContext.MM128.TABLE_LO_Y + y);
    5e3b:	0f b6 85 10 ff ff ff 	movzbl -0xf0(%rbp),%eax
    5e42:	48 c1 e0 04          	shl    $0x4,%rax
    5e46:	c5 f9 6f a8 00 00 00 	vmovdqa 0x0(%rax),%xmm5
    5e4d:	00 
			5e4a: R_X86_64_32S	GFContext
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1245
        table_hi_y = *(GFContext.MM128.TABLE_HI_Y + y);
    5e4e:	c5 f9 6f b8 00 00 00 	vmovdqa 0x0(%rax),%xmm7
    5e55:	00 
			5e52: R_X86_64_32S	GFContext+0x1000
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1244
        table_lo_y = *(GFContext.MM128.TABLE_LO_Y + y);
    5e56:	c5 f8 29 ad d0 fe ff 	vmovaps %xmm5,-0x130(%rbp)
    5e5d:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1245
        table_hi_y = *(GFContext.MM128.TABLE_HI_Y + y);
    5e5e:	c5 f8 29 bd b0 fe ff 	vmovaps %xmm7,-0x150(%rbp)
    5e65:	ff 
    5e66:	c5 f9 6f ad d0 fe ff 	vmovdqa -0x130(%rbp),%xmm5
    5e6d:	ff 
    5e6e:	c5 f9 6f b5 b0 fe ff 	vmovdqa -0x150(%rbp),%xmm6
    5e75:	ff 
    5e76:	c5 f9 6f 0d 00 00 00 	vmovdqa 0x0(%rip),%xmm1        # 5e7e <gf_muladd_mem+0x1fe>
    5e7d:	00 
			5e7a: R_X86_64_PC32	.LC3-0x4
    5e7e:	c5 f8 29 6d 90       	vmovaps %xmm5,-0x70(%rbp)
    5e83:	c5 f8 29 b5 70 ff ff 	vmovaps %xmm6,-0x90(%rbp)
    5e8a:	ff 
    5e8b:	c5 f8 29 4d b0       	vmovaps %xmm1,-0x50(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1257
            bytes -= 32;
    5e90:	83 e9 20             	sub    $0x20,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1282
            x16 += 2, z16 += 2;
    5e93:	49 83 c6 20          	add    $0x20,%r14
    5e97:	49 83 c7 20          	add    $0x20,%r15
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1254
            x1 = *(x16 + 1);
    5e9b:	c4 c1 79 6f 46 f0    	vmovdqa -0x10(%r14),%xmm0
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1257
            bytes -= 32;
    5ea1:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1254
            x1 = *(x16 + 1);
    5ea7:	c5 f8 29 85 50 ff ff 	vmovaps %xmm0,-0xb0(%rbp)
    5eae:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1258
            kernel_fpu_begin();
    5eaf:	e8 00 00 00 00       	callq  5eb4 <gf_muladd_mem+0x234>
			5eb0: R_X86_64_PC32	kernel_fpu_begin-0x4
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5eb4:	c5 f9 6f 5d b0       	vmovdqa -0x50(%rbp),%xmm3
vector_srli_epi64():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:559
    return (M128)__builtin_ia32_psrlqi128 ((__v2di)x, y);
    5eb9:	c5 f9 6f 85 50 ff ff 	vmovdqa -0xb0(%rbp),%xmm0
    5ec0:	ff 
    5ec1:	c5 f1 73 d0 04       	vpsrlq $0x4,%xmm0,%xmm1
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5ec6:	c5 f9 db c3          	vpand  %xmm3,%xmm0,%xmm0
vector_shuffle_epi8():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:564
    return (M128)__builtin_ia32_pshufb128((__v16qi)x, (__v16qi)y);
    5eca:	c5 f9 6f 75 90       	vmovdqa -0x70(%rbp),%xmm6
    5ecf:	c4 e2 49 00 e0       	vpshufb %xmm0,%xmm6,%xmm4
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5ed4:	c5 f1 db c3          	vpand  %xmm3,%xmm1,%xmm0
vector_shuffle_epi8():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:564
    return (M128)__builtin_ia32_pshufb128((__v16qi)x, (__v16qi)y);
    5ed8:	c5 f9 6f bd 70 ff ff 	vmovdqa -0x90(%rbp),%xmm7
    5edf:	ff 
    5ee0:	c5 f8 29 a5 30 ff ff 	vmovaps %xmm4,-0xd0(%rbp)
    5ee7:	ff 
    5ee8:	c4 e2 41 00 e8       	vpshufb %xmm0,%xmm7,%xmm5
    5eed:	c5 f8 29 ad 20 ff ff 	vmovaps %xmm5,-0xe0(%rbp)
    5ef4:	ff 
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1263
            kernel_fpu_end();
    5ef5:	e8 00 00 00 00       	callq  5efa <gf_muladd_mem+0x27a>
			5ef6: R_X86_64_PC32	kernel_fpu_end-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1264
            z1 = *(z16 + 1);
    5efa:	c4 c1 79 6f 57 f0    	vmovdqa -0x10(%r15),%xmm2
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1266
            x0 = *(x16);
    5f00:	c4 c1 79 6f 46 e0    	vmovdqa -0x20(%r14),%xmm0
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1264
            z1 = *(z16 + 1);
    5f06:	c5 f8 29 95 50 ff ff 	vmovaps %xmm2,-0xb0(%rbp)
    5f0d:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1266
            x0 = *(x16);
    5f0e:	c5 f8 29 85 10 ff ff 	vmovaps %xmm0,-0xf0(%rbp)
    5f15:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1268
            kernel_fpu_begin();
    5f16:	e8 00 00 00 00       	callq  5f1b <gf_muladd_mem+0x29b>
			5f17: R_X86_64_PC32	kernel_fpu_begin-0x4
vector_srli_epi64():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:559
    return (M128)__builtin_ia32_psrlqi128 ((__v2di)x, y);
    5f1b:	c5 f9 6f 85 10 ff ff 	vmovdqa -0xf0(%rbp),%xmm0
    5f22:	ff 
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5f23:	c5 f9 6f 5d b0       	vmovdqa -0x50(%rbp),%xmm3
vector_srli_epi64():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:559
    return (M128)__builtin_ia32_psrlqi128 ((__v2di)x, y);
    5f28:	c5 f1 73 d0 04       	vpsrlq $0x4,%xmm0,%xmm1
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5f2d:	c5 f9 db c3          	vpand  %xmm3,%xmm0,%xmm0
vector_shuffle_epi8():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:564
    return (M128)__builtin_ia32_pshufb128((__v16qi)x, (__v16qi)y);
    5f31:	c5 f9 6f 75 90       	vmovdqa -0x70(%rbp),%xmm6
    5f36:	c4 e2 49 00 f0       	vpshufb %xmm0,%xmm6,%xmm6
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5f3b:	c5 f1 db c3          	vpand  %xmm3,%xmm1,%xmm0
vector_shuffle_epi8():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:564
    return (M128)__builtin_ia32_pshufb128((__v16qi)x, (__v16qi)y);
    5f3f:	c5 f9 6f bd 70 ff ff 	vmovdqa -0x90(%rbp),%xmm7
    5f46:	ff 
    5f47:	c5 f8 29 b5 10 ff ff 	vmovaps %xmm6,-0xf0(%rbp)
    5f4e:	ff 
    5f4f:	c4 e2 41 00 f8       	vpshufb %xmm0,%xmm7,%xmm7
    5f54:	c5 f8 29 bd 00 ff ff 	vmovaps %xmm7,-0x100(%rbp)
    5f5b:	ff 
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1273
            kernel_fpu_end();
    5f5c:	e8 00 00 00 00       	callq  5f61 <gf_muladd_mem+0x2e1>
			5f5d: R_X86_64_PC32	kernel_fpu_end-0x4
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    5f61:	c5 f9 6f 8d 20 ff ff 	vmovdqa -0xe0(%rbp),%xmm1
    5f68:	ff 
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1251
        while (bytes >= 32) {
    5f69:	8b 8d fc fe ff ff    	mov    -0x104(%rbp),%ecx
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    5f6f:	c5 f1 ef 85 30 ff ff 	vpxor  -0xd0(%rbp),%xmm1,%xmm0
    5f76:	ff 
    5f77:	c5 f9 6f a5 00 ff ff 	vmovdqa -0x100(%rbp),%xmm4
    5f7e:	ff 
    5f7f:	c5 f9 ef 85 50 ff ff 	vpxor  -0xb0(%rbp),%xmm0,%xmm0
    5f86:	ff 
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1277
            *(z16 + 1) = vector_xor(p1, z1);
    5f87:	c4 c1 78 29 47 f0    	vmovaps %xmm0,-0x10(%r15)
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    5f8d:	c5 d9 ef 85 10 ff ff 	vpxor  -0xf0(%rbp),%xmm4,%xmm0
    5f94:	ff 
    5f95:	c4 c1 79 ef 47 e0    	vpxor  -0x20(%r15),%xmm0,%xmm0
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1280
            *(z16) = vector_xor(p0, z0);
    5f9b:	c4 c1 78 29 47 e0    	vmovaps %xmm0,-0x20(%r15)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1251
        while (bytes >= 32) {
    5fa1:	83 f9 1f             	cmp    $0x1f,%ecx
    5fa4:	0f 8f e6 fe ff ff    	jg     5e90 <gf_muladd_mem+0x210>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1286
        while (bytes >= 16) {
    5faa:	83 f9 0f             	cmp    $0xf,%ecx
    5fad:	0f 8e 20 fd ff ff    	jle    5cd3 <gf_muladd_mem+0x53>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1289
            x0 = *(x16);
    5fb3:	c4 c1 79 6f 06       	vmovdqa (%r14),%xmm0
    5fb8:	49 83 c7 10          	add    $0x10,%r15
    5fbc:	49 83 c6 10          	add    $0x10,%r14
    5fc0:	89 8d 70 ff ff ff    	mov    %ecx,-0x90(%rbp)
    5fc6:	c5 f8 29 45 90       	vmovaps %xmm0,-0x70(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1291
            kernel_fpu_begin();
    5fcb:	e8 00 00 00 00       	callq  5fd0 <gf_muladd_mem+0x350>
			5fcc: R_X86_64_PC32	kernel_fpu_begin-0x4
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5fd0:	c5 f9 6f 7d b0       	vmovdqa -0x50(%rbp),%xmm7
vector_srli_epi64():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:559
    return (M128)__builtin_ia32_psrlqi128 ((__v2di)x, y);
    5fd5:	c5 f9 6f 45 90       	vmovdqa -0x70(%rbp),%xmm0
    5fda:	c5 f1 73 d0 04       	vpsrlq $0x4,%xmm0,%xmm1
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5fdf:	c5 f9 db c7          	vpand  %xmm7,%xmm0,%xmm0
vector_shuffle_epi8():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:564
    return (M128)__builtin_ia32_pshufb128((__v16qi)x, (__v16qi)y);
    5fe3:	c5 f9 6f b5 d0 fe ff 	vmovdqa -0x130(%rbp),%xmm6
    5fea:	ff 
    5feb:	c4 e2 49 00 e8       	vpshufb %xmm0,%xmm6,%xmm5
vector_and():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:554
    return (M128)((__v2du)x & (__v2du)y);
    5ff0:	c5 f1 db c7          	vpand  %xmm7,%xmm1,%xmm0
vector_shuffle_epi8():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:564
    return (M128)__builtin_ia32_pshufb128((__v16qi)x, (__v16qi)y);
    5ff4:	c5 f9 6f b5 b0 fe ff 	vmovdqa -0x150(%rbp),%xmm6
    5ffb:	ff 
    5ffc:	c5 f8 29 6d b0       	vmovaps %xmm5,-0x50(%rbp)
    6001:	c4 e2 49 00 f8       	vpshufb %xmm0,%xmm6,%xmm7
    6006:	c5 f8 29 7d 90       	vmovaps %xmm7,-0x70(%rbp)
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1296
            kernel_fpu_end();
    600b:	e8 00 00 00 00       	callq  6010 <gf_muladd_mem+0x390>
			600c: R_X86_64_PC32	kernel_fpu_end-0x4
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    6010:	c5 f9 6f 7d 90       	vmovdqa -0x70(%rbp),%xmm7
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1300
            bytes -= 16, ++x16, ++z16;
    6015:	8b 8d 70 ff ff ff    	mov    -0x90(%rbp),%ecx
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    601b:	c5 c1 ef 45 b0       	vpxor  -0x50(%rbp),%xmm7,%xmm0
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1300
            bytes -= 16, ++x16, ++z16;
    6020:	83 e9 10             	sub    $0x10,%ecx
vector_xor():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:549
    return (M128)((__v2du)x ^ (__v2du)y);
    6023:	c4 c1 79 ef 47 f0    	vpxor  -0x10(%r15),%xmm0,%xmm0
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1299
            *(z16) = vector_xor(p0, z0);
    6029:	c4 c1 78 29 47 f0    	vmovaps %xmm0,-0x10(%r15)
    602f:	e9 9f fc ff ff       	jmpq   5cd3 <gf_muladd_mem+0x53>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1131
        if (y == 1) {
    6034:	0f 85 cf fd ff ff    	jne    5e09 <gf_muladd_mem+0x189>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1132
            gf_add_mem(vz, vx, bytes);
    603a:	89 ca                	mov    %ecx,%edx
    603c:	4c 89 f6             	mov    %r14,%rsi
    603f:	e8 00 00 00 00       	callq  6044 <gf_muladd_mem+0x3c4>
			6040: R_X86_64_PC32	gf_add_mem-0x4
    6044:	e9 c0 fd ff ff       	jmpq   5e09 <gf_muladd_mem+0x189>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1176
        table_lo_y = *(GFContext.MM256.TABLE_LO_Y + y);
    6049:	0f b6 85 10 ff ff ff 	movzbl -0xf0(%rbp),%eax
    6050:	48 c1 e0 05          	shl    $0x5,%rax
    6054:	c5 fd 6f b8 00 00 00 	vmovdqa 0x0(%rax),%ymm7
    605b:	00 
			6058: R_X86_64_32S	GFContext+0x2000
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1177
        table_hi_y = *(GFContext.MM256.TABLE_HI_Y + y);
    605c:	c5 fd 6f a0 00 00 00 	vmovdqa 0x0(%rax),%ymm4
    6063:	00 
			6060: R_X86_64_32S	GFContext+0x4000
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1186
        count = bytes / 64;
    6064:	89 c8                	mov    %ecx,%eax
    6066:	c1 f8 06             	sar    $0x6,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1176
        table_lo_y = *(GFContext.MM256.TABLE_LO_Y + y);
    6069:	c5 fd 7f bd d0 fe ff 	vmovdqa %ymm7,-0x130(%rbp)
    6070:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1187
        for (i = 0; i < count; ++i) {
    6071:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1177
        table_hi_y = *(GFContext.MM256.TABLE_HI_Y + y);
    6073:	c5 fd 7f a5 b0 fe ff 	vmovdqa %ymm4,-0x150(%rbp)
    607a:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1186
        count = bytes / 64;
    607b:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1187
        for (i = 0; i < count; ++i) {
    6081:	0f 84 5c 01 00 00    	je     61e3 <gf_muladd_mem+0x563>
    6087:	83 e8 01             	sub    $0x1,%eax
    608a:	c5 fd 7f 7d b0       	vmovdqa %ymm7,-0x50(%rbp)
    608f:	49 89 d5             	mov    %rdx,%r13
    6092:	48 c1 e0 06          	shl    $0x6,%rax
    6096:	c5 fd 7f 65 90       	vmovdqa %ymm4,-0x70(%rbp)
    609b:	49 89 fc             	mov    %rdi,%r12
    609e:	48 8d 44 07 40       	lea    0x40(%rdi,%rax,1),%rax
    60a3:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1190
            x0 = *(x32 + i * 2);
    60aa:	c4 c1 7d 6f 45 00    	vmovdqa 0x0(%r13),%ymm0
    60b0:	89 8d 20 ff ff ff    	mov    %ecx,-0xe0(%rbp)
    60b6:	c5 fd 7f 85 70 ff ff 	vmovdqa %ymm0,-0x90(%rbp)
    60bd:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1192
            kernel_fpu_begin();
    60be:	c5 f8 77             	vzeroupper 
    60c1:	e8 00 00 00 00       	callq  60c6 <gf_muladd_mem+0x446>
			60c2: R_X86_64_PC32	kernel_fpu_begin-0x4
vector_srli_epi64_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:535
    return (M256) __builtin_ia32_psrlqi256 ((__v4di)x, y);
    60c6:	c5 fd 6f 85 70 ff ff 	vmovdqa -0x90(%rbp),%ymm0
    60cd:	ff 
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    60ce:	c5 fd 6f 65 b0       	vmovdqa -0x50(%rbp),%ymm4
vector_srli_epi64_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:535
    return (M256) __builtin_ia32_psrlqi256 ((__v4di)x, y);
    60d3:	c5 f5 73 d0 04       	vpsrlq $0x4,%ymm0,%ymm1
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531
    return (M256) ((__v4du)x & (__v4du)y);
    60d8:	c5 fd db 05 00 00 00 	vpand  0x0(%rip),%ymm0,%ymm0        # 60e0 <gf_muladd_mem+0x460>
    60df:	00 
			60dc: R_X86_64_PC32	.LC2-0x4
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1194
            z0 = *(z32 + i * 2);
    60e0:	c4 c1 7d 6f 14 24    	vmovdqa (%r12),%ymm2
    60e6:	c5 fd 7f 95 70 ff ff 	vmovdqa %ymm2,-0x90(%rbp)
    60ed:	ff 
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    60ee:	c4 e2 5d 00 e8       	vpshufb %ymm0,%ymm4,%ymm5
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531
    return (M256) ((__v4du)x & (__v4du)y);
    60f3:	c5 f5 db 05 00 00 00 	vpand  0x0(%rip),%ymm1,%ymm0        # 60fb <gf_muladd_mem+0x47b>
    60fa:	00 
			60f7: R_X86_64_PC32	.LC2-0x4
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    60fb:	c5 fd 7f ad 50 ff ff 	vmovdqa %ymm5,-0xb0(%rbp)
    6102:	ff 
    6103:	c5 fd 6f 6d 90       	vmovdqa -0x70(%rbp),%ymm5
    6108:	c4 e2 55 00 f0       	vpshufb %ymm0,%ymm5,%ymm6
    610d:	c5 fd 7f b5 30 ff ff 	vmovdqa %ymm6,-0xd0(%rbp)
    6114:	ff 
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1198
            kernel_fpu_end();
    6115:	c5 f8 77             	vzeroupper 
    6118:	e8 00 00 00 00       	callq  611d <gf_muladd_mem+0x49d>
			6119: R_X86_64_PC32	kernel_fpu_end-0x4
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    611d:	c5 fd 6f bd 30 ff ff 	vmovdqa -0xd0(%rbp),%ymm7
    6124:	ff 
    6125:	c5 c5 ef 85 50 ff ff 	vpxor  -0xb0(%rbp),%ymm7,%ymm0
    612c:	ff 
    612d:	c5 fd ef 85 70 ff ff 	vpxor  -0x90(%rbp),%ymm0,%ymm0
    6134:	ff 
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1200
            *(z32 + i * 2) =  vector_xor_256(p0, z0);
    6135:	c4 c1 7d 7f 04 24    	vmovdqa %ymm0,(%r12)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1202
            x1 = *(x32 + i * 2 + 1);
    613b:	c4 c1 7d 6f 45 20    	vmovdqa 0x20(%r13),%ymm0
    6141:	c5 fd 7f 85 70 ff ff 	vmovdqa %ymm0,-0x90(%rbp)
    6148:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1204
            kernel_fpu_begin();
    6149:	c5 f8 77             	vzeroupper 
    614c:	e8 00 00 00 00       	callq  6151 <gf_muladd_mem+0x4d1>
			614d: R_X86_64_PC32	kernel_fpu_begin-0x4
vector_srli_epi64_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:535
    return (M256) __builtin_ia32_psrlqi256 ((__v4di)x, y);
    6151:	c5 fd 6f 85 70 ff ff 	vmovdqa -0x90(%rbp),%ymm0
    6158:	ff 
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    6159:	c5 fd 6f 65 b0       	vmovdqa -0x50(%rbp),%ymm4
vector_srli_epi64_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:535
    return (M256) __builtin_ia32_psrlqi256 ((__v4di)x, y);
    615e:	c5 f5 73 d0 04       	vpsrlq $0x4,%ymm0,%ymm1
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531
    return (M256) ((__v4du)x & (__v4du)y);
    6163:	c5 fd db 05 00 00 00 	vpand  0x0(%rip),%ymm0,%ymm0        # 616b <gf_muladd_mem+0x4eb>
    616a:	00 
			6167: R_X86_64_PC32	.LC2-0x4
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    616b:	c5 fd 6f 6d 90       	vmovdqa -0x70(%rbp),%ymm5
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1206
            z1 = *(z32 + i * 2 + 1);
    6170:	c4 c1 7d 6f 54 24 20 	vmovdqa 0x20(%r12),%ymm2
    6177:	c5 fd 7f 95 70 ff ff 	vmovdqa %ymm2,-0x90(%rbp)
    617e:	ff 
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    617f:	c4 e2 5d 00 e0       	vpshufb %ymm0,%ymm4,%ymm4
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531
    return (M256) ((__v4du)x & (__v4du)y);
    6184:	c5 f5 db 05 00 00 00 	vpand  0x0(%rip),%ymm1,%ymm0        # 618c <gf_muladd_mem+0x50c>
    618b:	00 
			6188: R_X86_64_PC32	.LC2-0x4
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    618c:	c5 fd 7f a5 50 ff ff 	vmovdqa %ymm4,-0xb0(%rbp)
    6193:	ff 
    6194:	c4 e2 55 00 e8       	vpshufb %ymm0,%ymm5,%ymm5
    6199:	c5 fd 7f ad 30 ff ff 	vmovdqa %ymm5,-0xd0(%rbp)
    61a0:	ff 
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1210
            kernel_fpu_end();
    61a1:	c5 f8 77             	vzeroupper 
    61a4:	49 83 c5 40          	add    $0x40,%r13
    61a8:	e8 00 00 00 00       	callq  61ad <gf_muladd_mem+0x52d>
			61a9: R_X86_64_PC32	kernel_fpu_end-0x4
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    61ad:	c5 fd 6f b5 30 ff ff 	vmovdqa -0xd0(%rbp),%ymm6
    61b4:	ff 
    61b5:	49 83 c4 40          	add    $0x40,%r12
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1187
        for (i = 0; i < count; ++i) {
    61b9:	8b 8d 20 ff ff ff    	mov    -0xe0(%rbp),%ecx
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    61bf:	c5 cd ef 85 50 ff ff 	vpxor  -0xb0(%rbp),%ymm6,%ymm0
    61c6:	ff 
    61c7:	c5 fd ef 85 70 ff ff 	vpxor  -0x90(%rbp),%ymm0,%ymm0
    61ce:	ff 
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1212
            *(z32 + i * 2 + 1) =  vector_xor_256(p1, z1);
    61cf:	c4 c1 7d 7f 44 24 e0 	vmovdqa %ymm0,-0x20(%r12)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1187
        for (i = 0; i < count; ++i) {
    61d6:	4c 39 a5 00 ff ff ff 	cmp    %r12,-0x100(%rbp)
    61dd:	0f 85 c7 fe ff ff    	jne    60aa <gf_muladd_mem+0x42a>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1214
        bytes -= count * 64;
    61e3:	8b b5 fc fe ff ff    	mov    -0x104(%rbp),%esi
    61e9:	89 f0                	mov    %esi,%eax
    61eb:	c1 e0 06             	shl    $0x6,%eax
    61ee:	29 c1                	sub    %eax,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1215
        z32 += count * 2;
    61f0:	89 f0                	mov    %esi,%eax
    61f2:	01 c0                	add    %eax,%eax
    61f4:	48 c1 e0 05          	shl    $0x5,%rax
    61f8:	49 01 c7             	add    %rax,%r15
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1216
        x32 += count * 2;
    61fb:	49 01 c6             	add    %rax,%r14
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1218
        if (bytes >= 32) {
    61fe:	83 f9 1f             	cmp    $0x1f,%ecx
    6201:	0f 8f ab 00 00 00    	jg     62b2 <gf_muladd_mem+0x632>
    6207:	c5 f8 77             	vzeroupper 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1241
    if (bytes >= 16 && CpuHasSSSE3) {
    620a:	83 f9 0f             	cmp    $0xf,%ecx
    620d:	0f 8e c0 fa ff ff    	jle    5cd3 <gf_muladd_mem+0x53>
    6213:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0(%rip)        # 621a <gf_muladd_mem+0x59a>
			6215: R_X86_64_PC32	.bss+0xa685c
    621a:	74 46                	je     6262 <gf_muladd_mem+0x5e2>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1244
        table_lo_y = *(GFContext.MM128.TABLE_LO_Y + y);
    621c:	0f b6 85 10 ff ff ff 	movzbl -0xf0(%rbp),%eax
    6223:	48 c1 e0 04          	shl    $0x4,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1251
        while (bytes >= 32) {
    6227:	83 f9 1f             	cmp    $0x1f,%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1244
        table_lo_y = *(GFContext.MM128.TABLE_LO_Y + y);
    622a:	c5 f9 6f b8 00 00 00 	vmovdqa 0x0(%rax),%xmm7
    6231:	00 
			622e: R_X86_64_32S	GFContext
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1245
        table_hi_y = *(GFContext.MM128.TABLE_HI_Y + y);
    6232:	c5 f9 6f a0 00 00 00 	vmovdqa 0x0(%rax),%xmm4
    6239:	00 
			6236: R_X86_64_32S	GFContext+0x1000
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1244
        table_lo_y = *(GFContext.MM128.TABLE_LO_Y + y);
    623a:	c5 f8 29 bd d0 fe ff 	vmovaps %xmm7,-0x130(%rbp)
    6241:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1245
        table_hi_y = *(GFContext.MM128.TABLE_HI_Y + y);
    6242:	c5 f8 29 a5 b0 fe ff 	vmovaps %xmm4,-0x150(%rbp)
    6249:	ff 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1251
        while (bytes >= 32) {
    624a:	0f 8f 16 fc ff ff    	jg     5e66 <gf_muladd_mem+0x1e6>
    6250:	c5 f9 6f 35 00 00 00 	vmovdqa 0x0(%rip),%xmm6        # 6258 <gf_muladd_mem+0x5d8>
    6257:	00 
			6254: R_X86_64_PC32	.LC3-0x4
    6258:	c5 f8 29 75 b0       	vmovaps %xmm6,-0x50(%rbp)
    625d:	e9 51 fd ff ff       	jmpq   5fb3 <gf_muladd_mem+0x333>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1307
    table = GFContext.GF_MUL_TABLE + ((unsigned)y << 8);
    6262:	48 c1 e3 08          	shl    $0x8,%rbx
    6266:	81 e3 00 ff 00 00    	and    $0xff00,%ebx
    626c:	48 81 c3 00 00 00 00 	add    $0x0,%rbx
			626f: R_X86_64_32S	GFContext+0x6000
    6273:	e9 75 fa ff ff       	jmpq   5ced <gf_muladd_mem+0x6d>
    6278:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1342
        case 1: z1[offset] ^= table[x1[offset]];
    627a:	41 0f b6 14 06       	movzbl (%r14,%rax,1),%edx
    627f:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    6283:	41 30 14 07          	xor    %dl,(%r15,%rax,1)
    6287:	e9 7d fb ff ff       	jmpq   5e09 <gf_muladd_mem+0x189>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1340
        case 3: z1[offset + 2] ^= table[x1[offset + 2]];
    628c:	48 98                	cltq   
    628e:	41 0f b6 54 06 02    	movzbl 0x2(%r14,%rax,1),%edx
    6294:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    6298:	41 30 54 07 02       	xor    %dl,0x2(%r15,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1341
        case 2: z1[offset + 1] ^= table[x1[offset + 1]];
    629d:	41 0f b6 54 06 01    	movzbl 0x1(%r14,%rax,1),%edx
    62a3:	0f b6 14 13          	movzbl (%rbx,%rdx,1),%edx
    62a7:	41 30 54 07 01       	xor    %dl,0x1(%r15,%rax,1)
    62ac:	eb cc                	jmp    627a <gf_muladd_mem+0x5fa>
    62ae:	48 98                	cltq   
    62b0:	eb eb                	jmp    629d <gf_muladd_mem+0x61d>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1220
            x0 = *(x32);
    62b2:	c4 c1 7d 6f 06       	vmovdqa (%r14),%ymm0
    62b7:	89 8d 70 ff ff ff    	mov    %ecx,-0x90(%rbp)
    62bd:	c5 fd 7f 45 b0       	vmovdqa %ymm0,-0x50(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1222
            kernel_fpu_begin();
    62c2:	c5 f8 77             	vzeroupper 
    62c5:	e8 00 00 00 00       	callq  62ca <gf_muladd_mem+0x64a>
			62c6: R_X86_64_PC32	kernel_fpu_begin-0x4
vector_srli_epi64_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:535
    return (M256) __builtin_ia32_psrlqi256 ((__v4di)x, y);
    62ca:	c5 fd 6f 45 b0       	vmovdqa -0x50(%rbp),%ymm0
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531
    return (M256) ((__v4du)x & (__v4du)y);
    62cf:	c5 fd 6f 15 00 00 00 	vmovdqa 0x0(%rip),%ymm2        # 62d7 <gf_muladd_mem+0x657>
    62d6:	00 
			62d3: R_X86_64_PC32	.LC2-0x4
vector_srli_epi64_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:535
    return (M256) __builtin_ia32_psrlqi256 ((__v4di)x, y);
    62d7:	c5 f5 73 d0 04       	vpsrlq $0x4,%ymm0,%ymm1
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    62dc:	c5 fd 6f a5 d0 fe ff 	vmovdqa -0x130(%rbp),%ymm4
    62e3:	ff 
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531
    return (M256) ((__v4du)x & (__v4du)y);
    62e4:	c5 fd db c2          	vpand  %ymm2,%ymm0,%ymm0
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    62e8:	c5 fd 6f ad b0 fe ff 	vmovdqa -0x150(%rbp),%ymm5
    62ef:	ff 
    62f0:	c4 e2 5d 00 f0       	vpshufb %ymm0,%ymm4,%ymm6
vector_and_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:531
    return (M256) ((__v4du)x & (__v4du)y);
    62f5:	c5 f5 db c2          	vpand  %ymm2,%ymm1,%ymm0
vector_shuffle_epi8_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:539
    return (M256)__builtin_ia32_pshufb256((__v32qi)x, (__v32qi)y);
    62f9:	c5 fd 7f 75 b0       	vmovdqa %ymm6,-0x50(%rbp)
    62fe:	c4 e2 55 00 c8       	vpshufb %ymm0,%ymm5,%ymm1
    6303:	c5 fd 7f 4d 90       	vmovdqa %ymm1,-0x70(%rbp)
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1227
            kernel_fpu_end();
    6308:	c5 f8 77             	vzeroupper 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1233
            z32++;
    630b:	49 83 c7 20          	add    $0x20,%r15
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1227
            kernel_fpu_end();
    630f:	e8 00 00 00 00       	callq  6314 <gf_muladd_mem+0x694>
			6310: R_X86_64_PC32	kernel_fpu_end-0x4
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    6314:	c5 fd 6f 7d 90       	vmovdqa -0x70(%rbp),%ymm7
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1234
            x32++;
    6319:	49 83 c6 20          	add    $0x20,%r14
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1232
            bytes -= 32;
    631d:	8b 8d 70 ff ff ff    	mov    -0x90(%rbp),%ecx
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    6323:	c5 c5 ef 45 b0       	vpxor  -0x50(%rbp),%ymm7,%ymm0
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1232
            bytes -= 32;
    6328:	83 e9 20             	sub    $0x20,%ecx
vector_xor_256():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:527
    return (M256) ((__v4du)x ^ (__v4du)y);
    632b:	c4 c1 7d ef 47 e0    	vpxor  -0x20(%r15),%ymm0,%ymm0
gf_muladd_mem():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1230
            *(z32) = vector_xor_256(p0, z0);
    6331:	c4 c1 7d 7f 47 e0    	vmovdqa %ymm0,-0x20(%r15)
    6337:	c5 f8 77             	vzeroupper 
    633a:	e9 8b f9 ff ff       	jmpq   5cca <gf_muladd_mem+0x4a>
    633f:	90                   	nop

0000000000006340 <gf_memswap>:
gf_memswap():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1348

void gf_memswap(void * __restrict vx, void * __restrict vy, int bytes) {
    6340:	e8 00 00 00 00       	callq  6345 <gf_memswap+0x5>
			6341: R_X86_64_PC32	__fentry__-0x4
    6345:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1371
#else
    M128 * __restrict x16 = (M128 *)(vx);
    M128 * __restrict y16 = (M128 *)(vy);

    // Handle blocks of 16 bytes
    while (bytes >= 16) {
    6346:	83 fa 0f             	cmp    $0xf,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1348
void gf_memswap(void * __restrict vx, void * __restrict vy, int bytes) {
    6349:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1371
    while (bytes >= 16) {
    634c:	7e 46                	jle    6394 <gf_memswap+0x54>
    634e:	83 ea 10             	sub    $0x10,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1367
    M128 * __restrict x16 = (M128 *)(vx);
    6351:	48 89 f8             	mov    %rdi,%rax
    6354:	41 89 d1             	mov    %edx,%r9d
    6357:	41 c1 e9 04          	shr    $0x4,%r9d
    635b:	45 89 c8             	mov    %r9d,%r8d
    635e:	49 83 c0 01          	add    $0x1,%r8
    6362:	49 c1 e0 04          	shl    $0x4,%r8
    6366:	4a 8d 0c 06          	lea    (%rsi,%r8,1),%rcx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1373
        M128 x0, y0;
        x0 = *(x16);
    636a:	c5 f9 6f 00          	vmovdqa (%rax),%xmm0
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1378
        y0 = *(y16);
	*x16 = y0;
	*y16 = x0;

        bytes -= 16, ++x16, ++y16;
    636e:	48 83 c6 10          	add    $0x10,%rsi
    6372:	48 83 c0 10          	add    $0x10,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1375
	*x16 = y0;
    6376:	c5 f9 6f 4e f0       	vmovdqa -0x10(%rsi),%xmm1
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1376
	*y16 = x0;
    637b:	c5 f8 29 46 f0       	vmovaps %xmm0,-0x10(%rsi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1375
	*x16 = y0;
    6380:	c5 f8 29 48 f0       	vmovaps %xmm1,-0x10(%rax)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1371
    while (bytes >= 16) {
    6385:	48 39 ce             	cmp    %rcx,%rsi
    6388:	75 e0                	jne    636a <gf_memswap+0x2a>
    638a:	41 c1 e1 04          	shl    $0x4,%r9d
    638e:	4c 01 c7             	add    %r8,%rdi
    6391:	44 29 ca             	sub    %r9d,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1388
    y1 = (uint8_t *)(y16);


    // Handle a block of 8 bytes
    eight = bytes & 8;
    if (eight) {
    6394:	89 d0                	mov    %edx,%eax
    6396:	83 e0 08             	and    $0x8,%eax
    6399:	74 0c                	je     63a7 <gf_memswap+0x67>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1392
        uint64_t * __restrict x8 = (uint64_t *)(x1);
        uint64_t * __restrict y8 = (uint64_t *)(y1);

        uint64_t temp = *x8;
    639b:	48 8b 0f             	mov    (%rdi),%rcx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1393
        *x8 = *y8;
    639e:	4c 8b 06             	mov    (%rsi),%r8
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1394
        *y8 = temp;
    63a1:	48 89 0e             	mov    %rcx,(%rsi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1393
        *x8 = *y8;
    63a4:	4c 89 07             	mov    %r8,(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1399
    }

    // Handle a block of 4 bytes
    four = bytes & 4;
    if (four) {
    63a7:	f6 c2 04             	test   $0x4,%dl
    63aa:	74 15                	je     63c1 <gf_memswap+0x81>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1400
        uint32_t * __restrict x4 = (uint32_t *)(x1 + eight);
    63ac:	48 98                	cltq   
    63ae:	48 8d 0c 07          	lea    (%rdi,%rax,1),%rcx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1401
        uint32_t * __restrict y4 = (uint32_t *)(y1 + eight);
    63b2:	48 01 f0             	add    %rsi,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1404

        uint32_t temp = *x4;
        *x4 = *y4;
    63b5:	44 8b 08             	mov    (%rax),%r9d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1403
        uint32_t temp = *x4;
    63b8:	44 8b 01             	mov    (%rcx),%r8d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1404
        *x4 = *y4;
    63bb:	44 89 09             	mov    %r9d,(%rcx)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1405
        *y4 = temp;
    63be:	44 89 00             	mov    %r8d,(%rax)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1409
    }

    // Handle final bytes
    offset = eight + four;
    63c1:	89 d0                	mov    %edx,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1410
    switch (bytes & 3) {
    63c3:	83 e2 03             	and    $0x3,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1409
    offset = eight + four;
    63c6:	83 e0 0c             	and    $0xc,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1410
    switch (bytes & 3) {
    63c9:	83 fa 02             	cmp    $0x2,%edx
    63cc:	74 56                	je     6424 <gf_memswap+0xe4>
    63ce:	83 fa 03             	cmp    $0x3,%edx
    63d1:	74 1b                	je     63ee <gf_memswap+0xae>
    63d3:	83 fa 01             	cmp    $0x1,%edx
    63d6:	74 02                	je     63da <gf_memswap+0x9a>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1417
        case 2: temp2 = x1[offset + 1]; x1[offset + 1] = y1[offset + 1]; y1[offset + 1] = temp2;
        case 1: temp2 = x1[offset]; x1[offset] = y1[offset]; y1[offset] = temp2;
        default:
            break;
    }
}
    63d8:	5d                   	pop    %rbp
    63d9:	c3                   	retq   
    63da:	48 98                	cltq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1413
        case 1: temp2 = x1[offset]; x1[offset] = y1[offset]; y1[offset] = temp2;
    63dc:	48 01 c7             	add    %rax,%rdi
    63df:	48 01 c6             	add    %rax,%rsi
    63e2:	0f b6 17             	movzbl (%rdi),%edx
    63e5:	0f b6 06             	movzbl (%rsi),%eax
    63e8:	88 16                	mov    %dl,(%rsi)
    63ea:	88 07                	mov    %al,(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1417
}
    63ec:	5d                   	pop    %rbp
    63ed:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1411
        case 3: temp2 = x1[offset + 2]; x1[offset + 2] = y1[offset + 2]; y1[offset + 2] = temp2;
    63ee:	48 98                	cltq   
    63f0:	48 8d 50 02          	lea    0x2(%rax),%rdx
    63f4:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
    63f8:	48 01 f2             	add    %rsi,%rdx
    63fb:	44 0f b6 0a          	movzbl (%rdx),%r9d
    63ff:	44 0f b6 01          	movzbl (%rcx),%r8d
    6403:	44 88 09             	mov    %r9b,(%rcx)
    6406:	44 88 02             	mov    %r8b,(%rdx)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1412
        case 2: temp2 = x1[offset + 1]; x1[offset + 1] = y1[offset + 1]; y1[offset + 1] = temp2;
    6409:	48 8d 50 01          	lea    0x1(%rax),%rdx
    640d:	48 8d 0c 17          	lea    (%rdi,%rdx,1),%rcx
    6411:	48 01 f2             	add    %rsi,%rdx
    6414:	44 0f b6 0a          	movzbl (%rdx),%r9d
    6418:	44 0f b6 01          	movzbl (%rcx),%r8d
    641c:	44 88 09             	mov    %r9b,(%rcx)
    641f:	44 88 02             	mov    %r8b,(%rdx)
    6422:	eb b8                	jmp    63dc <gf_memswap+0x9c>
    6424:	48 98                	cltq   
    6426:	eb e1                	jmp    6409 <gf_memswap+0xc9>
    6428:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    642f:	00 

0000000000006430 <cauchy_init>:
cauchy_init():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1465


//-----------------------------------------------------------------------------
// Initialization

int cauchy_init(void){
    6430:	e8 00 00 00 00       	callq  6435 <cauchy_init+0x5>
			6431: R_X86_64_PC32	__fentry__-0x4
    6435:	55                   	push   %rbp
    6436:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1467
    // Return error code from GF(256) init if required
    return gf_init();
    6439:	e8 00 00 00 00       	callq  643e <cauchy_init+0xe>
			643a: R_X86_64_PC32	gf_init-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1468
}
    643e:	5d                   	pop    %rbp
    643f:	c3                   	retq   

0000000000006440 <cauchy_rs_encode_block>:
cauchy_rs_encode_block():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1519
void cauchy_rs_encode_block(
    cauchy_encoder_params params, // Encoder parameters
    cauchy_block* originals,      // Array of pointers to original blocks
    int recoveryBlockIndex,      // Return value from cauchy_get_recovery_block_index()
    void* recoveryBlock)         // Output recovery block
{   
    6440:	e8 00 00 00 00       	callq  6445 <cauchy_rs_encode_block+0x5>
			6441: R_X86_64_PC32	__fentry__-0x4
    6445:	55                   	push   %rbp
    6446:	48 89 e5             	mov    %rsp,%rbp
    6449:	41 57                	push   %r15
    644b:	41 56                	push   %r14
    644d:	41 55                	push   %r13
    644f:	41 54                	push   %r12
    6451:	41 89 f4             	mov    %esi,%r12d
    6454:	53                   	push   %rbx
    6455:	4d 89 c5             	mov    %r8,%r13
    6458:	48 83 ec 28          	sub    $0x28,%rsp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1523
    uint8_t x_0, x_i, y_0, y_j, matrixElement;
    int j;
    // If only one block of input data,
    if (params.OriginalCount == 1){
    645c:	83 ff 01             	cmp    $0x1,%edi
    645f:	48 8b 32             	mov    (%rdx),%rsi
    6462:	0f 84 de 00 00 00    	je     6546 <cauchy_rs_encode_block+0x106>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1534
    // else OriginalCount >= 2:

    // Unroll first row of recovery matrix:
    // The matrix we generate for the first row is all ones,
    // so it is merely a parity of the original data.
    if (recoveryBlockIndex == params.OriginalCount){
    6468:	39 cf                	cmp    %ecx,%edi
    646a:	49 89 d7             	mov    %rdx,%r15
    646d:	89 fb                	mov    %edi,%ebx
    646f:	0f 84 87 00 00 00    	je     64fc <cauchy_rs_encode_block+0xbc>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1549
    // Start the x_0 values arbitrarily from the original count.
    x_0 = (uint8_t)(params.OriginalCount);

    // For other rows:
    {
        x_i = (uint8_t)(recoveryBlockIndex);
    6475:	88 4d be             	mov    %cl,-0x42(%rbp)
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6478:	c1 e1 08             	shl    $0x8,%ecx
cauchy_rs_encode_block():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1545
    x_0 = (uint8_t)(params.OriginalCount);
    647b:	40 88 7d bf          	mov    %dil,-0x41(%rbp)
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
    647f:	0f b7 c1             	movzwl %cx,%eax
    6482:	40 0f b6 cf          	movzbl %dil,%ecx
cauchy_rs_encode_block():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1556
        // Unroll first operation for speed
        {
            y_0 = 0;
            matrixElement = GetMatrixElement(x_i, x_0, y_0);

            gf_mul_mem(recoveryBlock, originals[0].Block, matrixElement, params.BlockBytes);
    6486:	4c 89 c7             	mov    %r8,%rdi
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
    6489:	01 c8                	add    %ecx,%eax
cauchy_rs_encode_block():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1556
    648b:	44 89 e1             	mov    %r12d,%ecx
    648e:	0f b6 90 00 00 00 00 	movzbl 0x0(%rax),%edx
			6491: R_X86_64_32S	GFContext+0x16000
    6495:	e8 00 00 00 00       	callq  649a <cauchy_rs_encode_block+0x5a>
			6496: R_X86_64_PC32	gf_mul_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1560
        }

        // For each original data column,
        for (j = 1; j < params.OriginalCount; ++j){
    649a:	83 fb 01             	cmp    $0x1,%ebx
    649d:	7e 4e                	jle    64ed <cauchy_rs_encode_block+0xad>
    649f:	49 83 c7 10          	add    $0x10,%r15
    64a3:	41 be 01 00 00 00    	mov    $0x1,%r14d
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    return (uint8_t)(x ^ y);
    64a9:	0f b6 45 be          	movzbl -0x42(%rbp),%eax
    64ad:	0f b6 55 bf          	movzbl -0x41(%rbp),%edx
cauchy_rs_encode_block():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1564 (discriminator 3)
            y_j = (uint8_t)(j);
            matrixElement = GetMatrixElement(x_i, x_0, y_j);

            gf_muladd_mem(recoveryBlock, matrixElement, originals[j].Block, params.BlockBytes);
    64b1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			64b4: R_X86_64_32S	GFContext
    64b8:	44 89 e1             	mov    %r12d,%ecx
    64bb:	49 83 c7 10          	add    $0x10,%r15
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    64bf:	44 31 f0             	xor    %r14d,%eax
    64c2:	44 31 f2             	xor    %r14d,%edx
cauchy_rs_encode_block():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1560 (discriminator 3)
        for (j = 1; j < params.OriginalCount; ++j){
    64c5:	41 83 c6 01          	add    $0x1,%r14d
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172 (discriminator 3)
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    64c9:	0f b6 c0             	movzbl %al,%eax
    64cc:	0f b6 d2             	movzbl %dl,%edx
    64cf:	c1 e0 08             	shl    $0x8,%eax
    64d2:	01 d0                	add    %edx,%eax
cauchy_rs_encode_block():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1564 (discriminator 3)
            gf_muladd_mem(recoveryBlock, matrixElement, originals[j].Block, params.BlockBytes);
    64d4:	49 8b 57 f0          	mov    -0x10(%r15),%rdx
    64d8:	0f b6 b4 07 00 60 01 	movzbl 0x16000(%rdi,%rax,1),%esi
    64df:	00 
    64e0:	4c 89 ef             	mov    %r13,%rdi
    64e3:	e8 00 00 00 00       	callq  64e8 <cauchy_rs_encode_block+0xa8>
			64e4: R_X86_64_PC32	gf_muladd_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1560 (discriminator 3)
        for (j = 1; j < params.OriginalCount; ++j){
    64e8:	44 39 f3             	cmp    %r14d,%ebx
    64eb:	75 bc                	jne    64a9 <cauchy_rs_encode_block+0x69>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1567
        }
    }
}
    64ed:	48 83 c4 28          	add    $0x28,%rsp
    64f1:	5b                   	pop    %rbx
    64f2:	41 5c                	pop    %r12
    64f4:	41 5d                	pop    %r13
    64f6:	41 5e                	pop    %r14
    64f8:	41 5f                	pop    %r15
    64fa:	5d                   	pop    %rbp
    64fb:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1535
        gf_addset_mem(recoveryBlock, originals[0].Block, originals[1].Block, params.BlockBytes);
    64fc:	48 8b 52 10          	mov    0x10(%rdx),%rdx
    6500:	44 89 e1             	mov    %r12d,%ecx
    6503:	4c 89 c7             	mov    %r8,%rdi
    6506:	e8 00 00 00 00       	callq  650b <cauchy_rs_encode_block+0xcb>
			6507: R_X86_64_PC32	gf_addset_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1536
        for (j = 2; j < params.OriginalCount; ++j){
    650b:	83 fb 02             	cmp    $0x2,%ebx
    650e:	7e dd                	jle    64ed <cauchy_rs_encode_block+0xad>
    6510:	8d 43 fd             	lea    -0x3(%rbx),%eax
    6513:	4d 8d 77 20          	lea    0x20(%r15),%r14
    6517:	48 c1 e0 04          	shl    $0x4,%rax
    651b:	49 8d 5c 07 30       	lea    0x30(%r15,%rax,1),%rbx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1537 (discriminator 3)
            gf_add_mem(recoveryBlock, originals[j].Block, params.BlockBytes);
    6520:	49 8b 36             	mov    (%r14),%rsi
    6523:	44 89 e2             	mov    %r12d,%edx
    6526:	4c 89 ef             	mov    %r13,%rdi
    6529:	49 83 c6 10          	add    $0x10,%r14
    652d:	e8 00 00 00 00       	callq  6532 <cauchy_rs_encode_block+0xf2>
			652e: R_X86_64_PC32	gf_add_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1536 (discriminator 3)
        for (j = 2; j < params.OriginalCount; ++j){
    6532:	4c 39 f3             	cmp    %r14,%rbx
    6535:	75 e9                	jne    6520 <cauchy_rs_encode_block+0xe0>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1567
}
    6537:	48 83 c4 28          	add    $0x28,%rsp
    653b:	5b                   	pop    %rbx
    653c:	41 5c                	pop    %r12
    653e:	41 5d                	pop    %r13
    6540:	41 5e                	pop    %r14
    6542:	41 5f                	pop    %r15
    6544:	5d                   	pop    %rbp
    6545:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1526
        memcpy(recoveryBlock, originals[0].Block, params.BlockBytes);
    6546:	49 63 d4             	movslq %r12d,%rdx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    6549:	4c 89 c7             	mov    %r8,%rdi
    654c:	e8 00 00 00 00       	callq  6551 <cauchy_rs_encode_block+0x111>
			654d: R_X86_64_PC32	memcpy-0x4
cauchy_rs_encode_block():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1567
}
    6551:	48 83 c4 28          	add    $0x28,%rsp
    6555:	5b                   	pop    %rbx
    6556:	41 5c                	pop    %r12
    6558:	41 5d                	pop    %r13
    655a:	41 5e                	pop    %r14
    655c:	41 5f                	pop    %r15
    655e:	5d                   	pop    %rbp
    655f:	c3                   	retq   

0000000000006560 <cauchy_rs_encode>:
cauchy_rs_encode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1573

int cauchy_rs_encode(
    cauchy_encoder_params params, // Encoder params
    uint8_t** dataBlocks,
    uint8_t** parityBlocks)        // Output recovery blocks end-to-end
{
    6560:	e8 00 00 00 00       	callq  6565 <cauchy_rs_encode+0x5>
			6561: R_X86_64_PC32	__fentry__-0x4
    6565:	55                   	push   %rbp
    6566:	48 89 e5             	mov    %rsp,%rbp
    6569:	41 57                	push   %r15
    656b:	41 89 ff             	mov    %edi,%r15d
    656e:	41 56                	push   %r14
    6570:	48 c1 ef 20          	shr    $0x20,%rdi
    6574:	41 55                	push   %r13
    6576:	41 54                	push   %r12
    6578:	53                   	push   %rbx
    6579:	49 89 fc             	mov    %rdi,%r12
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1574
    cauchy_block* originals = cauchy_malloc(sizeof(cauchy_block) * params.OriginalCount);
    657c:	49 63 ff             	movslq %r15d,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1573
{
    657f:	48 89 d3             	mov    %rdx,%rbx
    6582:	49 89 ce             	mov    %rcx,%r14
    6585:	48 83 ec 18          	sub    $0x18,%rsp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1574
    cauchy_block* originals = cauchy_malloc(sizeof(cauchy_block) * params.OriginalCount);
    6589:	48 c1 e7 04          	shl    $0x4,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1573
{
    658d:	89 75 c8             	mov    %esi,-0x38(%rbp)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    6590:	be c0 00 40 01       	mov    $0x14000c0,%esi
    6595:	e8 00 00 00 00       	callq  659a <cauchy_rs_encode+0x3a>
			6596: R_X86_64_PC32	__kmalloc-0x4
cauchy_rs_encode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1577
    int block;

    if (params.OriginalCount <= 0 || params.RecoveryCount <= 0 || params.BlockBytes <= 0){
    659a:	45 85 ff             	test   %r15d,%r15d
    659d:	0f 8e 98 00 00 00    	jle    663b <cauchy_rs_encode+0xdb>
    65a3:	45 85 e4             	test   %r12d,%r12d
    65a6:	0f 8e 8f 00 00 00    	jle    663b <cauchy_rs_encode+0xdb>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1577 (discriminator 2)
    65ac:	8b 55 c8             	mov    -0x38(%rbp),%edx
    65af:	85 d2                	test   %edx,%edx
    65b1:	0f 8e 84 00 00 00    	jle    663b <cauchy_rs_encode+0xdb>
    65b7:	49 89 c5             	mov    %rax,%r13
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1580
        return -1;
    }
    if (params.OriginalCount + params.RecoveryCount > 256){
    65ba:	43 8d 04 3c          	lea    (%r12,%r15,1),%eax
    65be:	3d 00 01 00 00       	cmp    $0x100,%eax
    65c3:	0f 8f 80 00 00 00    	jg     6649 <cauchy_rs_encode+0xe9>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1583
        return -2;
    }
    if (!originals || !parityBlocks || !dataBlocks){
    65c9:	4d 85 f6             	test   %r14,%r14
    65cc:	0f 94 c2             	sete   %dl
    65cf:	48 85 db             	test   %rbx,%rbx
    65d2:	0f 94 c0             	sete   %al
    65d5:	08 c2                	or     %al,%dl
    65d7:	75 69                	jne    6642 <cauchy_rs_encode+0xe2>
    65d9:	4d 85 ed             	test   %r13,%r13
    65dc:	74 64                	je     6642 <cauchy_rs_encode+0xe2>
    65de:	4c 89 e9             	mov    %r13,%rcx
    65e1:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1588 (discriminator 3)
        return -3;
    }

    for (block = 0; block < params.OriginalCount; ++block){
        originals[block].Block = dataBlocks[block];
    65e3:	48 8b 34 c3          	mov    (%rbx,%rax,8),%rsi
    65e7:	48 83 c0 01          	add    $0x1,%rax
    65eb:	48 83 c1 10          	add    $0x10,%rcx
    65ef:	48 89 71 f0          	mov    %rsi,-0x10(%rcx)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1587 (discriminator 3)
    for (block = 0; block < params.OriginalCount; ++block){
    65f3:	41 39 c7             	cmp    %eax,%r15d
    65f6:	7f eb                	jg     65e3 <cauchy_rs_encode+0x83>
    65f8:	31 db                	xor    %ebx,%ebx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1593 (discriminator 3)
    }

    for (block = 0; block < params.RecoveryCount; ++block){
        //print_hex_dump(KERN_DEBUG, "data: ", DUMP_PREFIX_OFFSET, 20, 1, (void*)originals[block].Block, 16, true);
        cauchy_rs_encode_block(params, originals, (params.OriginalCount + block), parityBlocks[block]);
    65fa:	44 89 7d c0          	mov    %r15d,-0x40(%rbp)
    65fe:	44 89 65 c4          	mov    %r12d,-0x3c(%rbp)
    6602:	41 8d 0c 1f          	lea    (%r15,%rbx,1),%ecx
    6606:	4d 8b 04 de          	mov    (%r14,%rbx,8),%r8
    660a:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    660e:	4c 89 ea             	mov    %r13,%rdx
    6611:	8b 75 c8             	mov    -0x38(%rbp),%esi
    6614:	48 83 c3 01          	add    $0x1,%rbx
    6618:	e8 00 00 00 00       	callq  661d <cauchy_rs_encode+0xbd>
			6619: R_X86_64_PC32	cauchy_rs_encode_block-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1591 (discriminator 3)
    for (block = 0; block < params.RecoveryCount; ++block){
    661d:	41 39 dc             	cmp    %ebx,%r12d
    6620:	7f d8                	jg     65fa <cauchy_rs_encode+0x9a>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1597
	//print_hex_dump(KERN_DEBUG, "parity: ", DUMP_PREFIX_OFFSET, 20, 1, (void*)parityBlocks[block], 16, true);
    }

    kfree(originals);
    6622:	4c 89 ef             	mov    %r13,%rdi
    6625:	e8 00 00 00 00       	callq  662a <cauchy_rs_encode+0xca>
			6626: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1598
    return 0;
    662a:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1599
}
    662c:	48 83 c4 18          	add    $0x18,%rsp
    6630:	5b                   	pop    %rbx
    6631:	41 5c                	pop    %r12
    6633:	41 5d                	pop    %r13
    6635:	41 5e                	pop    %r14
    6637:	41 5f                	pop    %r15
    6639:	5d                   	pop    %rbp
    663a:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1578
        return -1;
    663b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    6640:	eb ea                	jmp    662c <cauchy_rs_encode+0xcc>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1584
        return -3;
    6642:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    6647:	eb e3                	jmp    662c <cauchy_rs_encode+0xcc>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1581
        return -2;
    6649:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    664e:	eb dc                	jmp    662c <cauchy_rs_encode+0xcc>

0000000000006650 <Initialize>:
Initialize():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1622
    // Row indices that were erased
    uint8_t ErasuresIndices[256];

}CauchyDecoder;

int Initialize(CauchyDecoder *decoder, cauchy_encoder_params params, cauchy_block* blocks) {
    6650:	e8 00 00 00 00       	callq  6655 <Initialize+0x5>
			6651: R_X86_64_PC32	__fentry__-0x4
    6655:	55                   	push   %rbp
    6656:	48 89 e5             	mov    %rsp,%rbp
    6659:	48 83 ec 10          	sub    $0x10,%rsp
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1631

    decoder->OriginalCount = 0;
    decoder->RecoveryCount = 0;

    // Initialize erasures to zeros
    for (ii = 0; ii < params.OriginalCount; ++ii){
    665d:	85 f6                	test   %esi,%esi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1622
int Initialize(CauchyDecoder *decoder, cauchy_encoder_params params, cauchy_block* blocks) {
    665f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    6663:	89 55 f8             	mov    %edx,-0x8(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1625
    decoder->Params = params;
    6666:	48 89 37             	mov    %rsi,(%rdi)
    6669:	89 57 08             	mov    %edx,0x8(%rdi)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1627
    decoder->OriginalCount = 0;
    666c:	c7 87 18 10 00 00 00 	movl   $0x0,0x1018(%rdi)
    6673:	00 00 00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1628
    decoder->RecoveryCount = 0;
    6676:	c7 87 10 08 00 00 00 	movl   $0x0,0x810(%rdi)
    667d:	00 00 00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1631
    for (ii = 0; ii < params.OriginalCount; ++ii){
    6680:	0f 8e 8b 00 00 00    	jle    6711 <Initialize+0xc1>
    6686:	8d 56 ff             	lea    -0x1(%rsi),%edx
    6689:	41 89 f0             	mov    %esi,%r8d
    668c:	48 8d 87 1c 10 00 00 	lea    0x101c(%rdi),%rax
    6693:	48 8d b4 17 1d 10 00 	lea    0x101d(%rdi,%rdx,1),%rsi
    669a:	00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1632 (discriminator 3)
        decoder->ErasuresIndices[ii] = 0;
    669b:	c6 00 00             	movb   $0x0,(%rax)
    669e:	48 83 c0 01          	add    $0x1,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1631 (discriminator 3)
    for (ii = 0; ii < params.OriginalCount; ++ii){
    66a2:	48 39 f0             	cmp    %rsi,%rax
    66a5:	75 f4                	jne    669b <Initialize+0x4b>
    66a7:	48 83 c2 01          	add    $0x1,%rdx
    66ab:	48 c1 e2 04          	shl    $0x4,%rdx
    66af:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
    66b3:	eb 35                	jmp    66ea <Initialize+0x9a>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1641
    for (ii = 0; ii < params.OriginalCount; ++ii, ++block){
        row = block->Index;

        // If it is an original block,
        if (row < params.OriginalCount){
            decoder->Original[decoder->OriginalCount++] = block;
    66b5:	48 63 97 18 10 00 00 	movslq 0x1018(%rdi),%rdx
    66bc:	44 8d 4a 01          	lea    0x1(%rdx),%r9d
    66c0:	44 89 8f 18 10 00 00 	mov    %r9d,0x1018(%rdi)
    66c7:	48 89 8c d7 18 08 00 	mov    %rcx,0x818(%rdi,%rdx,8)
    66ce:	00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1642
            if (decoder->ErasuresIndices[row] != 0){
    66cf:	80 bc 07 1c 10 00 00 	cmpb   $0x0,0x101c(%rdi,%rax,1)
    66d6:	00 
    66d7:	75 6d                	jne    6746 <Initialize+0xf6>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1636
    for (ii = 0; ii < params.OriginalCount; ++ii, ++block){
    66d9:	48 83 c1 10          	add    $0x10,%rcx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1647
                // Error out if two row indices repeat
                printk(KERN_INFO "Indices incorrect\n");
                return -1;
            }
            decoder->ErasuresIndices[row] = 1;
    66dd:	c6 84 07 1c 10 00 00 	movb   $0x1,0x101c(%rdi,%rax,1)
    66e4:	01 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1636
    for (ii = 0; ii < params.OriginalCount; ++ii, ++block){
    66e5:	48 39 f1             	cmp    %rsi,%rcx
    66e8:	74 27                	je     6711 <Initialize+0xc1>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1637
        row = block->Index;
    66ea:	0f b6 41 08          	movzbl 0x8(%rcx),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1640
        if (row < params.OriginalCount){
    66ee:	41 39 c0             	cmp    %eax,%r8d
    66f1:	7f c2                	jg     66b5 <Initialize+0x65>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1650
        }
        else{
            decoder->Recovery[decoder->RecoveryCount++] = block;
    66f3:	48 63 87 10 08 00 00 	movslq 0x810(%rdi),%rax
    66fa:	8d 50 01             	lea    0x1(%rax),%edx
    66fd:	89 97 10 08 00 00    	mov    %edx,0x810(%rdi)
    6703:	48 89 4c c7 10       	mov    %rcx,0x10(%rdi,%rax,8)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1636
    for (ii = 0; ii < params.OriginalCount; ++ii, ++block){
    6708:	48 83 c1 10          	add    $0x10,%rcx
    670c:	48 39 f1             	cmp    %rsi,%rcx
    670f:	75 d9                	jne    66ea <Initialize+0x9a>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1622
int Initialize(CauchyDecoder *decoder, cauchy_encoder_params params, cauchy_block* blocks) {
    6711:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1655
        }
    }

    // Identify erasures
    for (ii = 0, indexCount = 0; ii < 256; ++ii) {
    6713:	31 d2                	xor    %edx,%edx
    6715:	eb 0c                	jmp    6723 <Initialize+0xd3>
    6717:	48 83 c0 01          	add    $0x1,%rax
    671b:	48 3d 00 01 00 00    	cmp    $0x100,%rax
    6721:	74 1f                	je     6742 <Initialize+0xf2>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1656
        if (!decoder->ErasuresIndices[ii]) {
    6723:	80 bc 07 1c 10 00 00 	cmpb   $0x0,0x101c(%rdi,%rax,1)
    672a:	00 
    672b:	75 ea                	jne    6717 <Initialize+0xc7>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1657
            decoder->ErasuresIndices[indexCount] = (uint8_t)( ii );
    672d:	48 63 ca             	movslq %edx,%rcx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1659

            if (++indexCount >= decoder->RecoveryCount) {
    6730:	83 c2 01             	add    $0x1,%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1657
            decoder->ErasuresIndices[indexCount] = (uint8_t)( ii );
    6733:	88 84 0f 1c 10 00 00 	mov    %al,0x101c(%rdi,%rcx,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1659
            if (++indexCount >= decoder->RecoveryCount) {
    673a:	3b 97 10 08 00 00    	cmp    0x810(%rdi),%edx
    6740:	7c d5                	jl     6717 <Initialize+0xc7>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1645
                return -1;
    6742:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1665
                break;
            }
        }
    }
    return 0;
}
    6744:	c9                   	leaveq 
    6745:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1644
                printk(KERN_INFO "Indices incorrect\n");
    6746:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			6749: R_X86_64_32S	.rodata.str1.1+0xd3
    674d:	31 c0                	xor    %eax,%eax
    674f:	e8 00 00 00 00       	callq  6754 <Initialize+0x104>
			6750: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1645
                return -1;
    6754:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1665
}
    6759:	c9                   	leaveq 
    675a:	c3                   	retq   
    675b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000006760 <DecodeM1>:
DecodeM1():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1667

void DecodeM1(CauchyDecoder *decoder){
    6760:	e8 00 00 00 00       	callq  6765 <DecodeM1+0x5>
			6761: R_X86_64_PC32	__fentry__-0x4
    6765:	55                   	push   %rbp
    6766:	48 89 e5             	mov    %rsp,%rbp
    6769:	41 56                	push   %r14
    676b:	41 55                	push   %r13
    676d:	41 54                	push   %r12
    676f:	53                   	push   %rbx
    6770:	49 89 fc             	mov    %rdi,%r12
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1675
    uint8_t* inBlock = NULL;
    int ii;
    uint8_t* inBlock2;

    // For each block,
    for (ii = 0; ii < decoder->OriginalCount; ++ii) {
    6773:	8b 87 18 10 00 00    	mov    0x1018(%rdi),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1669
    uint8_t* outBlock = (uint8_t*)(decoder->Recovery[0]->Block);
    6779:	48 8b 57 10          	mov    0x10(%rdi),%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1675
    for (ii = 0; ii < decoder->OriginalCount; ++ii) {
    677d:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1669
    uint8_t* outBlock = (uint8_t*)(decoder->Recovery[0]->Block);
    677f:	4c 8b 2a             	mov    (%rdx),%r13
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1675
    for (ii = 0; ii < decoder->OriginalCount; ++ii) {
    6782:	7e 56                	jle    67da <DecodeM1+0x7a>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1676
        inBlock2 = (uint8_t*)(decoder->Original[ii]->Block);
    6784:	48 8b 97 18 08 00 00 	mov    0x818(%rdi),%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1675
    for (ii = 0; ii < decoder->OriginalCount; ++ii) {
    678b:	31 db                	xor    %ebx,%ebx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1676
        inBlock2 = (uint8_t*)(decoder->Original[ii]->Block);
    678d:	48 8b 32             	mov    (%rdx),%rsi
    6790:	eb 0a                	jmp    679c <DecodeM1+0x3c>
    6792:	49 8b 96 28 08 00 00 	mov    0x828(%r14),%rdx
    6799:	48 8b 32             	mov    (%rdx),%rsi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1675 (discriminator 2)
    for (ii = 0; ii < decoder->OriginalCount; ++ii) {
    679c:	8d 4b 01             	lea    0x1(%rbx),%ecx
    679f:	39 c1                	cmp    %eax,%ecx
    67a1:	7d 4c                	jge    67ef <DecodeM1+0x8f>
    67a3:	48 63 d3             	movslq %ebx,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1678

        if (!inBlock) {
    67a6:	48 85 f6             	test   %rsi,%rsi
    67a9:	4d 8d 34 d4          	lea    (%r12,%rdx,8),%r14
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1676
        inBlock2 = (uint8_t*)(decoder->Original[ii]->Block);
    67ad:	49 8b 96 20 08 00 00 	mov    0x820(%r14),%rdx
    67b4:	48 8b 12             	mov    (%rdx),%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1678
        if (!inBlock) {
    67b7:	74 4a                	je     6803 <DecodeM1+0xa3>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1682
            inBlock = inBlock2;
        }else {
            // outBlock ^= inBlock ^ inBlock2
            gf_add2_mem(outBlock, inBlock, inBlock2, decoder->Params.BlockBytes);
    67b9:	41 8b 4c 24 08       	mov    0x8(%r12),%ecx
    67be:	4c 89 ef             	mov    %r13,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1675
    for (ii = 0; ii < decoder->OriginalCount; ++ii) {
    67c1:	83 c3 02             	add    $0x2,%ebx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1682
            gf_add2_mem(outBlock, inBlock, inBlock2, decoder->Params.BlockBytes);
    67c4:	e8 00 00 00 00       	callq  67c9 <DecodeM1+0x69>
			67c5: R_X86_64_PC32	gf_add2_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1675
    for (ii = 0; ii < decoder->OriginalCount; ++ii) {
    67c9:	41 8b 84 24 18 10 00 	mov    0x1018(%r12),%eax
    67d0:	00 
    67d1:	39 c3                	cmp    %eax,%ebx
    67d3:	7c bd                	jl     6792 <DecodeM1+0x32>
    67d5:	49 8b 54 24 10       	mov    0x10(%r12),%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1693
    if (inBlock) {
        gf_add_mem(outBlock, inBlock, decoder->Params.BlockBytes);
    }

    // Recover the index it corresponds to
    decoder->Recovery[0]->Index = decoder->ErasuresIndices[0];
    67da:	41 0f b6 84 24 1c 10 	movzbl 0x101c(%r12),%eax
    67e1:	00 00 
    67e3:	88 42 08             	mov    %al,0x8(%rdx)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1694
}
    67e6:	5b                   	pop    %rbx
    67e7:	41 5c                	pop    %r12
    67e9:	41 5d                	pop    %r13
    67eb:	41 5e                	pop    %r14
    67ed:	5d                   	pop    %rbp
    67ee:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1688
    if (inBlock) {
    67ef:	48 85 f6             	test   %rsi,%rsi
    67f2:	74 e1                	je     67d5 <DecodeM1+0x75>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1689
        gf_add_mem(outBlock, inBlock, decoder->Params.BlockBytes);
    67f4:	41 8b 54 24 08       	mov    0x8(%r12),%edx
    67f9:	4c 89 ef             	mov    %r13,%rdi
    67fc:	e8 00 00 00 00       	callq  6801 <DecodeM1+0xa1>
			67fd: R_X86_64_PC32	gf_add_mem-0x4
    6801:	eb d2                	jmp    67d5 <DecodeM1+0x75>
    6803:	89 cb                	mov    %ecx,%ebx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1676
        inBlock2 = (uint8_t*)(decoder->Original[ii]->Block);
    6805:	48 89 d6             	mov    %rdx,%rsi
    6808:	eb 92                	jmp    679c <DecodeM1+0x3c>
    680a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000006810 <GenerateLDUDecomposition>:
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1697

// Generate the LU decomposition of the matrix
void GenerateLDUDecomposition(CauchyDecoder *decoder, uint8_t* matrix_L, uint8_t* diag_D, uint8_t* matrix_U) {
    6810:	e8 00 00 00 00       	callq  6815 <GenerateLDUDecomposition+0x5>
			6811: R_X86_64_PC32	__fentry__-0x4
    6815:	55                   	push   %rbp
    6816:	48 89 e5             	mov    %rsp,%rbp
    6819:	41 57                	push   %r15
    681b:	41 56                	push   %r14
    681d:	41 55                	push   %r13
    681f:	41 54                	push   %r12
    6821:	49 89 ff             	mov    %rdi,%r15
    6824:	53                   	push   %rbx
    6825:	48 81 ec a8 03 00 00 	sub    $0x3a8,%rsp
    682c:	48 89 b5 90 fc ff ff 	mov    %rsi,-0x370(%rbp)
    6833:	48 89 95 50 fc ff ff 	mov    %rdx,-0x3b0(%rbp)
    683a:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    6841:	00 00 
    6843:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    6847:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1706
    // Modified for practical use.  I folded the diagonal parts of U/L matrices into the
    // diagonal one to reduce the number of multiplications to perform against the input data,
    // and organized the triangle matrices in memory to allow for faster SSE3 GF multiplications.

    // Matrix size NxN
    int N = decoder->RecoveryCount;
    6849:	8b 87 10 08 00 00    	mov    0x810(%rdi),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1697
void GenerateLDUDecomposition(CauchyDecoder *decoder, uint8_t* matrix_L, uint8_t* diag_D, uint8_t* matrix_U) {
    684f:	48 89 8d 48 fc ff ff 	mov    %rcx,-0x3b8(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1715
    uint8_t *last_U, *row_L, *row_U, *output_U;
    uint8_t x_0, x_k, y_k, D_kk, L_kk, U_kk, x_j, y_j, L_jk, U_kj, x_n, y_n, L_nn, U_nn;

    // Generators
    uint8_t g[256], b[256];
    for (i = 0; i < N; ++i) {
    6856:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1706
    int N = decoder->RecoveryCount;
    6858:	89 85 8c fc ff ff    	mov    %eax,-0x374(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1715
    for (i = 0; i < N; ++i) {
    685e:	0f 8e a6 04 00 00    	jle    6d0a <GenerateLDUDecomposition+0x4fa>
    6864:	8b 85 8c fc ff ff    	mov    -0x374(%rbp),%eax
    686a:	48 8d b5 c0 fd ff ff 	lea    -0x240(%rbp),%rsi
    6871:	48 8d 8d c0 fe ff ff 	lea    -0x140(%rbp),%rcx
    6878:	8d 50 ff             	lea    -0x1(%rax),%edx
    687b:	31 c0                	xor    %eax,%eax
    687d:	89 95 88 fc ff ff    	mov    %edx,-0x378(%rbp)
    6883:	48 83 c2 01          	add    $0x1,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1716 (discriminator 3)
        g[i] = 1;
    6887:	c6 04 06 01          	movb   $0x1,(%rsi,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1717 (discriminator 3)
        b[i] = 1;
    688b:	c6 04 01 01          	movb   $0x1,(%rcx,%rax,1)
    688f:	48 83 c0 01          	add    $0x1,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1715 (discriminator 3)
    for (i = 0; i < N; ++i) {
    6893:	48 39 c2             	cmp    %rax,%rdx
    6896:	75 ef                	jne    6887 <GenerateLDUDecomposition+0x77>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1722
    }

    // Temporary buffer for rotated row of U matrix
    // This allows for faster GF bulk multiplication
    last_U = matrix_U + ((N - 1) * N) / 2 - 1;
    6898:	48 63 9d 88 fc ff ff 	movslq -0x378(%rbp),%rbx
    689f:	8b 95 8c fc ff ff    	mov    -0x374(%rbp),%edx
    68a5:	0f af d3             	imul   %ebx,%edx
    68a8:	89 d0                	mov    %edx,%eax
    68aa:	c1 e8 1f             	shr    $0x1f,%eax
    68ad:	01 d0                	add    %edx,%eax
    68af:	d1 f8                	sar    %eax
    68b1:	48 98                	cltq   
    68b3:	48 83 e8 01          	sub    $0x1,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1729

    // Start the x_0 values arbitrarily from the original count.
    x_0 = (uint8_t)(decoder->Params.OriginalCount);

    // Unrolling k = 0 just makes it slower for some reason.
    for (k = 0; k < N - 1; ++k) {
    68b7:	85 db                	test   %ebx,%ebx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1722
    last_U = matrix_U + ((N - 1) * N) / 2 - 1;
    68b9:	48 89 85 40 fc ff ff 	mov    %rax,-0x3c0(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1726
    x_0 = (uint8_t)(decoder->Params.OriginalCount);
    68c0:	41 8b 07             	mov    (%r15),%eax
    68c3:	89 85 3c fc ff ff    	mov    %eax,-0x3c4(%rbp)
    68c9:	88 85 5b fc ff ff    	mov    %al,-0x3a5(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1729
    for (k = 0; k < N - 1; ++k) {
    68cf:	0f 8e 90 03 00 00    	jle    6c65 <GenerateLDUDecomposition+0x455>
    68d5:	48 8d 85 bf fc ff ff 	lea    -0x341(%rbp),%rax
    68dc:	48 c7 85 78 fc ff ff 	movq   $0xffffffffffffffff,-0x388(%rbp)
    68e3:	ff ff ff ff 
    68e7:	48 c7 85 80 fc ff ff 	movq   $0x1,-0x380(%rbp)
    68ee:	01 00 00 00 
    68f2:	c7 85 b0 fc ff ff 00 	movl   $0x0,-0x350(%rbp)
    68f9:	00 00 00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1723
    firstOffset_U = 0;
    68fc:	c7 85 74 fc ff ff 00 	movl   $0x0,-0x38c(%rbp)
    6903:	00 00 00 
    6906:	49 c7 c6 00 00 00 00 	mov    $0x0,%r14
			6909: R_X86_64_32S	GFContext
    690d:	48 89 85 a8 fc ff ff 	mov    %rax,-0x358(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1730
        x_k = decoder->Recovery[k]->Index;
    6914:	48 8b 9d 80 fc ff ff 	mov    -0x380(%rbp),%rbx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1746
        diag_D[k] = gf_mul(D_kk, gf_mul(L_kk, U_kk));

        // Computing the k-th row of L and U
        row_L = matrix_L;
        row_U = rotated_row_U;
        for (j = k + 1; j < N; ++j) {
    691b:	83 85 b0 fc ff ff 01 	addl   $0x1,-0x350(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1730
        x_k = decoder->Recovery[k]->Index;
    6922:	49 8b 44 df 08       	mov    0x8(%r15,%rbx,8),%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1731
        y_k = decoder->ErasuresIndices[k];
    6927:	45 0f b6 ac 1f 1b 10 	movzbl 0x101b(%r15,%rbx,1),%r13d
    692e:	00 00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1730
        x_k = decoder->Recovery[k]->Index;
    6930:	0f b6 40 08          	movzbl 0x8(%rax),%eax
    6934:	88 85 b8 fc ff ff    	mov    %al,-0x348(%rbp)
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160
    return (uint8_t)(x ^ y);
    693a:	44 31 e8             	xor    %r13d,%eax
    693d:	0f b6 d0             	movzbl %al,%edx
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6940:	0f b6 84 1d bf fd ff 	movzbl -0x241(%rbp,%rbx,1),%eax
    6947:	ff 
    6948:	89 d1                	mov    %edx,%ecx
    694a:	c1 e1 08             	shl    $0x8,%ecx
    694d:	01 c8                	add    %ecx,%eax
    694f:	41 0f b6 bc 06 00 60 	movzbl 0x16000(%r14,%rax,1),%edi
    6956:	01 00 
    6958:	0f b6 84 1d bf fe ff 	movzbl -0x141(%rbp,%rbx,1),%eax
    695f:	ff 
    6960:	01 c8                	add    %ecx,%eax
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160
    return (uint8_t)(x ^ y);
    6962:	0f b6 8d 5b fc ff ff 	movzbl -0x3a5(%rbp),%ecx
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6969:	40 88 bd b5 fc ff ff 	mov    %dil,-0x34b(%rbp)
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166
    return GFContext.GF_MUL_TABLE[((unsigned)y << 8) + x];
    6970:	41 0f b6 84 06 00 60 	movzbl 0x16000(%r14,%rax,1),%eax
    6977:	01 00 
    6979:	89 bd 70 fc ff ff    	mov    %edi,-0x390(%rbp)
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160
    return (uint8_t)(x ^ y);
    697f:	44 31 e9             	xor    %r13d,%ecx
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166
    return GFContext.GF_MUL_TABLE[((unsigned)y << 8) + x];
    6982:	0f b6 c9             	movzbl %cl,%ecx
    6985:	c1 e1 08             	shl    $0x8,%ecx
    6988:	01 c8                	add    %ecx,%eax
    698a:	41 0f b6 84 06 00 60 	movzbl 0x6000(%r14,%rax,1),%eax
    6991:	00 00 
    6993:	88 85 b6 fc ff ff    	mov    %al,-0x34a(%rbp)
    6999:	89 85 5c fc ff ff    	mov    %eax,-0x3a4(%rbp)
    699f:	c1 e0 08             	shl    $0x8,%eax
    69a2:	01 f8                	add    %edi,%eax
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1741
        diag_D[k] = gf_mul(D_kk, gf_mul(L_kk, U_kk));
    69a4:	48 8b bd 50 fc ff ff 	mov    -0x3b0(%rbp),%rdi
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166
    69ab:	41 0f b6 84 06 00 60 	movzbl 0x6000(%r14,%rax,1),%eax
    69b2:	00 00 
    69b4:	c1 e0 08             	shl    $0x8,%eax
    69b7:	01 d0                	add    %edx,%eax
    69b9:	41 0f b6 84 06 00 60 	movzbl 0x6000(%r14,%rax,1),%eax
    69c0:	00 00 
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1741
    69c2:	88 44 1f ff          	mov    %al,-0x1(%rdi,%rbx,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1746
        for (j = k + 1; j < N; ++j) {
    69c6:	8b 85 b0 fc ff ff    	mov    -0x350(%rbp),%eax
    69cc:	39 85 8c fc ff ff    	cmp    %eax,-0x374(%rbp)
    69d2:	0f 8e 14 03 00 00    	jle    6cec <GenerateLDUDecomposition+0x4dc>
    69d8:	8b bd 88 fc ff ff    	mov    -0x378(%rbp),%edi
    69de:	48 8b b5 78 fc ff ff 	mov    -0x388(%rbp),%rsi
    69e5:	4c 8d 9d c0 fe ff ff 	lea    -0x140(%rbp),%r11
    69ec:	29 c7                	sub    %eax,%edi
    69ee:	48 89 f8             	mov    %rdi,%rax
    69f1:	48 89 bd 60 fc ff ff 	mov    %rdi,-0x3a0(%rbp)
    69f8:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
    69fc:	48 89 bd 68 fc ff ff 	mov    %rdi,-0x398(%rbp)
    6a03:	48 01 c7             	add    %rax,%rdi
    6a06:	48 8b 85 90 fc ff ff 	mov    -0x370(%rbp),%rax
    6a0d:	48 89 bd a0 fc ff ff 	mov    %rdi,-0x360(%rbp)
    6a14:	48 89 df             	mov    %rbx,%rdi
    6a17:	48 8d 9d c0 fd ff ff 	lea    -0x240(%rbp),%rbx
    6a1e:	48 01 f0             	add    %rsi,%rax
    6a21:	48 89 85 98 fc ff ff 	mov    %rax,-0x368(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1747 (discriminator 3)
            x_j = decoder->Recovery[j]->Index;
    6a28:	49 8b 44 ff 10       	mov    0x10(%r15,%rdi,8),%rax
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172 (discriminator 3)
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6a2d:	44 0f b6 14 3b       	movzbl (%rbx,%rdi,1),%r10d
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    return (uint8_t)(x ^ y);
    6a32:	44 89 ee             	mov    %r13d,%esi
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172 (discriminator 3)
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6a35:	45 0f b6 0c 3b       	movzbl (%r11,%rdi,1),%r9d
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1747 (discriminator 3)
    6a3a:	0f b6 50 08          	movzbl 0x8(%rax),%edx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1748 (discriminator 3)
            y_j = decoder->ErasuresIndices[j];
    6a3e:	41 0f b6 84 3f 1c 10 	movzbl 0x101c(%r15,%rdi,1),%eax
    6a45:	00 00 
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    return (uint8_t)(x ^ y);
    6a47:	31 d6                	xor    %edx,%esi
    6a49:	32 95 b8 fc ff ff    	xor    -0x348(%rbp),%dl
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172 (discriminator 3)
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6a4f:	40 0f b6 f6          	movzbl %sil,%esi
    6a53:	c1 e6 08             	shl    $0x8,%esi
    6a56:	42 8d 0c 16          	lea    (%rsi,%r10,1),%ecx
    6a5a:	0f b6 d2             	movzbl %dl,%edx
    6a5d:	45 0f b6 a4 0e 00 60 	movzbl 0x16000(%r14,%rcx,1),%r12d
    6a64:	01 00 
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    return (uint8_t)(x ^ y);
    6a66:	0f b6 8d b8 fc ff ff 	movzbl -0x348(%rbp),%ecx
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172 (discriminator 3)
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6a6d:	01 d6                	add    %edx,%esi
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    return (uint8_t)(x ^ y);
    6a6f:	31 c1                	xor    %eax,%ecx
    6a71:	44 31 e8             	xor    %r13d,%eax
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172 (discriminator 3)
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6a74:	0f b6 c9             	movzbl %cl,%ecx
    6a77:	0f b6 c0             	movzbl %al,%eax
    6a7a:	c1 e1 08             	shl    $0x8,%ecx
    6a7d:	46 8d 04 09          	lea    (%rcx,%r9,1),%r8d
    6a81:	01 c1                	add    %eax,%ecx
    6a83:	47 0f b6 84 06 00 60 	movzbl 0x16000(%r14,%r8,1),%r8d
    6a8a:	01 00 
    6a8c:	44 88 85 b7 fc ff ff 	mov    %r8b,-0x349(%rbp)
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1755 (discriminator 3)
            // L_jk = g[j] / (x_j + y_k)
            // U_kj = b[j] / (x_k + y_j)
            L_jk = gf_div(g[j], gf_add(x_j, y_k));
            U_kj = gf_div(b[j], gf_add(x_k, y_j));

            *matrix_L++ = L_jk;
    6a93:	4c 8b 85 98 fc ff ff 	mov    -0x368(%rbp),%r8
    6a9a:	45 88 24 38          	mov    %r12b,(%r8,%rdi,1)
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166 (discriminator 3)
    return GFContext.GF_MUL_TABLE[((unsigned)y << 8) + x];
    6a9e:	41 0f b6 94 36 00 60 	movzbl 0x16000(%r14,%rsi,1),%edx
    6aa5:	01 00 
    6aa7:	41 0f b6 84 0e 00 60 	movzbl 0x16000(%r14,%rcx,1),%eax
    6aae:	01 00 
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1756 (discriminator 3)
            *row_U++ = U_kj;
    6ab0:	44 0f b6 85 b7 fc ff 	movzbl -0x349(%rbp),%r8d
    6ab7:	ff 
    6ab8:	4c 8b a5 a8 fc ff ff 	mov    -0x358(%rbp),%r12
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166 (discriminator 3)
    6abf:	c1 e2 08             	shl    $0x8,%edx
    6ac2:	c1 e0 08             	shl    $0x8,%eax
    6ac5:	41 01 d2             	add    %edx,%r10d
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1756 (discriminator 3)
    6ac8:	45 88 04 3c          	mov    %r8b,(%r12,%rdi,1)
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166 (discriminator 3)
    6acc:	41 01 c1             	add    %eax,%r9d
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1760 (discriminator 3)

            // g[j] = g[j] * (x_j + x_k) / (x_j + y_k)
            // b[j] = b[j] * (y_j + y_k) / (y_j + x_k)
            g[j] = gf_mul(g[j], gf_div(gf_add(x_j, x_k), gf_add(x_j, y_k)));
    6acf:	43 0f b6 94 16 00 60 	movzbl 0x6000(%r14,%r10,1),%edx
    6ad6:	00 00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1761 (discriminator 3)
            b[j] = gf_mul(b[j], gf_div(gf_add(y_j, y_k), gf_add(y_j, x_k)));
    6ad8:	43 0f b6 84 0e 00 60 	movzbl 0x6000(%r14,%r9,1),%eax
    6adf:	00 00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1760 (discriminator 3)
            g[j] = gf_mul(g[j], gf_div(gf_add(x_j, x_k), gf_add(x_j, y_k)));
    6ae1:	88 14 3b             	mov    %dl,(%rbx,%rdi,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1761 (discriminator 3)
            b[j] = gf_mul(b[j], gf_div(gf_add(y_j, y_k), gf_add(y_j, x_k)));
    6ae4:	41 88 04 3b          	mov    %al,(%r11,%rdi,1)
    6ae8:	48 83 c7 01          	add    $0x1,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1746 (discriminator 3)
        for (j = k + 1; j < N; ++j) {
    6aec:	48 39 bd a0 fc ff ff 	cmp    %rdi,-0x360(%rbp)
    6af3:	0f 85 2f ff ff ff    	jne    6a28 <GenerateLDUDecomposition+0x218>
    6af9:	48 8b 85 90 fc ff ff 	mov    -0x370(%rbp),%rax
    6b00:	48 8b 9d 60 fc ff ff 	mov    -0x3a0(%rbp),%rbx
    6b07:	4c 8d 64 18 01       	lea    0x1(%rax,%rbx,1),%r12
    6b0c:	8b 9d 8c fc ff ff    	mov    -0x374(%rbp),%ebx
    6b12:	2b 9d b0 fc ff ff    	sub    -0x350(%rbp),%ebx
gf_div_mem():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:206

/// Performs "x[] /= y" bulk memory operation
static FORCE_INLINE void gf_div_mem(void * __restrict vz, const void * __restrict vx, uint8_t y, int bytes)
{
    // Multiply by inverse
    gf_mul_mem(vz, vx, y == 1 ? (uint8_t)1 : GFContext.GF_INV_TABLE[y], bytes);
    6b18:	ba 01 00 00 00       	mov    $0x1,%edx
    6b1d:	80 bd b5 fc ff ff 01 	cmpb   $0x1,-0x34b(%rbp)
    6b24:	74 10                	je     6b36 <GenerateLDUDecomposition+0x326>
    6b26:	48 63 85 70 fc ff ff 	movslq -0x390(%rbp),%rax
    6b2d:	41 0f b6 94 06 00 60 	movzbl 0x26000(%r14,%rax,1),%edx
    6b34:	02 00 
    6b36:	48 8b bd 90 fc ff ff 	mov    -0x370(%rbp),%rdi
    6b3d:	89 d9                	mov    %ebx,%ecx
    6b3f:	48 89 fe             	mov    %rdi,%rsi
    6b42:	e8 00 00 00 00       	callq  6b47 <GenerateLDUDecomposition+0x337>
			6b43: R_X86_64_PC32	gf_mul_mem-0x4
    6b47:	80 bd b6 fc ff ff 01 	cmpb   $0x1,-0x34a(%rbp)
    6b4e:	ba 01 00 00 00       	mov    $0x1,%edx
    6b53:	74 10                	je     6b65 <GenerateLDUDecomposition+0x355>
    6b55:	48 63 85 5c fc ff ff 	movslq -0x3a4(%rbp),%rax
    6b5c:	41 0f b6 94 06 00 60 	movzbl 0x26000(%r14,%rax,1),%edx
    6b63:	02 00 
    6b65:	48 8d b5 c0 fc ff ff 	lea    -0x340(%rbp),%rsi
    6b6c:	89 d9                	mov    %ebx,%ecx
    6b6e:	48 89 f7             	mov    %rsi,%rdi
    6b71:	e8 00 00 00 00       	callq  6b76 <GenerateLDUDecomposition+0x366>
			6b72: R_X86_64_PC32	gf_mul_mem-0x4
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1772
        count = N - (k + 1);
        gf_div_mem(row_L, row_L, L_kk, count);
        gf_div_mem(rotated_row_U, rotated_row_U, U_kk, count);

        // Copy U matrix row into place in memory.
        output_U = last_U + firstOffset_U;
    6b76:	48 63 95 74 fc ff ff 	movslq -0x38c(%rbp),%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1774
        row_U = rotated_row_U;
        for (j = k + 1; j < N; ++j) {
    6b7d:	8b 85 b0 fc ff ff    	mov    -0x350(%rbp),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1772
        output_U = last_U + firstOffset_U;
    6b83:	48 03 95 40 fc ff ff 	add    -0x3c0(%rbp),%rdx
    6b8a:	48 03 95 48 fc ff ff 	add    -0x3b8(%rbp),%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1774
        for (j = k + 1; j < N; ++j) {
    6b91:	39 85 8c fc ff ff    	cmp    %eax,-0x374(%rbp)
    6b97:	7e 31                	jle    6bca <GenerateLDUDecomposition+0x3ba>
    6b99:	8b b5 88 fc ff ff    	mov    -0x378(%rbp),%esi
    6b9f:	48 8b bd 78 fc ff ff 	mov    -0x388(%rbp),%rdi
    6ba6:	29 c6                	sub    %eax,%esi
    6ba8:	31 c0                	xor    %eax,%eax
    6baa:	48 83 c6 01          	add    $0x1,%rsi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1775 (discriminator 3)
            *output_U = *row_U++;
    6bae:	0f b6 8c 05 c0 fc ff 	movzbl -0x340(%rbp,%rax,1),%ecx
    6bb5:	ff 
    6bb6:	88 0a                	mov    %cl,(%rdx)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1776 (discriminator 3)
            output_U -= j;
    6bb8:	48 89 f9             	mov    %rdi,%rcx
    6bbb:	48 29 c1             	sub    %rax,%rcx
    6bbe:	48 83 c0 01          	add    $0x1,%rax
    6bc2:	48 01 ca             	add    %rcx,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1774 (discriminator 3)
        for (j = k + 1; j < N; ++j) {
    6bc5:	48 39 c6             	cmp    %rax,%rsi
    6bc8:	75 e4                	jne    6bae <GenerateLDUDecomposition+0x39e>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1778
        }
        firstOffset_U -= k + 2;
    6bca:	8b 85 80 fc ff ff    	mov    -0x380(%rbp),%eax
    6bd0:	48 83 ad 78 fc ff ff 	subq   $0x1,-0x388(%rbp)
    6bd7:	01 
    6bd8:	48 83 ad a8 fc ff ff 	subq   $0x1,-0x358(%rbp)
    6bdf:	01 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1729
    for (k = 0; k < N - 1; ++k) {
    6be0:	8b 9d 88 fc ff ff    	mov    -0x378(%rbp),%ebx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1778
        firstOffset_U -= k + 2;
    6be6:	83 c0 01             	add    $0x1,%eax
    6be9:	29 85 74 fc ff ff    	sub    %eax,-0x38c(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1729
    for (k = 0; k < N - 1; ++k) {
    6bef:	39 9d b0 fc ff ff    	cmp    %ebx,-0x350(%rbp)
    6bf5:	48 8b 85 68 fc ff ff 	mov    -0x398(%rbp),%rax
    6bfc:	48 89 85 80 fc ff ff 	mov    %rax,-0x380(%rbp)
    6c03:	74 0c                	je     6c11 <GenerateLDUDecomposition+0x401>
    6c05:	4c 89 a5 90 fc ff ff 	mov    %r12,-0x370(%rbp)
    6c0c:	e9 03 fd ff ff       	jmpq   6914 <GenerateLDUDecomposition+0x104>
    6c11:	48 63 9d b0 fc ff ff 	movslq -0x350(%rbp),%rbx
    6c18:	44 0f b6 b5 5b fc ff 	movzbl -0x3a5(%rbp),%r14d
    6c1f:	ff 
    6c20:	49 89 dc             	mov    %rbx,%r12
    6c23:	49 89 dd             	mov    %rbx,%r13
    6c26:	48 89 9d b8 fc ff ff 	mov    %rbx,-0x348(%rbp)
    6c2d:	48 8b 9d 48 fc ff ff 	mov    -0x3b8(%rbp),%rbx
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    return (uint8_t)(x ^ y);
    6c34:	43 0f b6 94 2f 1c 10 	movzbl 0x101c(%r15,%r13,1),%edx
    6c3b:	00 00 
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1787 (discriminator 3)
    row_U = matrix_U;
    for (j = N - 1; j > 0; --j) {
        y_j = decoder->ErasuresIndices[j];
        count = j;

        gf_mul_mem(row_U, row_U, gf_add(x_0, y_j), count);
    6c3d:	44 89 e1             	mov    %r12d,%ecx
    6c40:	48 89 de             	mov    %rbx,%rsi
    6c43:	48 89 df             	mov    %rbx,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1788 (discriminator 3)
        row_U += count;
    6c46:	4c 01 eb             	add    %r13,%rbx
    6c49:	49 83 ed 01          	sub    $0x1,%r13
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    6c4d:	44 31 f2             	xor    %r14d,%edx
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1787 (discriminator 3)
        gf_mul_mem(row_U, row_U, gf_add(x_0, y_j), count);
    6c50:	0f b6 d2             	movzbl %dl,%edx
    6c53:	e8 00 00 00 00       	callq  6c58 <GenerateLDUDecomposition+0x448>
			6c54: R_X86_64_PC32	gf_mul_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1783 (discriminator 3)
    for (j = N - 1; j > 0; --j) {
    6c58:	41 83 ec 01          	sub    $0x1,%r12d
    6c5c:	75 d6                	jne    6c34 <GenerateLDUDecomposition+0x424>
    6c5e:	48 8b 9d b8 fc ff ff 	mov    -0x348(%rbp),%rbx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1792
    }

    x_n = decoder->Recovery[N - 1]->Index;
    y_n = decoder->ErasuresIndices[N - 1];
    6c65:	41 0f b6 94 1f 1c 10 	movzbl 0x101c(%r15,%rbx,1),%edx
    6c6c:	00 00 
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160
    6c6e:	0f b6 85 3c fc ff ff 	movzbl -0x3c4(%rbp),%eax
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166
    return GFContext.GF_MUL_TABLE[((unsigned)y << 8) + x];
    6c75:	0f b6 8c 1d c0 fe ff 	movzbl -0x140(%rbp,%rbx,1),%ecx
    6c7c:	ff 
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160
    return (uint8_t)(x ^ y);
    6c7d:	31 d0                	xor    %edx,%eax
gf_mul():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:166
    return GFContext.GF_MUL_TABLE[((unsigned)y << 8) + x];
    6c7f:	0f b6 c0             	movzbl %al,%eax
    6c82:	c1 e0 08             	shl    $0x8,%eax
    6c85:	01 c8                	add    %ecx,%eax
    6c87:	0f b6 8c 1d c0 fd ff 	movzbl -0x240(%rbp,%rbx,1),%ecx
    6c8e:	ff 
    6c8f:	0f b6 80 00 00 00 00 	movzbl 0x0(%rax),%eax
			6c92: R_X86_64_32S	GFContext+0x6000
    6c96:	c1 e0 08             	shl    $0x8,%eax
    6c99:	01 c8                	add    %ecx,%eax
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1791
    x_n = decoder->Recovery[N - 1]->Index;
    6c9b:	49 8b 4c df 10       	mov    0x10(%r15,%rbx,8),%rcx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1801
    // U_nn = b[N-1] * (x_0 + y_n)
    L_nn = g[N - 1];
    U_nn = gf_mul(b[N - 1], gf_add(x_0, y_n));

    // diag_D[N-1] = L_nn * D_nn * U_nn
    diag_D[N - 1] = gf_div(gf_mul(L_nn, U_nn), gf_add(x_n, y_n));
    6ca0:	48 8b 9d 50 fc ff ff 	mov    -0x3b0(%rbp),%rbx
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6ca7:	0f b6 80 00 00 00 00 	movzbl 0x0(%rax),%eax
			6caa: R_X86_64_32S	GFContext+0x6000
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160
    return (uint8_t)(x ^ y);
    6cae:	32 51 08             	xor    0x8(%rcx),%dl
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6cb1:	0f b6 d2             	movzbl %dl,%edx
    6cb4:	c1 e2 08             	shl    $0x8,%edx
    6cb7:	01 c2                	add    %eax,%edx
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1801
    6cb9:	48 63 85 8c fc ff ff 	movslq -0x374(%rbp),%rax
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172
    6cc0:	0f b6 92 00 00 00 00 	movzbl 0x0(%rdx),%edx
			6cc3: R_X86_64_32S	GFContext+0x16000
GenerateLDUDecomposition():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1801
    6cc7:	88 54 03 ff          	mov    %dl,-0x1(%rbx,%rax,1)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1802
}
    6ccb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6ccf:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    6cd6:	00 00 
    6cd8:	75 3e                	jne    6d18 <GenerateLDUDecomposition+0x508>
    6cda:	48 81 c4 a8 03 00 00 	add    $0x3a8,%rsp
    6ce1:	5b                   	pop    %rbx
    6ce2:	41 5c                	pop    %r12
    6ce4:	41 5d                	pop    %r13
    6ce6:	41 5e                	pop    %r14
    6ce8:	41 5f                	pop    %r15
    6cea:	5d                   	pop    %rbp
    6ceb:	c3                   	retq   
    6cec:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1746
        for (j = k + 1; j < N; ++j) {
    6cf3:	4c 8b a5 90 fc ff ff 	mov    -0x370(%rbp),%r12
    6cfa:	48 83 c0 01          	add    $0x1,%rax
    6cfe:	48 89 85 68 fc ff ff 	mov    %rax,-0x398(%rbp)
    6d05:	e9 02 fe ff ff       	jmpq   6b0c <GenerateLDUDecomposition+0x2fc>
    6d0a:	83 e8 01             	sub    $0x1,%eax
    6d0d:	89 85 88 fc ff ff    	mov    %eax,-0x378(%rbp)
    6d13:	e9 80 fb ff ff       	jmpq   6898 <GenerateLDUDecomposition+0x88>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1802
}
    6d18:	e8 00 00 00 00       	callq  6d1d <GenerateLDUDecomposition+0x50d>
			6d19: R_X86_64_PC32	__stack_chk_fail-0x4
    6d1d:	0f 1f 00             	nopl   (%rax)

0000000000006d20 <Decode>:
Decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1804

void Decode(CauchyDecoder *decoder) {
    6d20:	e8 00 00 00 00       	callq  6d25 <Decode+0x5>
			6d21: R_X86_64_PC32	__fentry__-0x4
    6d25:	55                   	push   %rbp
    6d26:	48 89 e5             	mov    %rsp,%rbp
    6d29:	41 57                	push   %r15
    6d2b:	41 56                	push   %r14
    6d2d:	41 55                	push   %r13
    6d2f:	41 54                	push   %r12
    6d31:	49 89 ff             	mov    %rdi,%r15
    6d34:	53                   	push   %rbx
    6d35:	48 81 ec 58 08 00 00 	sub    $0x858,%rsp
    6d3c:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    6d43:	00 00 
    6d45:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    6d49:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1806
    // Matrix size is NxN, where N is the number of recovery blocks used.
    const int N = decoder->RecoveryCount;
    6d4b:	8b 87 10 08 00 00    	mov    0x810(%rdi),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1816
    int originalIndex, recoveryIndex, j, i;
    int requiredSpace;
    uint8_t *inBlock, *outBlock, *dynamicMatrix, *matrix, *matrix_U, *diag_D, *matrix_L;
    uint8_t inRow, x_i, y_j, matrixElement, c_ij;
    static const int StackAllocSize = 2048;
    uint8_t stackMatrix[StackAllocSize];
    6d51:	48 89 65 a8          	mov    %rsp,-0x58(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1806
    const int N = decoder->RecoveryCount;
    6d55:	89 45 9c             	mov    %eax,-0x64(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1809
    const uint8_t x_0 = (uint8_t)(decoder->Params.OriginalCount);
    6d58:	0f b6 07             	movzbl (%rdi),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1820
    void *block_j;
    void *block_i, *block;
    // Eliminate original data from the the recovery rows
    for (originalIndex = 0; originalIndex < decoder->OriginalCount; ++originalIndex) {
    6d5b:	8b bf 18 10 00 00    	mov    0x1018(%rdi),%edi
    6d61:	85 ff                	test   %edi,%edi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1809
    const uint8_t x_0 = (uint8_t)(decoder->Params.OriginalCount);
    6d63:	88 45 90             	mov    %al,-0x70(%rbp)
    6d66:	8b 45 9c             	mov    -0x64(%rbp),%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1820
    for (originalIndex = 0; originalIndex < decoder->OriginalCount; ++originalIndex) {
    6d69:	0f 8e 71 02 00 00    	jle    6fe0 <Decode+0x2c0>
    6d6f:	83 e8 01             	sub    $0x1,%eax
    6d72:	48 c7 45 a0 01 00 00 	movq   $0x1,-0x60(%rbp)
    6d79:	00 
    6d7a:	49 c7 c6 00 00 00 00 	mov    $0x0,%r14
			6d7d: R_X86_64_32S	GFContext
    6d81:	89 45 98             	mov    %eax,-0x68(%rbp)
    6d84:	49 8d 44 c7 18       	lea    0x18(%r15,%rax,8),%rax
    6d89:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1821
        inBlock = (uint8_t*)(decoder->Original[originalIndex]->Block);
    6d8d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1824
        inRow = decoder->Original[originalIndex]->Index;

        for (recoveryIndex = 0; recoveryIndex < N; ++recoveryIndex) {
    6d91:	8b 75 9c             	mov    -0x64(%rbp),%esi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1821
        inBlock = (uint8_t*)(decoder->Original[originalIndex]->Block);
    6d94:	49 8b 84 c7 10 08 00 	mov    0x810(%r15,%rax,8),%rax
    6d9b:	00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1824
        for (recoveryIndex = 0; recoveryIndex < N; ++recoveryIndex) {
    6d9c:	85 f6                	test   %esi,%esi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1821
        inBlock = (uint8_t*)(decoder->Original[originalIndex]->Block);
    6d9e:	4c 8b 28             	mov    (%rax),%r13
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1822
        inRow = decoder->Original[originalIndex]->Index;
    6da1:	44 0f b6 60 08       	movzbl 0x8(%rax),%r12d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1824
        for (recoveryIndex = 0; recoveryIndex < N; ++recoveryIndex) {
    6da6:	7e 51                	jle    6df9 <Decode+0xd9>
    6da8:	0f b6 5d 90          	movzbl -0x70(%rbp),%ebx
    6dac:	44 31 e3             	xor    %r12d,%ebx
    6daf:	0f b6 c3             	movzbl %bl,%eax
    6db2:	49 8d 5f 10          	lea    0x10(%r15),%rbx
    6db6:	89 45 b8             	mov    %eax,-0x48(%rbp)
    6db9:	4c 89 f8             	mov    %r15,%rax
    6dbc:	49 89 df             	mov    %rbx,%r15
    6dbf:	48 89 c3             	mov    %rax,%rbx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1825 (discriminator 3)
            outBlock = (uint8_t*)(decoder->Recovery[recoveryIndex]->Block);
    6dc2:	49 8b 3f             	mov    (%r15),%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1830 (discriminator 3)
            x_i = decoder->Recovery[recoveryIndex]->Index;
            y_j = inRow;
            matrixElement = GetMatrixElement(x_i, x_0, y_j);

            gf_muladd_mem(outBlock, matrixElement, inBlock, decoder->Params.BlockBytes);
    6dc5:	8b 4b 08             	mov    0x8(%rbx),%ecx
    6dc8:	4c 89 ea             	mov    %r13,%rdx
    6dcb:	49 83 c7 08          	add    $0x8,%r15
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    return (uint8_t)(x ^ y);
    6dcf:	0f b6 47 08          	movzbl 0x8(%rdi),%eax
Decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1830 (discriminator 3)
    6dd3:	48 8b 3f             	mov    (%rdi),%rdi
gf_add():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:160 (discriminator 3)
    6dd6:	44 31 e0             	xor    %r12d,%eax
gf_div():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:172 (discriminator 3)
    return GFContext.GF_DIV_TABLE[((unsigned)y << 8) + x];
    6dd9:	0f b6 c0             	movzbl %al,%eax
    6ddc:	c1 e0 08             	shl    $0x8,%eax
    6ddf:	03 45 b8             	add    -0x48(%rbp),%eax
Decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1830 (discriminator 3)
    6de2:	41 0f b6 b4 06 00 60 	movzbl 0x16000(%r14,%rax,1),%esi
    6de9:	01 00 
    6deb:	e8 00 00 00 00       	callq  6df0 <Decode+0xd0>
			6dec: R_X86_64_PC32	gf_muladd_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1824 (discriminator 3)
        for (recoveryIndex = 0; recoveryIndex < N; ++recoveryIndex) {
    6df0:	4c 3b 7d b0          	cmp    -0x50(%rbp),%r15
    6df4:	75 cc                	jne    6dc2 <Decode+0xa2>
    6df6:	49 89 df             	mov    %rbx,%r15
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1820
    for (originalIndex = 0; originalIndex < decoder->OriginalCount; ++originalIndex) {
    6df9:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    6dfd:	89 d0                	mov    %edx,%eax
    6dff:	48 83 c2 01          	add    $0x1,%rdx
    6e03:	41 39 87 18 10 00 00 	cmp    %eax,0x1018(%r15)
    6e0a:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    6e0e:	0f 8f 79 ff ff ff    	jg     6d8d <Decode+0x6d>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1837
    }

    // Allocate matrix
    dynamicMatrix = NULL;
    matrix = stackMatrix;
    requiredSpace = N * N;
    6e14:	8b 7d 9c             	mov    -0x64(%rbp),%edi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1835
    dynamicMatrix = NULL;
    6e17:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
    6e1e:	00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1837
    requiredSpace = N * N;
    6e1f:	89 f8                	mov    %edi,%eax
    6e21:	0f af c7             	imul   %edi,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1838
    if (requiredSpace > StackAllocSize) {
    6e24:	3d 00 08 00 00       	cmp    $0x800,%eax
    6e29:	7e 15                	jle    6e40 <Decode+0x120>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1839
        dynamicMatrix = cauchy_malloc(requiredSpace);
    6e2b:	48 63 f8             	movslq %eax,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    6e2e:	be c0 00 40 01       	mov    $0x14000c0,%esi
    6e33:	e8 00 00 00 00       	callq  6e38 <Decode+0x118>
			6e34: R_X86_64_PC32	__kmalloc-0x4
    6e38:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    6e3c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
Decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1853
        L is lower-triangular, diagonal is all ones.
        D is a diagonal matrix.
        U is upper-triangular, diagonal is all ones.
    */
    matrix_U = matrix;
    diag_D = matrix_U + (N - 1) * N / 2;
    6e40:	8b 5d 98             	mov    -0x68(%rbp),%ebx
    6e43:	4c 63 65 9c          	movslq -0x64(%rbp),%r12
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1855
    matrix_L = diag_D + N;
    GenerateLDUDecomposition(decoder, matrix_L, diag_D, matrix_U);
    6e47:	4c 89 ff             	mov    %r15,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1853
    diag_D = matrix_U + (N - 1) * N / 2;
    6e4a:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
    6e4e:	89 da                	mov    %ebx,%edx
    6e50:	89 5d 8c             	mov    %ebx,-0x74(%rbp)
    6e53:	41 0f af d4          	imul   %r12d,%edx
    6e57:	89 d0                	mov    %edx,%eax
    6e59:	c1 e8 1f             	shr    $0x1f,%eax
    6e5c:	01 d0                	add    %edx,%eax
    6e5e:	d1 f8                	sar    %eax
    6e60:	48 98                	cltq   
    6e62:	48 01 c8             	add    %rcx,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1854
    matrix_L = diag_D + N;
    6e65:	49 01 c4             	add    %rax,%r12
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1855
    GenerateLDUDecomposition(decoder, matrix_L, diag_D, matrix_U);
    6e68:	48 89 c2             	mov    %rax,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1853
    diag_D = matrix_U + (N - 1) * N / 2;
    6e6b:	48 89 45 90          	mov    %rax,-0x70(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1855
    GenerateLDUDecomposition(decoder, matrix_L, diag_D, matrix_U);
    6e6f:	4c 89 e6             	mov    %r12,%rsi
    6e72:	e8 00 00 00 00       	callq  6e77 <Decode+0x157>
			6e73: R_X86_64_PC32	GenerateLDUDecomposition-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1861

    /*
        Eliminate lower left triangle.
    */
    // For each column,
    for (j = 0; j < N - 1; ++j) {
    6e77:	85 db                	test   %ebx,%ebx
    6e79:	0f 8e 6c 01 00 00    	jle    6feb <Decode+0x2cb>
    6e7f:	4d 8d 77 08          	lea    0x8(%r15),%r14
    6e83:	4c 89 f8             	mov    %r15,%rax
    6e86:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
    6e8d:	4d 89 f7             	mov    %r14,%r15
    6e90:	49 89 c6             	mov    %rax,%r14
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1862
        block_j = decoder->Recovery[j]->Block;
    6e93:	49 8b 47 08          	mov    0x8(%r15),%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1865

        // For each row,
        for (i = j + 1; i < N; ++i) {
    6e97:	83 45 b0 01          	addl   $0x1,-0x50(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1862
        block_j = decoder->Recovery[j]->Block;
    6e9b:	48 8b 00             	mov    (%rax),%rax
    6e9e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1865
        for (i = j + 1; i < N; ++i) {
    6ea2:	8b 45 b0             	mov    -0x50(%rbp),%eax
    6ea5:	39 45 9c             	cmp    %eax,-0x64(%rbp)
    6ea8:	7e 49                	jle    6ef3 <Decode+0x1d3>
    6eaa:	8b 5d 98             	mov    -0x68(%rbp),%ebx
    6ead:	45 31 ed             	xor    %r13d,%r13d
    6eb0:	29 c3                	sub    %eax,%ebx
    6eb2:	4c 89 f0             	mov    %r14,%rax
    6eb5:	4d 89 e6             	mov    %r12,%r14
    6eb8:	48 83 c3 01          	add    $0x1,%rbx
    6ebc:	49 89 dc             	mov    %rbx,%r12
    6ebf:	48 89 c3             	mov    %rax,%rbx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1866 (discriminator 3)
            block_i = decoder->Recovery[i]->Block;
    6ec2:	4b 8b 44 ef 10       	mov    0x10(%r15,%r13,8),%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1869 (discriminator 3)
            c_ij = *matrix_L++; // Matrix elements are stored column-first, top-down.

            gf_muladd_mem(block_i, c_ij, block_j, decoder->Params.BlockBytes);
    6ec7:	43 0f b6 34 2e       	movzbl (%r14,%r13,1),%esi
    6ecc:	49 83 c5 01          	add    $0x1,%r13
    6ed0:	8b 4b 08             	mov    0x8(%rbx),%ecx
    6ed3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    6ed7:	48 8b 38             	mov    (%rax),%rdi
    6eda:	e8 00 00 00 00       	callq  6edf <Decode+0x1bf>
			6edb: R_X86_64_PC32	gf_muladd_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1865 (discriminator 3)
        for (i = j + 1; i < N; ++i) {
    6edf:	4d 39 ec             	cmp    %r13,%r12
    6ee2:	75 de                	jne    6ec2 <Decode+0x1a2>
    6ee4:	48 89 d8             	mov    %rbx,%rax
    6ee7:	4c 89 e3             	mov    %r12,%rbx
    6eea:	4d 89 f4             	mov    %r14,%r12
    6eed:	49 01 dc             	add    %rbx,%r12
    6ef0:	49 89 c6             	mov    %rax,%r14
    6ef3:	49 83 c7 08          	add    $0x8,%r15
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1861
    for (j = 0; j < N - 1; ++j) {
    6ef7:	8b 55 98             	mov    -0x68(%rbp),%edx
    6efa:	39 55 b0             	cmp    %edx,-0x50(%rbp)
    6efd:	75 94                	jne    6e93 <Decode+0x173>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1876
    }

    /*
        Eliminate diagonal.
    */
    for (i = 0; i < N; ++i) {
    6eff:	8b 45 9c             	mov    -0x64(%rbp),%eax
    6f02:	4d 89 f7             	mov    %r14,%r15
    6f05:	85 c0                	test   %eax,%eax
    6f07:	7e 58                	jle    6f61 <Decode+0x241>
gf_div_mem():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:206
    gf_mul_mem(vz, vx, y == 1 ? (uint8_t)1 : GFContext.GF_INV_TABLE[y], bytes);
    6f09:	44 8b 6d 9c          	mov    -0x64(%rbp),%r13d
    6f0d:	4c 8b 75 90          	mov    -0x70(%rbp),%r14
Decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1865
        for (i = j + 1; i < N; ++i) {
    6f11:	45 31 e4             	xor    %r12d,%r12d
gf_div_mem():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:206
    6f14:	48 c7 c3 00 00 00 00 	mov    $0x0,%rbx
			6f17: R_X86_64_32S	GFContext
Decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1879 (discriminator 3)
        block = decoder->Recovery[i]->Block;

        decoder->Recovery[i]->Index = decoder->ErasuresIndices[i];
    6f1b:	43 0f b6 94 27 1c 10 	movzbl 0x101c(%r15,%r12,1),%edx
    6f22:	00 00 
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1877 (discriminator 3)
        block = decoder->Recovery[i]->Block;
    6f24:	4b 8b 44 e7 10       	mov    0x10(%r15,%r12,8),%rax
    6f29:	48 8b 38             	mov    (%rax),%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1879 (discriminator 3)
        decoder->Recovery[i]->Index = decoder->ErasuresIndices[i];
    6f2c:	88 50 08             	mov    %dl,0x8(%rax)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1881 (discriminator 3)

        gf_div_mem(block, block, diag_D[i], decoder->Params.BlockBytes);
    6f2f:	43 0f b6 04 26       	movzbl (%r14,%r12,1),%eax
gf_div_mem():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:206 (discriminator 3)
    6f34:	ba 01 00 00 00       	mov    $0x1,%edx
Decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1881 (discriminator 3)
    6f39:	41 8b 4f 08          	mov    0x8(%r15),%ecx
gf_div_mem():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:206 (discriminator 3)
    6f3d:	3c 01                	cmp    $0x1,%al
    6f3f:	74 08                	je     6f49 <Decode+0x229>
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:206
    6f41:	0f b6 94 03 00 60 02 	movzbl 0x26000(%rbx,%rax,1),%edx
    6f48:	00 
    6f49:	48 89 fe             	mov    %rdi,%rsi
    6f4c:	49 83 c4 01          	add    $0x1,%r12
    6f50:	e8 00 00 00 00       	callq  6f55 <Decode+0x235>
			6f51: R_X86_64_PC32	gf_mul_mem-0x4
Decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1876
    for (i = 0; i < N; ++i) {
    6f55:	45 39 e5             	cmp    %r12d,%r13d
    6f58:	7f c1                	jg     6f1b <Decode+0x1fb>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1887
    }

    /*
        Eliminate upper right triangle.
    */
    for (j = N - 1; j >= 1; --j) {
    6f5a:	8b 4d 98             	mov    -0x68(%rbp),%ecx
    6f5d:	85 c9                	test   %ecx,%ecx
    6f5f:	7e 58                	jle    6fb9 <Decode+0x299>
    6f61:	48 63 45 98          	movslq -0x68(%rbp),%rax
    6f65:	44 8b 75 8c          	mov    -0x74(%rbp),%r14d
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1888
        block_j = decoder->Recovery[j]->Block;
    6f69:	49 8b 44 c7 10       	mov    0x10(%r15,%rax,8),%rax
    6f6e:	4c 8b 65 a8          	mov    -0x58(%rbp),%r12
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1890

        for (i = j - 1; i >= 0; --i) {
    6f72:	41 83 ee 01          	sub    $0x1,%r14d
    6f76:	44 89 f3             	mov    %r14d,%ebx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1888
        block_j = decoder->Recovery[j]->Block;
    6f79:	4c 8b 28             	mov    (%rax),%r13
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1891 (discriminator 3)
            block_i = decoder->Recovery[i]->Block;
    6f7c:	48 63 c3             	movslq %ebx,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1894 (discriminator 3)
            c_ij = *matrix_U++; // Matrix elements are stored column-first, bottom-up.

            gf_muladd_mem(block_i, c_ij, block_j, decoder->Params.BlockBytes);
    6f7f:	41 0f b6 34 24       	movzbl (%r12),%esi
    6f84:	41 8b 4f 08          	mov    0x8(%r15),%ecx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1891 (discriminator 3)
            block_i = decoder->Recovery[i]->Block;
    6f88:	49 8b 44 c7 10       	mov    0x10(%r15,%rax,8),%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1894 (discriminator 3)
            gf_muladd_mem(block_i, c_ij, block_j, decoder->Params.BlockBytes);
    6f8d:	4c 89 ea             	mov    %r13,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1890 (discriminator 3)
        for (i = j - 1; i >= 0; --i) {
    6f90:	83 eb 01             	sub    $0x1,%ebx
    6f93:	49 83 c4 01          	add    $0x1,%r12
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1894 (discriminator 3)
            gf_muladd_mem(block_i, c_ij, block_j, decoder->Params.BlockBytes);
    6f97:	48 8b 38             	mov    (%rax),%rdi
    6f9a:	e8 00 00 00 00       	callq  6f9f <Decode+0x27f>
			6f9b: R_X86_64_PC32	gf_muladd_mem-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1890 (discriminator 3)
        for (i = j - 1; i >= 0; --i) {
    6f9f:	83 fb ff             	cmp    $0xffffffff,%ebx
    6fa2:	75 d8                	jne    6f7c <Decode+0x25c>
    6fa4:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
    6fa8:	49 63 c6             	movslq %r14d,%rax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1887 (discriminator 1)
    for (j = N - 1; j >= 1; --j) {
    6fab:	45 85 f6             	test   %r14d,%r14d
    6fae:	48 8d 54 07 01       	lea    0x1(%rdi,%rax,1),%rdx
    6fb3:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    6fb7:	75 b0                	jne    6f69 <Decode+0x249>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1898
        }
    }

    kfree(dynamicMatrix);
    6fb9:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    6fbd:	e8 00 00 00 00       	callq  6fc2 <Decode+0x2a2>
			6fbe: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1899
}
    6fc2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    6fc6:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    6fcd:	00 00 
    6fcf:	75 27                	jne    6ff8 <Decode+0x2d8>
    6fd1:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    6fd5:	5b                   	pop    %rbx
    6fd6:	41 5c                	pop    %r12
    6fd8:	41 5d                	pop    %r13
    6fda:	41 5e                	pop    %r14
    6fdc:	41 5f                	pop    %r15
    6fde:	5d                   	pop    %rbp
    6fdf:	c3                   	retq   
    6fe0:	83 e8 01             	sub    $0x1,%eax
    6fe3:	89 45 98             	mov    %eax,-0x68(%rbp)
    6fe6:	e9 29 fe ff ff       	jmpq   6e14 <Decode+0xf4>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1876
    for (i = 0; i < N; ++i) {
    6feb:	8b 55 9c             	mov    -0x64(%rbp),%edx
    6fee:	85 d2                	test   %edx,%edx
    6ff0:	0f 8f 13 ff ff ff    	jg     6f09 <Decode+0x1e9>
    6ff6:	eb c1                	jmp    6fb9 <Decode+0x299>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1899
}
    6ff8:	e8 00 00 00 00       	callq  6ffd <Decode+0x2dd>
			6ff9: R_X86_64_PC32	__stack_chk_fail-0x4
    6ffd:	0f 1f 00             	nopl   (%rax)

0000000000007000 <cauchy_rs_decode>:
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1907
    cauchy_encoder_params params, // Encoder params
    uint8_t** dataBlocks,
    uint8_t** parityBlocks,
    uint8_t* erasures,
    uint8_t num_erasures)         // Array of 'originalCount' blocks as described above
{
    7000:	e8 00 00 00 00       	callq  7005 <cauchy_rs_decode+0x5>
			7001: R_X86_64_PC32	__fentry__-0x4
    7005:	55                   	push   %rbp
    7006:	48 89 e5             	mov    %rsp,%rbp
    7009:	41 57                	push   %r15
    700b:	41 56                	push   %r14
    700d:	41 55                	push   %r13
    700f:	41 54                	push   %r12
    7011:	41 89 f7             	mov    %esi,%r15d
    7014:	53                   	push   %rbx
    7015:	89 fb                	mov    %edi,%ebx
    7017:	49 89 d5             	mov    %rdx,%r13
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    701a:	ba 20 11 00 00       	mov    $0x1120,%edx
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1907
    701f:	48 83 ec 48          	sub    $0x48,%rsp
    7023:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
    7027:	48 c1 ef 20          	shr    $0x20,%rdi
    702b:	49 89 fe             	mov    %rdi,%r14
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    702e:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 7035 <cauchy_rs_decode+0x35>
			7031: R_X86_64_PC32	kmalloc_caches+0x64
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1907
    7035:	89 75 9c             	mov    %esi,-0x64(%rbp)
    7038:	89 75 c8             	mov    %esi,-0x38(%rbp)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    703b:	be c0 00 40 01       	mov    $0x14000c0,%esi
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1907
    7040:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    7044:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
    7048:	44 89 4d b8          	mov    %r9d,-0x48(%rbp)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    704c:	e8 00 00 00 00       	callq  7051 <cauchy_rs_decode+0x51>
			704d: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1909
    CauchyDecoder *state = cauchy_malloc(sizeof(CauchyDecoder));
    cauchy_block *blocks = cauchy_malloc(sizeof(cauchy_block) * params.OriginalCount);
    7051:	48 63 fb             	movslq %ebx,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    7054:	be c0 00 40 01       	mov    $0x14000c0,%esi
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    7059:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1909
    705d:	48 c1 e7 04          	shl    $0x4,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    7061:	e8 00 00 00 00       	callq  7066 <cauchy_rs_decode+0x66>
			7062: R_X86_64_PC32	__kmalloc-0x4
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1912
    int i = 0;

    if (params.OriginalCount <= 0 || params.RecoveryCount <= 0 || params.BlockBytes <= 0) {
    7066:	85 db                	test   %ebx,%ebx
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    7068:	49 89 c4             	mov    %rax,%r12
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1912
    706b:	0f 9e c2             	setle  %dl
    706e:	45 85 f6             	test   %r14d,%r14d
    7071:	0f 9e c0             	setle  %al
    7074:	08 c2                	or     %al,%dl
    7076:	0f 85 17 01 00 00    	jne    7193 <cauchy_rs_decode+0x193>
    707c:	45 85 ff             	test   %r15d,%r15d
    707f:	0f 8e 0e 01 00 00    	jle    7193 <cauchy_rs_decode+0x193>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1915
        return -1;
    }
    if (params.OriginalCount + params.RecoveryCount > 256) {
    7085:	41 8d 04 1e          	lea    (%r14,%rbx,1),%eax
    7089:	3d 00 01 00 00       	cmp    $0x100,%eax
    708e:	0f 8f 08 01 00 00    	jg     719c <cauchy_rs_decode+0x19c>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1918
        return -2;
    }
    if (!blocks) {
    7094:	4d 85 e4             	test   %r12,%r12
    7097:	0f 84 11 01 00 00    	je     71ae <cauchy_rs_decode+0x1ae>
    709d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    70a1:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
    70a5:	4d 89 e7             	mov    %r12,%r15
    70a8:	44 8b 4d b8          	mov    -0x48(%rbp),%r9d
    70ac:	4c 89 e2             	mov    %r12,%rdx
    70af:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1923 (discriminator 3)
        return -3;
    }

    for(i = 0; i < params.OriginalCount; ++i){
        blocks[i].Block = dataBlocks[i];
    70b1:	49 8b 74 c5 00       	mov    0x0(%r13,%rax,8),%rsi
cauchy_get_original_block_index():
/home/austen/programming/dm-afs/include/lib/cauchy_rs.h:240 (discriminator 3)
    return (unsigned char)(params.OriginalCount + recoveryBlockIndex);
}
static inline unsigned char cauchy_get_original_block_index(cauchy_encoder_params params, int originalBlockIndex)
{
    //assert(originalBlockIndex >= 0 && originalBlockIndex < params.OriginalCount);
    return (unsigned char)(originalBlockIndex);
    70b6:	88 42 08             	mov    %al,0x8(%rdx)
    70b9:	48 83 c0 01          	add    $0x1,%rax
    70bd:	48 83 c2 10          	add    $0x10,%rdx
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1923 (discriminator 3)
    70c1:	48 89 72 f0          	mov    %rsi,-0x10(%rdx)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1922 (discriminator 3)
    for(i = 0; i < params.OriginalCount; ++i){
    70c5:	39 c3                	cmp    %eax,%ebx
    70c7:	7f e8                	jg     70b1 <cauchy_rs_decode+0xb1>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1927
        blocks[i].Index = cauchy_get_original_block_index(params, i);
    }

    for(i = 0; i < num_erasures; i++){
    70c9:	45 84 c9             	test   %r9b,%r9b
    70cc:	74 34                	je     7102 <cauchy_rs_decode+0x102>
    70ce:	45 0f b6 c9          	movzbl %r9b,%r9d
    70d2:	89 de                	mov    %ebx,%esi
    70d4:	31 d2                	xor    %edx,%edx
    70d6:	41 8d 79 ff          	lea    -0x1(%r9),%edi
    70da:	48 83 c7 01          	add    $0x1,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1928 (discriminator 3)
        blocks[erasures[i]].Block = parityBlocks[i];
    70de:	41 0f b6 04 10       	movzbl (%r8,%rdx,1),%eax
    70e3:	4c 8b 0c d1          	mov    (%rcx,%rdx,8),%r9
    70e7:	48 c1 e0 04          	shl    $0x4,%rax
    70eb:	4c 01 e0             	add    %r12,%rax
    70ee:	4c 89 08             	mov    %r9,(%rax)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1929 (discriminator 3)
        blocks[erasures[i]].Index = cauchy_get_recovery_block_index(params, i);
    70f1:	44 8d 0c 16          	lea    (%rsi,%rdx,1),%r9d
    70f5:	48 83 c2 01          	add    $0x1,%rdx
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1927 (discriminator 3)
    for(i = 0; i < num_erasures; i++){
    70f9:	48 39 d7             	cmp    %rdx,%rdi
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1929 (discriminator 3)
        blocks[erasures[i]].Index = cauchy_get_recovery_block_index(params, i);
    70fc:	44 88 48 08          	mov    %r9b,0x8(%rax)
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1927 (discriminator 3)
    for(i = 0; i < num_erasures; i++){
    7100:	75 dc                	jne    70de <cauchy_rs_decode+0xde>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1932
    }

    if (Initialize(state, params, blocks)) {
    7102:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    7106:	8b 55 c8             	mov    -0x38(%rbp),%edx
    7109:	4c 89 e1             	mov    %r12,%rcx
    710c:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    7110:	e8 00 00 00 00       	callq  7115 <cauchy_rs_decode+0x115>
			7111: R_X86_64_PC32	Initialize-0x4
    7115:	85 c0                	test   %eax,%eax
    7117:	89 45 a8             	mov    %eax,-0x58(%rbp)
    711a:	0f 85 85 00 00 00    	jne    71a5 <cauchy_rs_decode+0x1a5>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1937
        return -5;
    }

    // If nothing is erased,
    if (state->RecoveryCount <= 0) {
    7120:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    7124:	8b 90 10 08 00 00    	mov    0x810(%rax),%edx
    712a:	85 d2                	test   %edx,%edx
    712c:	7e 49                	jle    7177 <cauchy_rs_decode+0x177>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1942
        return 0;
    }

    // If m=1,
    if (params.RecoveryCount == 1) {
    712e:	41 83 fe 01          	cmp    $0x1,%r14d
    7132:	74 55                	je     7189 <cauchy_rs_decode+0x189>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1948
        DecodeM1(state);
        return 0;
    }

    // Decode for m>1
    Decode(state);
    7134:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    7138:	45 31 f6             	xor    %r14d,%r14d
    713b:	e8 00 00 00 00       	callq  7140 <cauchy_rs_decode+0x140>
			713c: R_X86_64_PC32	Decode-0x4
    7140:	48 63 45 9c          	movslq -0x64(%rbp),%rax
    7144:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344 (discriminator 3)
    7148:	49 8b 37             	mov    (%r15),%rsi
    714b:	4b 8b 7c f5 00       	mov    0x0(%r13,%r14,8),%rdi
    7150:	49 83 c6 01          	add    $0x1,%r14
    7154:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    7158:	49 83 c7 10          	add    $0x10,%r15
    715c:	e8 00 00 00 00       	callq  7161 <cauchy_rs_decode+0x161>
			715d: R_X86_64_PC32	memcpy-0x4
cauchy_rs_decode():
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1949 (discriminator 3)
    for(i = 0; i < params.OriginalCount; ++i){
    7161:	44 39 f3             	cmp    %r14d,%ebx
    7164:	7f e2                	jg     7148 <cauchy_rs_decode+0x148>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1954
    //    print_hex_dump(KERN_DEBUG, "decoded: ", DUMP_PREFIX_OFFSET, 20, 1, (void*)blocks[i].Block, 16, true);
        memcpy(dataBlocks[i], blocks[i].Block, params.BlockBytes);
    }
    
    kfree(state);
    7166:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    716a:	e8 00 00 00 00       	callq  716f <cauchy_rs_decode+0x16f>
			716b: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1955
    kfree(blocks);
    716f:	4c 89 e7             	mov    %r12,%rdi
    7172:	e8 00 00 00 00       	callq  7177 <cauchy_rs_decode+0x177>
			7173: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1957
    return 0;
}
    7177:	8b 45 a8             	mov    -0x58(%rbp),%eax
    717a:	48 83 c4 48          	add    $0x48,%rsp
    717e:	5b                   	pop    %rbx
    717f:	41 5c                	pop    %r12
    7181:	41 5d                	pop    %r13
    7183:	41 5e                	pop    %r14
    7185:	41 5f                	pop    %r15
    7187:	5d                   	pop    %rbp
    7188:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1943
        DecodeM1(state);
    7189:	48 89 c7             	mov    %rax,%rdi
    718c:	e8 00 00 00 00       	callq  7191 <cauchy_rs_decode+0x191>
			718d: R_X86_64_PC32	DecodeM1-0x4
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1944
        return 0;
    7191:	eb e4                	jmp    7177 <cauchy_rs_decode+0x177>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1913
        return -1;
    7193:	c7 45 a8 ff ff ff ff 	movl   $0xffffffff,-0x58(%rbp)
    719a:	eb db                	jmp    7177 <cauchy_rs_decode+0x177>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1916
        return -2;
    719c:	c7 45 a8 fe ff ff ff 	movl   $0xfffffffe,-0x58(%rbp)
    71a3:	eb d2                	jmp    7177 <cauchy_rs_decode+0x177>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1933
        return -5;
    71a5:	c7 45 a8 fb ff ff ff 	movl   $0xfffffffb,-0x58(%rbp)
    71ac:	eb c9                	jmp    7177 <cauchy_rs_decode+0x177>
/home/austen/programming/dm-afs/src/lib/cauchy_rs.c:1919
        return -3;
    71ae:	c7 45 a8 fd ff ff ff 	movl   $0xfffffffd,-0x58(%rbp)
    71b5:	eb c0                	jmp    7177 <cauchy_rs_decode+0x177>
    71b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    71be:	00 00 

00000000000071c0 <_gfshare_ctx_init_core>:
_gfshare_ctx_init_core():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:230

static gfshare_ctx * _gfshare_ctx_init_core(const uint8_t *sharenrs, 
		                            uint32_t sharecount, 
					    uint32_t threshold, 
					    size_t maxsize ) 
{
    71c0:	e8 00 00 00 00       	callq  71c5 <_gfshare_ctx_init_core+0x5>
			71c1: R_X86_64_PC32	__fentry__-0x4
    71c5:	55                   	push   %rbp
    71c6:	48 89 e5             	mov    %rsp,%rbp
    71c9:	41 57                	push   %r15
    71cb:	41 56                	push   %r14
    71cd:	41 55                	push   %r13
    71cf:	41 54                	push   %r12
    71d1:	53                   	push   %rbx
    71d2:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:234
  gfshare_ctx *ctx;

  /* Size must be nonzero, and 1 <= threshold <= sharecount */
  if( maxsize < 1 || threshold < 1 || threshold > sharecount ) {
    71d6:	85 d2                	test   %edx,%edx
    71d8:	41 0f 94 c0          	sete   %r8b
    71dc:	39 f2                	cmp    %esi,%edx
    71de:	0f 97 c0             	seta   %al
    71e1:	41 08 c0             	or     %al,%r8b
    71e4:	0f 85 a1 00 00 00    	jne    728b <_gfshare_ctx_init_core+0xcb>
    71ea:	48 85 c9             	test   %rcx,%rcx
    71ed:	0f 84 98 00 00 00    	je     728b <_gfshare_ctx_init_core+0xcb>
    71f3:	49 89 fe             	mov    %rdi,%r14
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    71f6:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 71fd <_gfshare_ctx_init_core+0x3d>
			71f9: R_X86_64_PC32	kmalloc_caches+0x2c
    71fd:	41 89 d5             	mov    %edx,%r13d
    7200:	89 f3                	mov    %esi,%ebx
    7202:	ba 28 00 00 00       	mov    $0x28,%edx
    7207:	be c0 00 40 01       	mov    $0x14000c0,%esi
    720c:	49 89 cc             	mov    %rcx,%r12
    720f:	e8 00 00 00 00       	callq  7214 <_gfshare_ctx_init_core+0x54>
			7210: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
_gfshare_ctx_init_core():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:239
    return NULL;
  }
  
  ctx = kmalloc( sizeof(struct _gfshare_ctx), GFP_KERNEL);
  if( ctx == NULL )
    7214:	48 85 c0             	test   %rax,%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    7217:	49 89 c7             	mov    %rax,%r15
_gfshare_ctx_init_core():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:239
    721a:	74 6f                	je     728b <_gfshare_ctx_init_core+0xcb>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:242
    return NULL; /* errno should still be set from XMALLOC() */
  
  ctx->sharecount = sharecount;
    721c:	89 18                	mov    %ebx,(%rax)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:243
  ctx->threshold = threshold;
    721e:	44 89 68 04          	mov    %r13d,0x4(%rax)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    7222:	be c0 00 40 01       	mov    $0x14000c0,%esi
_gfshare_ctx_init_core():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:244
  ctx->maxsize = maxsize;
    7227:	44 89 60 08          	mov    %r12d,0x8(%rax)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:245
  ctx->size = maxsize;
    722b:	44 89 60 0c          	mov    %r12d,0xc(%rax)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    722f:	48 89 df             	mov    %rbx,%rdi
    7232:	e8 00 00 00 00       	callq  7237 <_gfshare_ctx_init_core+0x77>
			7233: R_X86_64_PC32	__kmalloc-0x4
_gfshare_ctx_init_core():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:248
  ctx->sharenrs = kmalloc( sharecount, GFP_KERNEL);
  
  if( ctx->sharenrs == NULL ) {
    7237:	48 85 c0             	test   %rax,%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:246
  ctx->sharenrs = kmalloc( sharecount, GFP_KERNEL);
    723a:	49 89 47 10          	mov    %rax,0x10(%r15)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:248
  if( ctx->sharenrs == NULL ) {
    723e:	74 43                	je     7283 <_gfshare_ctx_init_core+0xc3>
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    7240:	48 89 da             	mov    %rbx,%rdx
    7243:	4c 89 f6             	mov    %r14,%rsi
    7246:	48 89 c7             	mov    %rax,%rdi
_gfshare_ctx_init_core():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:254
    kfree( ctx );
    return NULL;
  }
  
  memcpy( ctx->sharenrs, sharenrs, sharecount );
  ctx->buffer = kmalloc( sharecount * maxsize, GFP_KERNEL);
    7249:	49 0f af dc          	imul   %r12,%rbx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    724d:	e8 00 00 00 00       	callq  7252 <_gfshare_ctx_init_core+0x92>
			724e: R_X86_64_PC32	memcpy-0x4
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    7252:	be c0 00 40 01       	mov    $0x14000c0,%esi
_gfshare_ctx_init_core():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:254
    7257:	48 89 df             	mov    %rbx,%rdi
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:504
    725a:	e8 00 00 00 00       	callq  725f <_gfshare_ctx_init_core+0x9f>
			725b: R_X86_64_PC32	__kmalloc-0x4
_gfshare_ctx_init_core():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:256
  
  if( ctx->buffer == NULL ) {
    725f:	48 85 c0             	test   %rax,%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:254
  ctx->buffer = kmalloc( sharecount * maxsize, GFP_KERNEL);
    7262:	49 89 47 18          	mov    %rax,0x18(%r15)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:256
  if( ctx->buffer == NULL ) {
    7266:	74 12                	je     727a <_gfshare_ctx_init_core+0xba>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:263
    kfree( ctx );
    return NULL;
  }
  
  return ctx;
}
    7268:	48 83 c4 08          	add    $0x8,%rsp
    726c:	4c 89 f8             	mov    %r15,%rax
    726f:	5b                   	pop    %rbx
    7270:	41 5c                	pop    %r12
    7272:	41 5d                	pop    %r13
    7274:	41 5e                	pop    %r14
    7276:	41 5f                	pop    %r15
    7278:	5d                   	pop    %rbp
    7279:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/libgfshare.c:257
    kfree( ctx->sharenrs );
    727a:	49 8b 7f 10          	mov    0x10(%r15),%rdi
    727e:	e8 00 00 00 00       	callq  7283 <_gfshare_ctx_init_core+0xc3>
			727f: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:258
    kfree( ctx );
    7283:	4c 89 ff             	mov    %r15,%rdi
    7286:	e8 00 00 00 00       	callq  728b <_gfshare_ctx_init_core+0xcb>
			7287: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:259
    return NULL;
    728b:	45 31 ff             	xor    %r15d,%r15d
    728e:	eb d8                	jmp    7268 <_gfshare_ctx_init_core+0xa8>

0000000000007290 <speck_encrypt>:
speck_encrypt():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:164
{
    7290:	e8 00 00 00 00       	callq  7295 <speck_encrypt+0x5>
			7291: R_X86_64_PC32	__fentry__-0x4
    7295:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:165
    uint64_t y = pt[0], x = pt[1], b = K[0], a = K[1];
    7296:	48 8b 46 08          	mov    0x8(%rsi),%rax
    729a:	4c 8b 06             	mov    (%rsi),%r8
    729d:	48 8b 0a             	mov    (%rdx),%rcx
    72a0:	48 8b 52 08          	mov    0x8(%rdx),%rdx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:164
{
    72a4:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:167
    R(x, y, b);
    72a7:	48 c1 c8 08          	ror    $0x8,%rax
    72ab:	4c 01 c0             	add    %r8,%rax
    72ae:	4c 89 c6             	mov    %r8,%rsi
    72b1:	45 31 c0             	xor    %r8d,%r8d
    72b4:	48 31 c8             	xor    %rcx,%rax
    72b7:	48 c1 c6 03          	rol    $0x3,%rsi
    72bb:	48 31 c6             	xor    %rax,%rsi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:169 (discriminator 3)
        R(a, b, i);
    72be:	48 c1 ca 08          	ror    $0x8,%rdx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:170 (discriminator 3)
        R(x, y, b);
    72c2:	48 c1 c8 08          	ror    $0x8,%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:169 (discriminator 3)
        R(a, b, i);
    72c6:	48 01 ca             	add    %rcx,%rdx
    72c9:	48 c1 c1 03          	rol    $0x3,%rcx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:170 (discriminator 3)
        R(x, y, b);
    72cd:	48 01 f0             	add    %rsi,%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:169 (discriminator 3)
        R(a, b, i);
    72d0:	4c 31 c2             	xor    %r8,%rdx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:170 (discriminator 3)
        R(x, y, b);
    72d3:	48 c1 c6 03          	rol    $0x3,%rsi
    72d7:	49 83 c0 01          	add    $0x1,%r8
/home/austen/programming/dm-afs/src/lib/libgfshare.c:169 (discriminator 3)
        R(a, b, i);
    72db:	48 31 d1             	xor    %rdx,%rcx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:170 (discriminator 3)
        R(x, y, b);
    72de:	48 31 c8             	xor    %rcx,%rax
    72e1:	48 31 c6             	xor    %rax,%rsi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:168 (discriminator 3)
    for (i = 0; i < ROUNDS - 1; i++) {
    72e4:	49 83 f8 1f          	cmp    $0x1f,%r8
    72e8:	75 d4                	jne    72be <speck_encrypt+0x2e>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:173
    ct[0] = y;
    72ea:	48 89 37             	mov    %rsi,(%rdi)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:174
    ct[1] = x;
    72ed:	48 89 47 08          	mov    %rax,0x8(%rdi)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:175
}
    72f1:	5d                   	pop    %rbp
    72f2:	c3                   	retq   
    72f3:	0f 1f 00             	nopl   (%rax)
    72f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    72fd:	00 00 00 

0000000000007300 <generate_block_ctr>:
generate_block_ctr():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:185
void generate_block_ctr(size_t output_length, uint8_t *output_block, uint8_t *seed){
    7300:	e8 00 00 00 00       	callq  7305 <generate_block_ctr+0x5>
			7301: R_X86_64_PC32	__fentry__-0x4
    7305:	55                   	push   %rbp
    7306:	48 89 e5             	mov    %rsp,%rbp
    7309:	41 54                	push   %r12
    730b:	53                   	push   %rbx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:186
    uint32_t rounds = output_length/BLOCK_SIZE;
    730c:	49 89 fc             	mov    %rdi,%r12
/home/austen/programming/dm-afs/src/lib/libgfshare.c:185
void generate_block_ctr(size_t output_length, uint8_t *output_block, uint8_t *seed){
    730f:	48 89 f3             	mov    %rsi,%rbx
    7312:	48 83 ec 50          	sub    $0x50,%rsp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:186
    uint32_t rounds = output_length/BLOCK_SIZE;
    7316:	49 c1 ec 04          	shr    $0x4,%r12
/home/austen/programming/dm-afs/src/lib/libgfshare.c:185
void generate_block_ctr(size_t output_length, uint8_t *output_block, uint8_t *seed){
    731a:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    7321:	00 00 
    7323:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    7327:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:190
    if(output_length % BLOCK_SIZE != 0){
    7329:	40 f6 c7 0f          	test   $0xf,%dil
    732d:	75 73                	jne    73a2 <generate_block_ctr+0xa2>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:194
    key[0] = ((uint64_t *)seed)[0];
    732f:	48 8b 02             	mov    (%rdx),%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:200
    for(i = 0; i < rounds; i++){
    7332:	41 83 e4 ff          	and    $0xffffffff,%r12d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:197
    ctr[0] = 0;
    7336:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    733d:	00 
/home/austen/programming/dm-afs/src/lib/libgfshare.c:198
    ctr[1] = 0;
    733e:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    7345:	00 
/home/austen/programming/dm-afs/src/lib/libgfshare.c:194
    key[0] = ((uint64_t *)seed)[0];
    7346:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:195
    key[1] = ((uint64_t *)seed)[1];
    734a:	48 8b 42 08          	mov    0x8(%rdx),%rax
    734e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:200
    for(i = 0; i < rounds; i++){
    7352:	74 36                	je     738a <generate_block_ctr+0x8a>
    7354:	49 c1 e4 04          	shl    $0x4,%r12
    7358:	49 01 dc             	add    %rbx,%r12
/home/austen/programming/dm-afs/src/lib/libgfshare.c:201 (discriminator 3)
       speck_encrypt(output, ctr, key);
    735b:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
    735f:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
    7363:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
    7367:	48 83 c3 10          	add    $0x10,%rbx
    736b:	e8 00 00 00 00       	callq  7370 <generate_block_ctr+0x70>
			736c: R_X86_64_PC32	speck_encrypt-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:202 (discriminator 3)
       ((uint64_t *)output_block)[j + 1] = output[1];
    7370:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:204 (discriminator 3)
       ctr[0]++;
    7374:	48 83 45 b0 01       	addq   $0x1,-0x50(%rbp)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:202 (discriminator 3)
       ((uint64_t *)output_block)[j + 1] = output[1];
    7379:	48 89 43 f8          	mov    %rax,-0x8(%rbx)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:203 (discriminator 3)
       ((uint64_t *)output_block)[j + 0] = output[0];
    737d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    7381:	48 89 43 f0          	mov    %rax,-0x10(%rbx)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:200 (discriminator 3)
    for(i = 0; i < rounds; i++){
    7385:	4c 39 e3             	cmp    %r12,%rbx
    7388:	75 d1                	jne    735b <generate_block_ctr+0x5b>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:207
}
    738a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    738e:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    7395:	00 00 
    7397:	75 25                	jne    73be <generate_block_ctr+0xbe>
    7399:	48 83 c4 50          	add    $0x50,%rsp
    739d:	5b                   	pop    %rbx
    739e:	41 5c                	pop    %r12
    73a0:	5d                   	pop    %rbp
    73a1:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/libgfshare.c:191
        printk(KERN_INFO "Not aligned to 128 bit boundary %ld", output_length);
    73a2:	48 89 fe             	mov    %rdi,%rsi
    73a5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			73a8: R_X86_64_32S	.rodata.str1.8+0x1920
    73ac:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    73b0:	e8 00 00 00 00       	callq  73b5 <generate_block_ctr+0xb5>
			73b1: R_X86_64_PC32	printk-0x4
    73b5:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
    73b9:	e9 71 ff ff ff       	jmpq   732f <generate_block_ctr+0x2f>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:207
}
    73be:	e8 00 00 00 00       	callq  73c3 <generate_block_ctr+0xc3>
			73bf: R_X86_64_PC32	__stack_chk_fail-0x4
    73c3:	0f 1f 00             	nopl   (%rax)
    73c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    73cd:	00 00 00 

00000000000073d0 <_gfshare_fill_rand_using_speck>:
_gfshare_fill_rand_using_speck():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:215
static void _gfshare_fill_rand_using_speck(uint8_t* buffer, size_t count){
    73d0:	e8 00 00 00 00       	callq  73d5 <_gfshare_fill_rand_using_speck+0x5>
			73d1: R_X86_64_PC32	__fentry__-0x4
    73d5:	55                   	push   %rbp
    73d6:	48 89 e5             	mov    %rsp,%rbp
    73d9:	41 54                	push   %r12
    73db:	53                   	push   %rbx
    73dc:	49 89 fc             	mov    %rdi,%r12
    73df:	48 89 f3             	mov    %rsi,%rbx
get_seed_64():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:211
    get_random_bytes(random, 16);
    73e2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			73e5: R_X86_64_32S	.bss+0xa6940
    73e9:	be 10 00 00 00       	mov    $0x10,%esi
    73ee:	e8 00 00 00 00       	callq  73f3 <_gfshare_fill_rand_using_speck+0x23>
			73ef: R_X86_64_PC32	get_random_bytes-0x4
_gfshare_fill_rand_using_speck():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:217
    generate_block_ctr(count, buffer, key);
    73f3:	4c 89 e6             	mov    %r12,%rsi
    73f6:	48 89 df             	mov    %rbx,%rdi
    73f9:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
			73fc: R_X86_64_32S	.bss+0xa6940
    7400:	e8 00 00 00 00       	callq  7405 <_gfshare_fill_rand_using_speck+0x35>
			7401: R_X86_64_PC32	generate_block_ctr-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:218
}
    7405:	5b                   	pop    %rbx
    7406:	41 5c                	pop    %r12
    7408:	5d                   	pop    %rbp
    7409:	c3                   	retq   
    740a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000007410 <get_seed_64>:
get_seed_64():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:209
uint64_t * get_seed_64(void){
    7410:	e8 00 00 00 00       	callq  7415 <get_seed_64+0x5>
			7411: R_X86_64_PC32	__fentry__-0x4
    7415:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:211
    get_random_bytes(random, 16);
    7416:	be 10 00 00 00       	mov    $0x10,%esi
    741b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			741e: R_X86_64_32S	.bss+0xa6940
/home/austen/programming/dm-afs/src/lib/libgfshare.c:209
uint64_t * get_seed_64(void){
    7422:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:211
    get_random_bytes(random, 16);
    7425:	e8 00 00 00 00       	callq  742a <get_seed_64+0x1a>
			7426: R_X86_64_PC32	get_random_bytes-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:213
}
    742a:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
			742d: R_X86_64_32S	.bss+0xa6940
    7431:	5d                   	pop    %rbp
    7432:	c3                   	retq   
    7433:	0f 1f 00             	nopl   (%rax)
    7436:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    743d:	00 00 00 

0000000000007440 <gfshare_ctx_init_enc>:
gfshare_ctx_init_enc():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:270
/* Initialise a gfshare context for producing shares */
gfshare_ctx * gfshare_ctx_init_enc(const uint8_t* sharenrs,
                                   uint32_t sharecount,
                                   uint32_t threshold,
                                   size_t maxsize)
{
    7440:	e8 00 00 00 00       	callq  7445 <gfshare_ctx_init_enc+0x5>
			7441: R_X86_64_PC32	__fentry__-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:273
  int i;

  for (i = 0; i < sharecount; i++) {
    7445:	85 f6                	test   %esi,%esi
    7447:	74 1a                	je     7463 <gfshare_ctx_init_enc+0x23>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:274
    if (sharenrs[i] == 0) {
    7449:	80 3f 00             	cmpb   $0x0,(%rdi)
    744c:	74 20                	je     746e <gfshare_ctx_init_enc+0x2e>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:273
  for (i = 0; i < sharecount; i++) {
    744e:	31 c0                	xor    %eax,%eax
    7450:	eb 0a                	jmp    745c <gfshare_ctx_init_enc+0x1c>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:274
    if (sharenrs[i] == 0) {
    7452:	4c 63 c0             	movslq %eax,%r8
    7455:	42 80 3c 07 00       	cmpb   $0x0,(%rdi,%r8,1)
    745a:	74 12                	je     746e <gfshare_ctx_init_enc+0x2e>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:273 (discriminator 2)
  for (i = 0; i < sharecount; i++) {
    745c:	83 c0 01             	add    $0x1,%eax
    745f:	39 f0                	cmp    %esi,%eax
    7461:	75 ef                	jne    7452 <gfshare_ctx_init_enc+0x12>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:270
{
    7463:	55                   	push   %rbp
    7464:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:282
       * treat log(0) as 0, it ends up as a copy of x[i] = 1) */
      return NULL;
    }
  }

  return _gfshare_ctx_init_core( sharenrs, sharecount, threshold, maxsize );
    7467:	e8 54 fd ff ff       	callq  71c0 <_gfshare_ctx_init_core>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:283
}
    746c:	5d                   	pop    %rbp
    746d:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/libgfshare.c:278
      return NULL;
    746e:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:283
}
    7470:	c3                   	retq   
    7471:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    7476:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    747d:	00 00 00 

0000000000007480 <gfshare_ctx_init_dec>:
gfshare_ctx_init_dec():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:290
/* Initialise a gfshare context for recombining shares */
gfshare_ctx* gfshare_ctx_init_dec(const uint8_t* sharenrs,
                                  uint32_t sharecount,
                                  uint32_t threshold,
                                  size_t maxsize)
{
    7480:	e8 00 00 00 00       	callq  7485 <gfshare_ctx_init_dec+0x5>
			7481: R_X86_64_PC32	__fentry__-0x4
    7485:	55                   	push   %rbp
    7486:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:291
  return _gfshare_ctx_init_core( sharenrs, sharecount, threshold, maxsize );
    7489:	e8 32 fd ff ff       	callq  71c0 <_gfshare_ctx_init_core>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:292
}
    748e:	5d                   	pop    %rbp
    748f:	c3                   	retq   

0000000000007490 <gfshare_ctx_setsize>:
gfshare_ctx_setsize():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:295

/* Set the current processing size */
int gfshare_ctx_setsize(gfshare_ctx* ctx, size_t size) {
    7490:	e8 00 00 00 00       	callq  7495 <gfshare_ctx_setsize+0x5>
			7491: R_X86_64_PC32	__fentry__-0x4
    7495:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:296
  if(size < 1 || size >= ctx->maxsize) {
    7496:	48 85 f6             	test   %rsi,%rsi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:297
    return 1;
    7499:	b8 01 00 00 00       	mov    $0x1,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:295
int gfshare_ctx_setsize(gfshare_ctx* ctx, size_t size) {
    749e:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:296
  if(size < 1 || size >= ctx->maxsize) {
    74a1:	74 0d                	je     74b0 <gfshare_ctx_setsize+0x20>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:296 (discriminator 1)
    74a3:	8b 57 08             	mov    0x8(%rdi),%edx
    74a6:	48 39 f2             	cmp    %rsi,%rdx
    74a9:	76 05                	jbe    74b0 <gfshare_ctx_setsize+0x20>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:299
  }
  ctx->size = size;
    74ab:	89 77 0c             	mov    %esi,0xc(%rdi)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:300
  return 0;
    74ae:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:301
}
    74b0:	5d                   	pop    %rbp
    74b1:	c3                   	retq   
    74b2:	0f 1f 40 00          	nopl   0x0(%rax)
    74b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    74bd:	00 00 00 

00000000000074c0 <gfshare_ctx_free>:
gfshare_ctx_free():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:304

/* Free a share context's memory. */
void gfshare_ctx_free(gfshare_ctx* ctx) {
    74c0:	e8 00 00 00 00       	callq  74c5 <gfshare_ctx_free+0x5>
			74c1: R_X86_64_PC32	__fentry__-0x4
    74c5:	55                   	push   %rbp
    74c6:	48 89 e5             	mov    %rsp,%rbp
    74c9:	53                   	push   %rbx
    74ca:	48 89 fb             	mov    %rdi,%rbx
    74cd:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:305
  gfshare_fill_rand( ctx->buffer, ctx->sharecount * ctx->maxsize );
    74d1:	8b 37                	mov    (%rdi),%esi
    74d3:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 74da <gfshare_ctx_free+0x1a>
			74d6: R_X86_64_PC32	gfshare_fill_rand-0x4
    74da:	0f af 77 08          	imul   0x8(%rdi),%esi
    74de:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
    74e2:	e8 00 00 00 00       	callq  74e7 <gfshare_ctx_free+0x27>
			74e3: R_X86_64_PC32	__x86_indirect_thunk_rax-0x4
_gfshare_fill_rand_using_random_bytes():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:144
    get_random_bytes(buffer, count);
    74e7:	8b 33                	mov    (%rbx),%esi
    74e9:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    74ed:	e8 00 00 00 00       	callq  74f2 <gfshare_ctx_free+0x32>
			74ee: R_X86_64_PC32	get_random_bytes-0x4
gfshare_ctx_free():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:307
  _gfshare_fill_rand_using_random_bytes( ctx->sharenrs, ctx->sharecount );
  kfree( ctx->sharenrs );
    74f2:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    74f6:	e8 00 00 00 00       	callq  74fb <gfshare_ctx_free+0x3b>
			74f7: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:308
  kfree( ctx->buffer );
    74fb:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
    74ff:	e8 00 00 00 00       	callq  7504 <gfshare_ctx_free+0x44>
			7500: R_X86_64_PC32	kfree-0x4
_gfshare_fill_rand_using_random_bytes():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:144
    get_random_bytes(buffer, count);
    7504:	48 89 df             	mov    %rbx,%rdi
    7507:	be 28 00 00 00       	mov    $0x28,%esi
    750c:	e8 00 00 00 00       	callq  7511 <gfshare_ctx_free+0x51>
			750d: R_X86_64_PC32	get_random_bytes-0x4
gfshare_ctx_free():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:310
  _gfshare_fill_rand_using_random_bytes( (uint8_t*)ctx, sizeof(struct _gfshare_ctx) );
  kfree( ctx );
    7511:	48 89 df             	mov    %rbx,%rdi
    7514:	e8 00 00 00 00       	callq  7519 <gfshare_ctx_free+0x59>
			7515: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:311
}
    7519:	48 83 c4 08          	add    $0x8,%rsp
    751d:	5b                   	pop    %rbx
    751e:	5d                   	pop    %rbp
    751f:	c3                   	retq   

0000000000007520 <gfshare_ctx_enc_setsecret>:
gfshare_ctx_enc_setsecret():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:315

/* --------------------------------------------------------[ Splitting ]---- */
/* Provide a secret to the encoder. (this re-scrambles the coefficients) */
void gfshare_ctx_enc_setsecret( gfshare_ctx* ctx, const uint8_t* secret) {
    7520:	e8 00 00 00 00       	callq  7525 <gfshare_ctx_enc_setsecret+0x5>
			7521: R_X86_64_PC32	__fentry__-0x4
    7525:	55                   	push   %rbp
    7526:	48 89 e5             	mov    %rsp,%rbp
    7529:	53                   	push   %rbx
    752a:	48 89 fb             	mov    %rdi,%rbx
    752d:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:316
  memcpy(ctx->buffer + ((ctx->threshold-1) * ctx->maxsize), secret, ctx->size);
    7531:	8b 47 04             	mov    0x4(%rdi),%eax
    7534:	8b 53 0c             	mov    0xc(%rbx),%edx
    7537:	8d 78 ff             	lea    -0x1(%rax),%edi
    753a:	0f af 7b 08          	imul   0x8(%rbx),%edi
    753e:	48 03 7b 18          	add    0x18(%rbx),%rdi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    7542:	e8 00 00 00 00       	callq  7547 <gfshare_ctx_enc_setsecret+0x27>
			7543: R_X86_64_PC32	memcpy-0x4
gfshare_ctx_enc_setsecret():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:317
  gfshare_fill_rand(ctx->buffer, (ctx->threshold-1) * ctx->maxsize);
    7547:	8b 43 04             	mov    0x4(%rbx),%eax
    754a:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
    754e:	8d 70 ff             	lea    -0x1(%rax),%esi
    7551:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 7558 <gfshare_ctx_enc_setsecret+0x38>
			7554: R_X86_64_PC32	gfshare_fill_rand-0x4
    7558:	0f af 73 08          	imul   0x8(%rbx),%esi
    755c:	e8 00 00 00 00       	callq  7561 <gfshare_ctx_enc_setsecret+0x41>
			755d: R_X86_64_PC32	__x86_indirect_thunk_rax-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:318
}
    7561:	48 83 c4 08          	add    $0x8,%rsp
    7565:	5b                   	pop    %rbx
    7566:	5d                   	pop    %rbp
    7567:	c3                   	retq   
    7568:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    756f:	00 

0000000000007570 <gfshare_ctx_enc_getshares>:
gfshare_ctx_enc_getshares():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:327
 * 'sharenr' is the index into the 'sharenrs' array of the share you want.
 */
int gfshare_ctx_enc_getshares(const gfshare_ctx* ctx,
		              const uint8_t* secret,
                              uint8_t** shares)
{
    7570:	e8 00 00 00 00       	callq  7575 <gfshare_ctx_enc_getshares+0x5>
			7571: R_X86_64_PC32	__fentry__-0x4
    7575:	55                   	push   %rbp
    7576:	48 89 e5             	mov    %rsp,%rbp
    7579:	41 57                	push   %r15
    757b:	41 56                	push   %r14
    757d:	41 55                	push   %r13
    757f:	41 54                	push   %r12
    7581:	49 89 fc             	mov    %rdi,%r12
    7584:	53                   	push   %rbx
    7585:	48 83 ec 18          	sub    $0x18,%rsp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:332
  uint32_t pos, coefficient;
  uint8_t *share_ptr;
  int i;

  memcpy(ctx->buffer + ((ctx->threshold-1) * ctx->maxsize), secret, ctx->size);
    7589:	8b 47 04             	mov    0x4(%rdi),%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:327
{
    758c:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:332
  memcpy(ctx->buffer + ((ctx->threshold-1) * ctx->maxsize), secret, ctx->size);
    7590:	41 8b 54 24 0c       	mov    0xc(%r12),%edx
    7595:	8d 78 ff             	lea    -0x1(%rax),%edi
    7598:	41 0f af 7c 24 08    	imul   0x8(%r12),%edi
    759e:	49 03 7c 24 18       	add    0x18(%r12),%rdi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    75a3:	e8 00 00 00 00       	callq  75a8 <gfshare_ctx_enc_getshares+0x38>
			75a4: R_X86_64_PC32	memcpy-0x4
gfshare_ctx_enc_getshares():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:333
  gfshare_fill_rand(ctx->buffer, (ctx->threshold-1) * ctx->maxsize);
    75a8:	41 8b 44 24 04       	mov    0x4(%r12),%eax
    75ad:	49 8b 7c 24 18       	mov    0x18(%r12),%rdi
    75b2:	8d 70 ff             	lea    -0x1(%rax),%esi
    75b5:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 75bc <gfshare_ctx_enc_getshares+0x4c>
			75b8: R_X86_64_PC32	gfshare_fill_rand-0x4
    75bc:	41 0f af 74 24 08    	imul   0x8(%r12),%esi
    75c2:	e8 00 00 00 00       	callq  75c7 <gfshare_ctx_enc_getshares+0x57>
			75c3: R_X86_64_PC32	__x86_indirect_thunk_rax-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:335

  for(i = 0; i < ctx->sharecount; i++) {
    75c7:	41 8b 14 24          	mov    (%r12),%edx
    75cb:	85 d2                	test   %edx,%edx
    75cd:	0f 84 a8 00 00 00    	je     767b <gfshare_ctx_enc_getshares+0x10b>
    75d3:	31 db                	xor    %ebx,%ebx
    75d5:	49 c7 c5 00 00 00 00 	mov    $0x0,%r13
			75d8: R_X86_64_32S	.rodata+0x24e0
/home/austen/programming/dm-afs/src/lib/libgfshare.c:336
    uint32_t ilog = logs[ctx->sharenrs[i]];
    75dc:	49 8b 54 24 10       	mov    0x10(%r12),%rdx
    75e1:	48 63 c3             	movslq %ebx,%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:339
    uint8_t *coefficient_ptr = ctx->buffer;

    memcpy(shares[i], coefficient_ptr++, ctx->size);
    75e4:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    75e8:	49 8b 74 24 18       	mov    0x18(%r12),%rsi
gfshare_ctx_enc_getshares():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:336
    uint32_t ilog = logs[ctx->sharenrs[i]];
    75ed:	0f b6 14 02          	movzbl (%rdx,%rax,1),%edx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:339
    memcpy(shares[i], coefficient_ptr++, ctx->size);
    75f1:	4c 8d 3c c1          	lea    (%rcx,%rax,8),%r15
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    75f5:	49 8b 3f             	mov    (%r15),%rdi
gfshare_ctx_enc_getshares():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:336
    uint32_t ilog = logs[ctx->sharenrs[i]];
    75f8:	45 0f b6 74 15 00    	movzbl 0x0(%r13,%rdx,1),%r14d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:339
    memcpy(shares[i], coefficient_ptr++, ctx->size);
    75fe:	41 8b 54 24 0c       	mov    0xc(%r12),%edx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    7603:	e8 00 00 00 00       	callq  7608 <gfshare_ctx_enc_getshares+0x98>
			7604: R_X86_64_PC32	memcpy-0x4
gfshare_ctx_enc_getshares():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:342
    coefficient_ptr += ctx->size - 1;

    for(coefficient = 1; coefficient < ctx->threshold; ++coefficient) {
    7608:	41 83 7c 24 04 01    	cmpl   $0x1,0x4(%r12)
    760e:	76 5e                	jbe    766e <gfshare_ctx_enc_getshares+0xfe>
    7610:	41 b8 01 00 00 00    	mov    $0x1,%r8d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:344
      share_ptr = shares[i];
      coefficient_ptr = ctx->buffer + coefficient * ctx->maxsize;
    7616:	44 89 c7             	mov    %r8d,%edi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:345
      for(pos = 0; pos < ctx->size; ++pos) {
    7619:	41 8b 44 24 0c       	mov    0xc(%r12),%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:343
      share_ptr = shares[i];
    761e:	49 8b 17             	mov    (%r15),%rdx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:344
      coefficient_ptr = ctx->buffer + coefficient * ctx->maxsize;
    7621:	41 0f af 7c 24 08    	imul   0x8(%r12),%edi
    7627:	49 03 7c 24 18       	add    0x18(%r12),%rdi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:345
      for(pos = 0; pos < ctx->size; ++pos) {
    762c:	85 c0                	test   %eax,%eax
    762e:	74 33                	je     7663 <gfshare_ctx_enc_getshares+0xf3>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:344
      coefficient_ptr = ctx->buffer + coefficient * ctx->maxsize;
    7630:	48 89 fe             	mov    %rdi,%rsi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:346
        uint8_t share_byte = *share_ptr;
    7633:	0f b6 02             	movzbl (%rdx),%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:347
        if(share_byte) {
    7636:	84 c0                	test   %al,%al
    7638:	74 10                	je     764a <gfshare_ctx_enc_getshares+0xda>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:348
          share_byte = exps[ilog + logs[share_byte]];
    763a:	41 0f b6 44 05 00    	movzbl 0x0(%r13,%rax,1),%eax
    7640:	44 01 f0             	add    %r14d,%eax
    7643:	0f b6 80 00 00 00 00 	movzbl 0x0(%rax),%eax
			7646: R_X86_64_32S	.rodata+0x22e0
/home/austen/programming/dm-afs/src/lib/libgfshare.c:350 (discriminator 2)
        }
        *share_ptr++ = share_byte ^ *coefficient_ptr++;
    764a:	48 83 c6 01          	add    $0x1,%rsi
    764e:	32 46 ff             	xor    -0x1(%rsi),%al
    7651:	48 83 c2 01          	add    $0x1,%rdx
    7655:	88 42 ff             	mov    %al,-0x1(%rdx)
/home/austen/programming/dm-afs/src/lib/libgfshare.c:345 (discriminator 2)
      for(pos = 0; pos < ctx->size; ++pos) {
    7658:	89 f0                	mov    %esi,%eax
    765a:	29 f8                	sub    %edi,%eax
    765c:	41 39 44 24 0c       	cmp    %eax,0xc(%r12)
    7661:	77 d0                	ja     7633 <gfshare_ctx_enc_getshares+0xc3>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:342
    for(coefficient = 1; coefficient < ctx->threshold; ++coefficient) {
    7663:	41 83 c0 01          	add    $0x1,%r8d
    7667:	45 39 44 24 04       	cmp    %r8d,0x4(%r12)
    766c:	77 a8                	ja     7616 <gfshare_ctx_enc_getshares+0xa6>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:335
  for(i = 0; i < ctx->sharecount; i++) {
    766e:	83 c3 01             	add    $0x1,%ebx
    7671:	41 39 1c 24          	cmp    %ebx,(%r12)
    7675:	0f 87 61 ff ff ff    	ja     75dc <gfshare_ctx_enc_getshares+0x6c>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:355
      }
    }
  }
  return 0;
}
    767b:	48 83 c4 18          	add    $0x18,%rsp
    767f:	31 c0                	xor    %eax,%eax
    7681:	5b                   	pop    %rbx
    7682:	41 5c                	pop    %r12
    7684:	41 5d                	pop    %r13
    7686:	41 5e                	pop    %r14
    7688:	41 5f                	pop    %r15
    768a:	5d                   	pop    %rbp
    768b:	c3                   	retq   
    768c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007690 <gfshare_ctx_dec_newshares>:
gfshare_ctx_dec_newshares():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:360

/* ----------------------------------------------------[ Recombination ]---- */

/* Inform a recombination context of a change in share indexes */
void gfshare_ctx_dec_newshares( gfshare_ctx* ctx, const uint8_t* sharenrs) {
    7690:	e8 00 00 00 00       	callq  7695 <gfshare_ctx_dec_newshares+0x5>
			7691: R_X86_64_PC32	__fentry__-0x4
    7695:	48 89 f8             	mov    %rdi,%rax
    7698:	55                   	push   %rbp
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    7699:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
gfshare_ctx_dec_newshares():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:361
  memcpy(ctx->sharenrs, sharenrs, ctx->sharecount);
    769d:	8b 10                	mov    (%rax),%edx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:360
void gfshare_ctx_dec_newshares( gfshare_ctx* ctx, const uint8_t* sharenrs) {
    769f:	48 89 e5             	mov    %rsp,%rbp
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    76a2:	e8 00 00 00 00       	callq  76a7 <gfshare_ctx_dec_newshares+0x17>
			76a3: R_X86_64_PC32	memcpy-0x4
gfshare_ctx_dec_newshares():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:362
}
    76a7:	5d                   	pop    %rbp
    76a8:	c3                   	retq   
    76a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000076b0 <gfshare_ctx_dec_giveshare>:
gfshare_ctx_dec_giveshare():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:367

/* Provide a share context with one of the shares.
 * The 'sharenr' is the index into the 'sharenrs' array
 */
int gfshare_ctx_dec_giveshare(gfshare_ctx* ctx, uint8_t sharenr, const uint8_t* share) {
    76b0:	e8 00 00 00 00       	callq  76b5 <gfshare_ctx_dec_giveshare+0x5>
			76b1: R_X86_64_PC32	__fentry__-0x4
/home/austen/programming/dm-afs/src/lib/libgfshare.c:368
  if(sharenr >= ctx->sharecount) {
    76b5:	40 0f b6 ce          	movzbl %sil,%ecx
    76b9:	3b 0f                	cmp    (%rdi),%ecx
    76bb:	73 21                	jae    76de <gfshare_ctx_dec_giveshare+0x2e>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:367
int gfshare_ctx_dec_giveshare(gfshare_ctx* ctx, uint8_t sharenr, const uint8_t* share) {
    76bd:	55                   	push   %rbp
    76be:	48 89 f8             	mov    %rdi,%rax
    76c1:	48 89 d6             	mov    %rdx,%rsi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:371
    return 1;
  }
  memcpy(ctx->buffer + (sharenr * ctx->maxsize), share, ctx->size);
    76c4:	0f af 4f 08          	imul   0x8(%rdi),%ecx
    76c8:	8b 50 0c             	mov    0xc(%rax),%edx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:367
int gfshare_ctx_dec_giveshare(gfshare_ctx* ctx, uint8_t sharenr, const uint8_t* share) {
    76cb:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:371
  memcpy(ctx->buffer + (sharenr * ctx->maxsize), share, ctx->size);
    76ce:	48 03 4f 18          	add    0x18(%rdi),%rcx
    76d2:	48 89 cf             	mov    %rcx,%rdi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    76d5:	e8 00 00 00 00       	callq  76da <gfshare_ctx_dec_giveshare+0x2a>
			76d6: R_X86_64_PC32	memcpy-0x4
gfshare_ctx_dec_giveshare():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:372
  return 0;
    76da:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:373
}
    76dc:	5d                   	pop    %rbp
    76dd:	c3                   	retq   
    76de:	b8 01 00 00 00       	mov    $0x1,%eax
    76e3:	c3                   	retq   
    76e4:	66 90                	xchg   %ax,%ax
    76e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    76ed:	00 00 00 

00000000000076f0 <gfshare_ctx_dec_extract>:
gfshare_ctx_dec_extract():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:378

/* Extract the secret by interpolation of the shares.
 * secretbuf must be allocated and at least 'size' bytes long
 */
void gfshare_ctx_dec_extract(const gfshare_ctx* ctx, uint8_t* secretbuf) {
    76f0:	e8 00 00 00 00       	callq  76f5 <gfshare_ctx_dec_extract+0x5>
			76f1: R_X86_64_PC32	__fentry__-0x4
    76f5:	55                   	push   %rbp
    76f6:	49 89 f3             	mov    %rsi,%r11
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    76f9:	31 f6                	xor    %esi,%esi
gfshare_ctx_dec_extract():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:378
    76fb:	48 89 e5             	mov    %rsp,%rbp
    76fe:	41 57                	push   %r15
    7700:	41 56                	push   %r14
    7702:	41 55                	push   %r13
    7704:	41 54                	push   %r12
    7706:	53                   	push   %rbx
    7707:	48 89 fb             	mov    %rdi,%rbx
    770a:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:382
  uint32_t i, j, n, jn;
  uint8_t *secret_ptr, *share_ptr;

  memset(secretbuf, 0, ctx->size);
    770e:	8b 57 0c             	mov    0xc(%rdi),%edx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    7711:	4c 89 df             	mov    %r11,%rdi
    7714:	e8 00 00 00 00       	callq  7719 <gfshare_ctx_dec_extract+0x29>
			7715: R_X86_64_PC32	memset-0x4
gfshare_ctx_dec_extract():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:384
  
  for(n = i = 0; n < ctx->threshold && i < ctx->sharecount; ++n, ++i) {
    7719:	44 8b 43 04          	mov    0x4(%rbx),%r8d
    771d:	45 85 c0             	test   %r8d,%r8d
    7720:	0f 84 2c 01 00 00    	je     7852 <gfshare_ctx_dec_extract+0x162>
    7726:	49 89 c3             	mov    %rax,%r11
    7729:	8b 03                	mov    (%rbx),%eax
    772b:	85 c0                	test   %eax,%eax
    772d:	0f 84 1f 01 00 00    	je     7852 <gfshare_ctx_dec_extract+0x162>
    7733:	45 31 ed             	xor    %r13d,%r13d
    7736:	31 f6                	xor    %esi,%esi
    7738:	eb 1e                	jmp    7758 <gfshare_ctx_dec_extract+0x68>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:389
    /* Compute L(i) as per Lagrange Interpolation */
    unsigned Li_top = 0, Li_bottom = 0;
    
    if(ctx->sharenrs[i] == 0) {
      n--;
    773a:	41 83 ed 01          	sub    $0x1,%r13d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:384 (discriminator 2)
  for(n = i = 0; n < ctx->threshold && i < ctx->sharecount; ++n, ++i) {
    773e:	41 83 c5 01          	add    $0x1,%r13d
    7742:	83 c6 01             	add    $0x1,%esi
    7745:	45 39 e8             	cmp    %r13d,%r8d
    7748:	0f 86 04 01 00 00    	jbe    7852 <gfshare_ctx_dec_extract+0x162>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:384 (discriminator 3)
    774e:	8b 03                	mov    (%rbx),%eax
    7750:	39 f0                	cmp    %esi,%eax
    7752:	0f 86 fa 00 00 00    	jbe    7852 <gfshare_ctx_dec_extract+0x162>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:388
    if(ctx->sharenrs[i] == 0) {
    7758:	4c 8b 53 10          	mov    0x10(%rbx),%r10
    775c:	89 f2                	mov    %esi,%edx
    775e:	45 0f b6 34 12       	movzbl (%r10,%rdx,1),%r14d
    7763:	45 84 f6             	test   %r14b,%r14b
    7766:	74 d2                	je     773a <gfshare_ctx_dec_extract+0x4a>
    7768:	44 8d 60 ff          	lea    -0x1(%rax),%r12d
    776c:	31 d2                	xor    %edx,%edx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:386
    unsigned Li_top = 0, Li_bottom = 0;
    776e:	45 31 c9             	xor    %r9d,%r9d
    7771:	31 ff                	xor    %edi,%edi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:393
      continue; /* this share is not provided. */
    }
    
    for(jn = j = 0; jn < ctx->threshold && j < ctx->sharecount; ++jn, ++j) {
    7773:	31 c9                	xor    %ecx,%ecx
    7775:	49 83 c4 01          	add    $0x1,%r12
    7779:	eb 34                	jmp    77af <gfshare_ctx_dec_extract+0xbf>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:401
      }
      if(ctx->sharenrs[j] == 0) {
        jn--;
        continue; /* skip empty share */
      }
      Li_top += logs[ctx->sharenrs[j]];
    777b:	44 0f b6 f8          	movzbl %al,%r15d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:402
      Li_bottom += logs[(ctx->sharenrs[i]) ^ (ctx->sharenrs[j])];
    777f:	44 31 f0             	xor    %r14d,%eax
    7782:	0f b6 c0             	movzbl %al,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:401
      Li_top += logs[ctx->sharenrs[j]];
    7785:	45 0f b6 bf 00 00 00 	movzbl 0x0(%r15),%r15d
    778c:	00 
			7789: R_X86_64_32S	.rodata+0x24e0
/home/austen/programming/dm-afs/src/lib/libgfshare.c:402
      Li_bottom += logs[(ctx->sharenrs[i]) ^ (ctx->sharenrs[j])];
    778d:	0f b6 80 00 00 00 00 	movzbl 0x0(%rax),%eax
			7790: R_X86_64_32S	.rodata+0x24e0
/home/austen/programming/dm-afs/src/lib/libgfshare.c:401
      Li_top += logs[ctx->sharenrs[j]];
    7794:	44 01 ff             	add    %r15d,%edi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:402
      Li_bottom += logs[(ctx->sharenrs[i]) ^ (ctx->sharenrs[j])];
    7797:	41 01 c1             	add    %eax,%r9d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:393 (discriminator 2)
    for(jn = j = 0; jn < ctx->threshold && j < ctx->sharecount; ++jn, ++j) {
    779a:	83 c1 01             	add    $0x1,%ecx
    779d:	44 39 c1             	cmp    %r8d,%ecx
    77a0:	73 25                	jae    77c7 <gfshare_ctx_dec_extract+0xd7>
    77a2:	48 83 c2 01          	add    $0x1,%rdx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:393 (discriminator 3)
    77a6:	49 39 d4             	cmp    %rdx,%r12
    77a9:	0f 84 b2 00 00 00    	je     7861 <gfshare_ctx_dec_extract+0x171>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:394
      if(i == j) {
    77af:	39 d6                	cmp    %edx,%esi
    77b1:	74 e7                	je     779a <gfshare_ctx_dec_extract+0xaa>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:397
      if(ctx->sharenrs[j] == 0) {
    77b3:	41 0f b6 04 12       	movzbl (%r10,%rdx,1),%eax
    77b8:	84 c0                	test   %al,%al
    77ba:	75 bf                	jne    777b <gfshare_ctx_dec_extract+0x8b>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:398
        jn--;
    77bc:	83 e9 01             	sub    $0x1,%ecx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:393
    for(jn = j = 0; jn < ctx->threshold && j < ctx->sharecount; ++jn, ++j) {
    77bf:	83 c1 01             	add    $0x1,%ecx
    77c2:	44 39 c1             	cmp    %r8d,%ecx
    77c5:	72 db                	jb     77a2 <gfshare_ctx_dec_extract+0xb2>
    77c7:	41 be 81 80 80 80    	mov    $0x80808081,%r14d
    77cd:	44 89 c8             	mov    %r9d,%eax
    77d0:	44 29 cf             	sub    %r9d,%edi
    77d3:	49 0f af c6          	imul   %r14,%rax
    77d7:	48 c1 e8 27          	shr    $0x27,%rax
    77db:	89 c2                	mov    %eax,%edx
    77dd:	c1 e2 08             	shl    $0x8,%edx
    77e0:	29 c2                	sub    %eax,%edx
    77e2:	8d 8c 17 ff 00 00 00 	lea    0xff(%rdi,%rdx,1),%ecx
    77e9:	48 89 ca             	mov    %rcx,%rdx
    77ec:	49 0f af ce          	imul   %r14,%rcx
    77f0:	48 c1 e9 27          	shr    $0x27,%rcx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:409
    Li_bottom %= 0xff;
    Li_top += 0xff - Li_bottom;
    Li_top %= 0xff;
    /* Li_top is now log(L(i)) */
    
    secret_ptr = secretbuf; share_ptr = ctx->buffer + (ctx->maxsize * i);
    77f4:	89 f7                	mov    %esi,%edi
    77f6:	89 c8                	mov    %ecx,%eax
    77f8:	c1 e0 08             	shl    $0x8,%eax
    77fb:	29 c8                	sub    %ecx,%eax
    77fd:	89 d1                	mov    %edx,%ecx
    77ff:	29 c1                	sub    %eax,%ecx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:410
    for(j = 0; j < ctx->size; ++j) {
    7801:	8b 43 0c             	mov    0xc(%rbx),%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:409
    secret_ptr = secretbuf; share_ptr = ctx->buffer + (ctx->maxsize * i);
    7804:	0f af 7b 08          	imul   0x8(%rbx),%edi
    7808:	48 03 7b 18          	add    0x18(%rbx),%rdi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:410
    for(j = 0; j < ctx->size; ++j) {
    780c:	85 c0                	test   %eax,%eax
    780e:	0f 84 2a ff ff ff    	je     773e <gfshare_ctx_dec_extract+0x4e>
    7814:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:411
      if(*share_ptr) {
    7816:	0f b6 14 07          	movzbl (%rdi,%rax,1),%edx
    781a:	84 d2                	test   %dl,%dl
    781c:	74 14                	je     7832 <gfshare_ctx_dec_extract+0x142>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:412
        *secret_ptr ^= exps[Li_top + logs[*share_ptr]];
    781e:	0f b6 92 00 00 00 00 	movzbl 0x0(%rdx),%edx
			7821: R_X86_64_32S	.rodata+0x24e0
    7825:	01 ca                	add    %ecx,%edx
    7827:	0f b6 92 00 00 00 00 	movzbl 0x0(%rdx),%edx
			782a: R_X86_64_32S	.rodata+0x22e0
    782e:	41 30 14 03          	xor    %dl,(%r11,%rax,1)
    7832:	8d 50 01             	lea    0x1(%rax),%edx
    7835:	48 83 c0 01          	add    $0x1,%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:410 (discriminator 2)
    for(j = 0; j < ctx->size; ++j) {
    7839:	39 53 0c             	cmp    %edx,0xc(%rbx)
    783c:	77 d8                	ja     7816 <gfshare_ctx_dec_extract+0x126>
    783e:	44 8b 43 04          	mov    0x4(%rbx),%r8d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:384
  for(n = i = 0; n < ctx->threshold && i < ctx->sharecount; ++n, ++i) {
    7842:	41 83 c5 01          	add    $0x1,%r13d
    7846:	83 c6 01             	add    $0x1,%esi
    7849:	45 39 e8             	cmp    %r13d,%r8d
    784c:	0f 87 fc fe ff ff    	ja     774e <gfshare_ctx_dec_extract+0x5e>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:417
      }
      share_ptr++; secret_ptr++;
    }
  }
}
    7852:	48 83 c4 08          	add    $0x8,%rsp
    7856:	5b                   	pop    %rbx
    7857:	41 5c                	pop    %r12
    7859:	41 5d                	pop    %r13
    785b:	41 5e                	pop    %r14
    785d:	41 5f                	pop    %r15
    785f:	5d                   	pop    %rbp
    7860:	c3                   	retq   
    7861:	41 ba 81 80 80 80    	mov    $0x80808081,%r10d
    7867:	44 89 c8             	mov    %r9d,%eax
    786a:	44 29 cf             	sub    %r9d,%edi
    786d:	49 0f af c2          	imul   %r10,%rax
    7871:	48 c1 e8 27          	shr    $0x27,%rax
    7875:	89 c2                	mov    %eax,%edx
    7877:	c1 e2 08             	shl    $0x8,%edx
    787a:	29 c2                	sub    %eax,%edx
    787c:	8d 8c 17 ff 00 00 00 	lea    0xff(%rdi,%rdx,1),%ecx
    7883:	48 89 ca             	mov    %rcx,%rdx
    7886:	49 0f af ca          	imul   %r10,%rcx
    788a:	e9 61 ff ff ff       	jmpq   77f0 <gfshare_ctx_dec_extract+0x100>
    788f:	90                   	nop

0000000000007890 <gfshare_ctx_dec_decode>:
gfshare_ctx_dec_decode():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:419

void gfshare_ctx_dec_decode(const gfshare_ctx* ctx, uint8_t* sharenrs, uint8_t** shares, uint8_t* secretbuf) {
    7890:	e8 00 00 00 00       	callq  7895 <gfshare_ctx_dec_decode+0x5>
			7891: R_X86_64_PC32	__fentry__-0x4
    7895:	55                   	push   %rbp
    7896:	48 89 e5             	mov    %rsp,%rbp
    7899:	41 57                	push   %r15
    789b:	41 56                	push   %r14
    789d:	41 55                	push   %r13
    789f:	41 54                	push   %r12
    78a1:	49 89 d6             	mov    %rdx,%r14
    78a4:	53                   	push   %rbx
    78a5:	48 89 fb             	mov    %rdi,%rbx
    78a8:	49 89 cc             	mov    %rcx,%r12
    78ab:	48 83 ec 08          	sub    $0x8,%rsp
/home/austen/programming/dm-afs/src/lib/libgfshare.c:423
  uint32_t i, j, n, jn;
  uint8_t *secret_ptr, *share_ptr;

  memcpy(ctx->sharenrs, sharenrs, ctx->sharecount);
    78af:	8b 13                	mov    (%rbx),%edx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    78b1:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
    78b5:	e8 00 00 00 00       	callq  78ba <gfshare_ctx_dec_decode+0x2a>
			78b6: R_X86_64_PC32	memcpy-0x4
gfshare_ctx_dec_decode():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:424
  memset(secretbuf, 0, ctx->size);
    78ba:	8b 53 0c             	mov    0xc(%rbx),%edx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    78bd:	31 f6                	xor    %esi,%esi
    78bf:	4c 89 e7             	mov    %r12,%rdi
    78c2:	e8 00 00 00 00       	callq  78c7 <gfshare_ctx_dec_decode+0x37>
			78c3: R_X86_64_PC32	memset-0x4
gfshare_ctx_dec_decode():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:425
  for(i = 0; i < ctx->sharecount; i++){
    78c7:	8b 13                	mov    (%rbx),%edx
    78c9:	85 d2                	test   %edx,%edx
    78cb:	0f 84 5c 01 00 00    	je     7a2d <gfshare_ctx_dec_decode+0x19d>
    78d1:	45 31 ed             	xor    %r13d,%r13d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:426 (discriminator 3)
      memcpy(ctx->buffer + (i * ctx->maxsize), shares[i], ctx->size);
    78d4:	44 89 ef             	mov    %r13d,%edi
    78d7:	44 89 e8             	mov    %r13d,%eax
    78da:	8b 53 0c             	mov    0xc(%rbx),%edx
    78dd:	0f af 7b 08          	imul   0x8(%rbx),%edi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344 (discriminator 3)
    78e1:	49 8b 34 c6          	mov    (%r14,%rax,8),%rsi
gfshare_ctx_dec_decode():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:425 (discriminator 3)
  for(i = 0; i < ctx->sharecount; i++){
    78e5:	41 83 c5 01          	add    $0x1,%r13d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:426 (discriminator 3)
      memcpy(ctx->buffer + (i * ctx->maxsize), shares[i], ctx->size);
    78e9:	48 03 7b 18          	add    0x18(%rbx),%rdi
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344 (discriminator 3)
    78ed:	e8 00 00 00 00       	callq  78f2 <gfshare_ctx_dec_decode+0x62>
			78ee: R_X86_64_PC32	memcpy-0x4
gfshare_ctx_dec_decode():
/home/austen/programming/dm-afs/src/lib/libgfshare.c:425 (discriminator 3)
  for(i = 0; i < ctx->sharecount; i++){
    78f2:	8b 03                	mov    (%rbx),%eax
    78f4:	44 39 e8             	cmp    %r13d,%eax
    78f7:	77 db                	ja     78d4 <gfshare_ctx_dec_decode+0x44>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:429
  }

  for(n = i = 0; n < ctx->threshold && i < ctx->sharecount; ++n, ++i) {
    78f9:	44 8b 43 04          	mov    0x4(%rbx),%r8d
    78fd:	45 85 c0             	test   %r8d,%r8d
    7900:	0f 84 27 01 00 00    	je     7a2d <gfshare_ctx_dec_decode+0x19d>
    7906:	85 c0                	test   %eax,%eax
    7908:	0f 84 1f 01 00 00    	je     7a2d <gfshare_ctx_dec_decode+0x19d>
    790e:	45 31 ed             	xor    %r13d,%r13d
    7911:	31 f6                	xor    %esi,%esi
    7913:	eb 1e                	jmp    7933 <gfshare_ctx_dec_decode+0xa3>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:434
    /* Compute L(i) as per Lagrange Interpolation */
    unsigned Li_top = 0, Li_bottom = 0;

    if(ctx->sharenrs[i] == 0) {
      n--;
    7915:	41 83 ed 01          	sub    $0x1,%r13d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:429 (discriminator 2)
  for(n = i = 0; n < ctx->threshold && i < ctx->sharecount; ++n, ++i) {
    7919:	41 83 c5 01          	add    $0x1,%r13d
    791d:	83 c6 01             	add    $0x1,%esi
    7920:	45 39 e8             	cmp    %r13d,%r8d
    7923:	0f 86 04 01 00 00    	jbe    7a2d <gfshare_ctx_dec_decode+0x19d>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:429 (discriminator 3)
    7929:	8b 03                	mov    (%rbx),%eax
    792b:	39 f0                	cmp    %esi,%eax
    792d:	0f 86 fa 00 00 00    	jbe    7a2d <gfshare_ctx_dec_decode+0x19d>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:433
    if(ctx->sharenrs[i] == 0) {
    7933:	4c 8b 53 10          	mov    0x10(%rbx),%r10
    7937:	89 f2                	mov    %esi,%edx
    7939:	45 0f b6 34 12       	movzbl (%r10,%rdx,1),%r14d
    793e:	45 84 f6             	test   %r14b,%r14b
    7941:	74 d2                	je     7915 <gfshare_ctx_dec_decode+0x85>
    7943:	44 8d 58 ff          	lea    -0x1(%rax),%r11d
    7947:	31 d2                	xor    %edx,%edx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:431
    unsigned Li_top = 0, Li_bottom = 0;
    7949:	45 31 c9             	xor    %r9d,%r9d
    794c:	31 ff                	xor    %edi,%edi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:438
      continue; /* this share is not provided. */
    }

    for(jn = j = 0; jn < ctx->threshold && j < ctx->sharecount; ++jn, ++j) {
    794e:	31 c9                	xor    %ecx,%ecx
    7950:	49 83 c3 01          	add    $0x1,%r11
    7954:	eb 34                	jmp    798a <gfshare_ctx_dec_decode+0xfa>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:446
      }
      if(ctx->sharenrs[j] == 0) {
        jn--;
        continue; /* skip empty share */
      }
      Li_top += logs[ctx->sharenrs[j]];
    7956:	44 0f b6 f8          	movzbl %al,%r15d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:447
      Li_bottom += logs[(ctx->sharenrs[i]) ^ (ctx->sharenrs[j])];
    795a:	44 31 f0             	xor    %r14d,%eax
    795d:	0f b6 c0             	movzbl %al,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:446
      Li_top += logs[ctx->sharenrs[j]];
    7960:	45 0f b6 bf 00 00 00 	movzbl 0x0(%r15),%r15d
    7967:	00 
			7964: R_X86_64_32S	.rodata+0x24e0
/home/austen/programming/dm-afs/src/lib/libgfshare.c:447
      Li_bottom += logs[(ctx->sharenrs[i]) ^ (ctx->sharenrs[j])];
    7968:	0f b6 80 00 00 00 00 	movzbl 0x0(%rax),%eax
			796b: R_X86_64_32S	.rodata+0x24e0
/home/austen/programming/dm-afs/src/lib/libgfshare.c:446
      Li_top += logs[ctx->sharenrs[j]];
    796f:	44 01 ff             	add    %r15d,%edi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:447
      Li_bottom += logs[(ctx->sharenrs[i]) ^ (ctx->sharenrs[j])];
    7972:	41 01 c1             	add    %eax,%r9d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:438 (discriminator 2)
    for(jn = j = 0; jn < ctx->threshold && j < ctx->sharecount; ++jn, ++j) {
    7975:	83 c1 01             	add    $0x1,%ecx
    7978:	44 39 c1             	cmp    %r8d,%ecx
    797b:	73 25                	jae    79a2 <gfshare_ctx_dec_decode+0x112>
    797d:	48 83 c2 01          	add    $0x1,%rdx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:438 (discriminator 3)
    7981:	49 39 d3             	cmp    %rdx,%r11
    7984:	0f 84 b2 00 00 00    	je     7a3c <gfshare_ctx_dec_decode+0x1ac>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:439
      if(i == j) {
    798a:	39 d6                	cmp    %edx,%esi
    798c:	74 e7                	je     7975 <gfshare_ctx_dec_decode+0xe5>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:442
      if(ctx->sharenrs[j] == 0) {
    798e:	41 0f b6 04 12       	movzbl (%r10,%rdx,1),%eax
    7993:	84 c0                	test   %al,%al
    7995:	75 bf                	jne    7956 <gfshare_ctx_dec_decode+0xc6>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:443
        jn--;
    7997:	83 e9 01             	sub    $0x1,%ecx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:438
    for(jn = j = 0; jn < ctx->threshold && j < ctx->sharecount; ++jn, ++j) {
    799a:	83 c1 01             	add    $0x1,%ecx
    799d:	44 39 c1             	cmp    %r8d,%ecx
    79a0:	72 db                	jb     797d <gfshare_ctx_dec_decode+0xed>
    79a2:	41 bb 81 80 80 80    	mov    $0x80808081,%r11d
    79a8:	44 89 c8             	mov    %r9d,%eax
    79ab:	44 29 cf             	sub    %r9d,%edi
    79ae:	49 0f af c3          	imul   %r11,%rax
    79b2:	48 c1 e8 27          	shr    $0x27,%rax
    79b6:	89 c2                	mov    %eax,%edx
    79b8:	c1 e2 08             	shl    $0x8,%edx
    79bb:	29 c2                	sub    %eax,%edx
    79bd:	8d 8c 17 ff 00 00 00 	lea    0xff(%rdi,%rdx,1),%ecx
    79c4:	48 89 ca             	mov    %rcx,%rdx
    79c7:	49 0f af cb          	imul   %r11,%rcx
    79cb:	48 c1 e9 27          	shr    $0x27,%rcx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:454
    Li_bottom %= 0xff;
    Li_top += 0xff - Li_bottom;
    Li_top %= 0xff;
    /* Li_top is now log(L(i)) */

    secret_ptr = secretbuf; share_ptr = ctx->buffer + (ctx->maxsize * i);
    79cf:	89 f7                	mov    %esi,%edi
    79d1:	89 c8                	mov    %ecx,%eax
    79d3:	c1 e0 08             	shl    $0x8,%eax
    79d6:	29 c8                	sub    %ecx,%eax
    79d8:	89 d1                	mov    %edx,%ecx
    79da:	29 c1                	sub    %eax,%ecx
/home/austen/programming/dm-afs/src/lib/libgfshare.c:455
    for(j = 0; j < ctx->size; ++j) {
    79dc:	8b 43 0c             	mov    0xc(%rbx),%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:454
    secret_ptr = secretbuf; share_ptr = ctx->buffer + (ctx->maxsize * i);
    79df:	0f af 7b 08          	imul   0x8(%rbx),%edi
    79e3:	48 03 7b 18          	add    0x18(%rbx),%rdi
/home/austen/programming/dm-afs/src/lib/libgfshare.c:455
    for(j = 0; j < ctx->size; ++j) {
    79e7:	85 c0                	test   %eax,%eax
    79e9:	0f 84 2a ff ff ff    	je     7919 <gfshare_ctx_dec_decode+0x89>
    79ef:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:456
      if(*share_ptr) {
    79f1:	0f b6 14 07          	movzbl (%rdi,%rax,1),%edx
    79f5:	84 d2                	test   %dl,%dl
    79f7:	74 14                	je     7a0d <gfshare_ctx_dec_decode+0x17d>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:457
        *secret_ptr ^= exps[Li_top + logs[*share_ptr]];
    79f9:	0f b6 92 00 00 00 00 	movzbl 0x0(%rdx),%edx
			79fc: R_X86_64_32S	.rodata+0x24e0
    7a00:	01 ca                	add    %ecx,%edx
    7a02:	0f b6 92 00 00 00 00 	movzbl 0x0(%rdx),%edx
			7a05: R_X86_64_32S	.rodata+0x22e0
    7a09:	41 30 14 04          	xor    %dl,(%r12,%rax,1)
    7a0d:	8d 50 01             	lea    0x1(%rax),%edx
    7a10:	48 83 c0 01          	add    $0x1,%rax
/home/austen/programming/dm-afs/src/lib/libgfshare.c:455 (discriminator 2)
    for(j = 0; j < ctx->size; ++j) {
    7a14:	39 53 0c             	cmp    %edx,0xc(%rbx)
    7a17:	77 d8                	ja     79f1 <gfshare_ctx_dec_decode+0x161>
    7a19:	44 8b 43 04          	mov    0x4(%rbx),%r8d
/home/austen/programming/dm-afs/src/lib/libgfshare.c:429
  for(n = i = 0; n < ctx->threshold && i < ctx->sharecount; ++n, ++i) {
    7a1d:	41 83 c5 01          	add    $0x1,%r13d
    7a21:	83 c6 01             	add    $0x1,%esi
    7a24:	45 39 e8             	cmp    %r13d,%r8d
    7a27:	0f 87 fc fe ff ff    	ja     7929 <gfshare_ctx_dec_decode+0x99>
/home/austen/programming/dm-afs/src/lib/libgfshare.c:462
      }
      share_ptr++; secret_ptr++;
    }
  }
}
    7a2d:	48 83 c4 08          	add    $0x8,%rsp
    7a31:	5b                   	pop    %rbx
    7a32:	41 5c                	pop    %r12
    7a34:	41 5d                	pop    %r13
    7a36:	41 5e                	pop    %r14
    7a38:	41 5f                	pop    %r15
    7a3a:	5d                   	pop    %rbp
    7a3b:	c3                   	retq   
    7a3c:	41 ba 81 80 80 80    	mov    $0x80808081,%r10d
    7a42:	44 89 c8             	mov    %r9d,%eax
    7a45:	44 29 cf             	sub    %r9d,%edi
    7a48:	49 0f af c2          	imul   %r10,%rax
    7a4c:	48 c1 e8 27          	shr    $0x27,%rax
    7a50:	89 c2                	mov    %eax,%edx
    7a52:	c1 e2 08             	shl    $0x8,%edx
    7a55:	29 c2                	sub    %eax,%edx
    7a57:	8d 8c 17 ff 00 00 00 	lea    0xff(%rdi,%rdx,1),%ecx
    7a5e:	48 89 ca             	mov    %rcx,%rdx
    7a61:	49 0f af ca          	imul   %r10,%rcx
    7a65:	e9 61 ff ff ff       	jmpq   79cb <gfshare_ctx_dec_decode+0x13b>
    7a6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000007a70 <UNALIGNED_LOAD64>:
UNALIGNED_LOAD64():
/home/austen/programming/dm-afs/src/lib/city.c:40
#include <linux/string.h>
#include <linux/kernel.h>

#define SWAP(x, y) do { typeof(x) SWAP = x; x = y; y = SWAP; } while (0)

static uint64_t UNALIGNED_LOAD64(const uint8_t *p) {
    7a70:	e8 00 00 00 00       	callq  7a75 <UNALIGNED_LOAD64+0x5>
			7a71: R_X86_64_PC32	__fentry__-0x4
    7a75:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/city.c:43
  uint64_t result;
  memcpy(&result, p, sizeof(result));
  return result;
    7a76:	48 8b 07             	mov    (%rdi),%rax
/home/austen/programming/dm-afs/src/lib/city.c:40
static uint64_t UNALIGNED_LOAD64(const uint8_t *p) {
    7a79:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/city.c:44
}
    7a7c:	5d                   	pop    %rbp
    7a7d:	c3                   	retq   
    7a7e:	66 90                	xchg   %ax,%ax

0000000000007a80 <WeakHashLen32WithSeedsArray>:
WeakHashLen32WithSeedsArray():
/home/austen/programming/dm-afs/src/lib/city.c:326
  output.second = (uint64_t)(b+c);
  return output;
}

// Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
static uint128 WeakHashLen32WithSeedsArray(const uint8_t* s, uint64_t a, uint64_t b) {
    7a80:	e8 00 00 00 00       	callq  7a85 <WeakHashLen32WithSeedsArray+0x5>
			7a81: R_X86_64_PC32	__fentry__-0x4
    7a85:	55                   	push   %rbp
    7a86:	48 89 e5             	mov    %rsp,%rbp
    7a89:	41 57                	push   %r15
    7a8b:	41 56                	push   %r14
    7a8d:	41 55                	push   %r13
    7a8f:	41 54                	push   %r12
    7a91:	49 89 ff             	mov    %rdi,%r15
    7a94:	53                   	push   %rbx
/home/austen/programming/dm-afs/src/lib/city.c:327
  return WeakHashLen32WithSeeds(Fetch64(s),
    7a95:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:326
static uint128 WeakHashLen32WithSeedsArray(const uint8_t* s, uint64_t a, uint64_t b) {
    7a99:	49 89 f5             	mov    %rsi,%r13
    7a9c:	48 83 ec 08          	sub    $0x8,%rsp
    7aa0:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7aa4:	e8 c7 ff ff ff       	callq  7a70 <UNALIGNED_LOAD64>
WeakHashLen32WithSeedsArray():
/home/austen/programming/dm-afs/src/lib/city.c:327
  return WeakHashLen32WithSeeds(Fetch64(s),
    7aa9:	49 8d 7f 10          	lea    0x10(%r15),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7aad:	48 89 c3             	mov    %rax,%rbx
    7ab0:	e8 bb ff ff ff       	callq  7a70 <UNALIGNED_LOAD64>
WeakHashLen32WithSeedsArray():
/home/austen/programming/dm-afs/src/lib/city.c:327
  return WeakHashLen32WithSeeds(Fetch64(s),
    7ab5:	49 8d 7f 08          	lea    0x8(%r15),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7ab9:	49 89 c6             	mov    %rax,%r14
    7abc:	e8 af ff ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    7ac1:	4c 89 ff             	mov    %r15,%rdi
    7ac4:	49 89 c4             	mov    %rax,%r12
    7ac7:	e8 a4 ff ff ff       	callq  7a70 <UNALIGNED_LOAD64>
WeakHashLen32WithSeeds():
/home/austen/programming/dm-afs/src/lib/city.c:315
  b = Rotate(b + a + z, 21);
    7acc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
/home/austen/programming/dm-afs/src/lib/city.c:314
  a += w;
    7ad0:	49 8d 74 05 00       	lea    0x0(%r13,%rax,1),%rsi
/home/austen/programming/dm-afs/src/lib/city.c:318
  a += y;
    7ad5:	4b 8d 0c 34          	lea    (%r12,%r14,1),%rcx
WeakHashLen32WithSeedsArray():
/home/austen/programming/dm-afs/src/lib/city.c:333
                                Fetch64(s + 8),
                                Fetch64(s + 16),
                                Fetch64(s + 24),
                                a,
                                b);
}
    7ad9:	48 83 c4 08          	add    $0x8,%rsp
WeakHashLen32WithSeeds():
/home/austen/programming/dm-afs/src/lib/city.c:318
  a += y;
    7add:	48 01 f1             	add    %rsi,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:320
  output.first = (uint64_t)(a+z);
    7ae0:	48 8d 04 19          	lea    (%rcx,%rbx,1),%rax
/home/austen/programming/dm-afs/src/lib/city.c:315
  b = Rotate(b + a + z, 21);
    7ae4:	48 01 d3             	add    %rdx,%rbx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    7ae7:	48 c1 c1 14          	rol    $0x14,%rcx
WeakHashLen32WithSeeds():
/home/austen/programming/dm-afs/src/lib/city.c:315
  b = Rotate(b + a + z, 21);
    7aeb:	48 8d 14 33          	lea    (%rbx,%rsi,1),%rdx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    7aef:	48 89 d3             	mov    %rdx,%rbx
    7af2:	48 c1 cb 15          	ror    $0x15,%rbx
WeakHashLen32WithSeeds():
/home/austen/programming/dm-afs/src/lib/city.c:319
  b += Rotate(a, 44);
    7af6:	48 8d 14 0b          	lea    (%rbx,%rcx,1),%rdx
WeakHashLen32WithSeedsArray():
/home/austen/programming/dm-afs/src/lib/city.c:333
}
    7afa:	5b                   	pop    %rbx
WeakHashLen32WithSeeds():
/home/austen/programming/dm-afs/src/lib/city.c:321
  output.second = (uint64_t)(b+c);
    7afb:	48 01 f2             	add    %rsi,%rdx
WeakHashLen32WithSeedsArray():
/home/austen/programming/dm-afs/src/lib/city.c:333
}
    7afe:	41 5c                	pop    %r12
    7b00:	41 5d                	pop    %r13
    7b02:	41 5e                	pop    %r14
    7b04:	41 5f                	pop    %r15
    7b06:	5d                   	pop    %rbp
    7b07:	c3                   	retq   
    7b08:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    7b0f:	00 

0000000000007b10 <UNALIGNED_LOAD32>:
UNALIGNED_LOAD32():
/home/austen/programming/dm-afs/src/lib/city.c:46
static uint32_t UNALIGNED_LOAD32(const uint8_t *p) {
    7b10:	e8 00 00 00 00       	callq  7b15 <UNALIGNED_LOAD32+0x5>
			7b11: R_X86_64_PC32	__fentry__-0x4
    7b15:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/city.c:49
  return result;
    7b16:	8b 07                	mov    (%rdi),%eax
/home/austen/programming/dm-afs/src/lib/city.c:46
static uint32_t UNALIGNED_LOAD32(const uint8_t *p) {
    7b18:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/city.c:50
}
    7b1b:	5d                   	pop    %rbp
    7b1c:	c3                   	retq   
    7b1d:	0f 1f 00             	nopl   (%rax)

0000000000007b20 <HashLen0to16>:
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:272
static uint64_t HashLen0to16(const uint8_t *s, size_t len) {
    7b20:	e8 00 00 00 00       	callq  7b25 <HashLen0to16+0x5>
			7b21: R_X86_64_PC32	__fentry__-0x4
    7b25:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/city.c:273
  if (len >= 8) {
    7b26:	48 83 fe 07          	cmp    $0x7,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:272
static uint64_t HashLen0to16(const uint8_t *s, size_t len) {
    7b2a:	48 89 e5             	mov    %rsp,%rbp
    7b2d:	41 56                	push   %r14
    7b2f:	41 55                	push   %r13
    7b31:	49 89 fd             	mov    %rdi,%r13
    7b34:	41 54                	push   %r12
    7b36:	49 89 f4             	mov    %rsi,%r12
    7b39:	53                   	push   %rbx
/home/austen/programming/dm-afs/src/lib/city.c:273
  if (len >= 8) {
    7b3a:	0f 87 a5 00 00 00    	ja     7be5 <HashLen0to16+0xc5>
/home/austen/programming/dm-afs/src/lib/city.c:281
  if (len >= 4) {
    7b40:	48 83 fe 03          	cmp    $0x3,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:282
    uint64_t mul = k2 + len * 2;
    7b44:	48 b8 4f 40 90 2f 3b 	movabs $0x9ae16a3b2f90404f,%rax
    7b4b:	6a e1 9a 
/home/austen/programming/dm-afs/src/lib/city.c:281
  if (len >= 4) {
    7b4e:	77 4b                	ja     7b9b <HashLen0to16+0x7b>
/home/austen/programming/dm-afs/src/lib/city.c:286
  if (len > 0) {
    7b50:	48 85 f6             	test   %rsi,%rsi
    7b53:	74 3d                	je     7b92 <HashLen0to16+0x72>
/home/austen/programming/dm-afs/src/lib/city.c:288
    uint8_t b = s[len >> 1];
    7b55:	48 89 f2             	mov    %rsi,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:290
    uint32_t y = (uint32_t)(a) + ((uint32_t)(b) << 8);
    7b58:	0f b6 0f             	movzbl (%rdi),%ecx
/home/austen/programming/dm-afs/src/lib/city.c:288
    uint8_t b = s[len >> 1];
    7b5b:	48 d1 ea             	shr    %rdx
/home/austen/programming/dm-afs/src/lib/city.c:290
    uint32_t y = (uint32_t)(a) + ((uint32_t)(b) << 8);
    7b5e:	0f b6 14 17          	movzbl (%rdi,%rdx,1),%edx
    7b62:	c1 e2 08             	shl    $0x8,%edx
    7b65:	01 ca                	add    %ecx,%edx
/home/austen/programming/dm-afs/src/lib/city.c:291
    uint32_t z = len + ((uint32_t)(c) << 2);
    7b67:	0f b6 4c 37 ff       	movzbl -0x1(%rdi,%rsi,1),%ecx
/home/austen/programming/dm-afs/src/lib/city.c:292
    return ShiftMix(y * k2 ^ z * k0) * k2;
    7b6c:	48 0f af d0          	imul   %rax,%rdx
    7b70:	8d 0c 8e             	lea    (%rsi,%rcx,4),%ecx
    7b73:	48 be 27 31 cb 97 5c 	movabs $0xc3a5c85c97cb3127,%rsi
    7b7a:	c8 a5 c3 
    7b7d:	48 0f af ce          	imul   %rsi,%rcx
    7b81:	48 31 ca             	xor    %rcx,%rdx
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    7b84:	48 89 d1             	mov    %rdx,%rcx
    7b87:	48 c1 e9 2f          	shr    $0x2f,%rcx
    7b8b:	48 31 ca             	xor    %rcx,%rdx
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:292
    return ShiftMix(y * k2 ^ z * k0) * k2;
    7b8e:	48 0f af c2          	imul   %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:295
}
    7b92:	5b                   	pop    %rbx
    7b93:	41 5c                	pop    %r12
    7b95:	41 5d                	pop    %r13
    7b97:	41 5e                	pop    %r14
    7b99:	5d                   	pop    %rbp
    7b9a:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/city.c:282
    uint64_t mul = k2 + len * 2;
    7b9b:	4c 8d 34 70          	lea    (%rax,%rsi,2),%r14
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    7b9f:	e8 6c ff ff ff       	callq  7b10 <UNALIGNED_LOAD32>
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:284
    return HashLen16Mul(len + (a << 3), Fetch32(s + len - 4), mul);
    7ba4:	4b 8d 7c 25 fc       	lea    -0x4(%r13,%r12,1),%rdi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    7ba9:	89 c3                	mov    %eax,%ebx
    7bab:	e8 60 ff ff ff       	callq  7b10 <UNALIGNED_LOAD32>
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:284
    return HashLen16Mul(len + (a << 3), Fetch32(s + len - 4), mul);
    7bb0:	49 8d 0c dc          	lea    (%r12,%rbx,8),%rcx
    7bb4:	89 c2                	mov    %eax,%edx
HashLen16Mul():
/home/austen/programming/dm-afs/src/lib/city.c:266
  b = (v ^ a) * mul;
    7bb6:	48 89 d0             	mov    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:264
  a = (u ^ v) * mul;
    7bb9:	48 31 d1             	xor    %rdx,%rcx
    7bbc:	49 0f af ce          	imul   %r14,%rcx
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:295
}
    7bc0:	5b                   	pop    %rbx
    7bc1:	41 5c                	pop    %r12
    7bc3:	41 5d                	pop    %r13
HashLen16Mul():
/home/austen/programming/dm-afs/src/lib/city.c:266
  b = (v ^ a) * mul;
    7bc5:	48 31 c8             	xor    %rcx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:265
  a ^= (a >> 47);
    7bc8:	48 c1 e9 2f          	shr    $0x2f,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:266
  b = (v ^ a) * mul;
    7bcc:	48 31 c8             	xor    %rcx,%rax
    7bcf:	49 0f af c6          	imul   %r14,%rax
/home/austen/programming/dm-afs/src/lib/city.c:267
  b ^= (b >> 47);
    7bd3:	48 89 c2             	mov    %rax,%rdx
    7bd6:	48 c1 ea 2f          	shr    $0x2f,%rdx
    7bda:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:268
  b *= mul;
    7bdd:	49 0f af c6          	imul   %r14,%rax
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:295
}
    7be1:	41 5e                	pop    %r14
    7be3:	5d                   	pop    %rbp
    7be4:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/city.c:274
    uint64_t mul = k2 + len * 2;
    7be5:	49 be 4f 40 90 2f 3b 	movabs $0x9ae16a3b2f90404f,%r14
    7bec:	6a e1 9a 
    7bef:	49 8d 1c 76          	lea    (%r14,%rsi,2),%rbx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7bf3:	e8 78 fe ff ff       	callq  7a70 <UNALIGNED_LOAD64>
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:276
    uint64_t b = Fetch64(s + len - 8);
    7bf8:	4b 8d 7c 25 f8       	lea    -0x8(%r13,%r12,1),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:275
    uint64_t a = Fetch64(s) + k2;
    7bfd:	49 01 c6             	add    %rax,%r14
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7c00:	e8 6b fe ff ff       	callq  7a70 <UNALIGNED_LOAD64>
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    7c05:	4c 89 f1             	mov    %r14,%rcx
    7c08:	48 c1 c9 19          	ror    $0x19,%rcx
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:278
    uint64_t d = (Rotate(a, 25) + b) * mul;
    7c0c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    7c10:	48 c1 c0 1b          	rol    $0x1b,%rax
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:277
    uint64_t c = Rotate(b, 37) * mul + a;
    7c14:	48 0f af c3          	imul   %rbx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:278
    uint64_t d = (Rotate(a, 25) + b) * mul;
    7c18:	48 89 d1             	mov    %rdx,%rcx
    7c1b:	48 0f af cb          	imul   %rbx,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:277
    uint64_t c = Rotate(b, 37) * mul + a;
    7c1f:	4a 8d 14 30          	lea    (%rax,%r14,1),%rdx
HashLen16Mul():
/home/austen/programming/dm-afs/src/lib/city.c:264
  a = (u ^ v) * mul;
    7c23:	48 31 ca             	xor    %rcx,%rdx
    7c26:	48 0f af d3          	imul   %rbx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:265
  a ^= (a >> 47);
    7c2a:	48 89 d0             	mov    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:266
  b = (v ^ a) * mul;
    7c2d:	48 31 ca             	xor    %rcx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:265
  a ^= (a >> 47);
    7c30:	48 c1 e8 2f          	shr    $0x2f,%rax
/home/austen/programming/dm-afs/src/lib/city.c:266
  b = (v ^ a) * mul;
    7c34:	48 31 c2             	xor    %rax,%rdx
    7c37:	48 0f af d3          	imul   %rbx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:267
  b ^= (b >> 47);
    7c3b:	48 89 d0             	mov    %rdx,%rax
    7c3e:	48 c1 e8 2f          	shr    $0x2f,%rax
    7c42:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:268
  b *= mul;
    7c45:	48 0f af c3          	imul   %rbx,%rax
HashLen0to16():
/home/austen/programming/dm-afs/src/lib/city.c:295
}
    7c49:	5b                   	pop    %rbx
    7c4a:	41 5c                	pop    %r12
    7c4c:	41 5d                	pop    %r13
    7c4e:	41 5e                	pop    %r14
    7c50:	5d                   	pop    %rbp
    7c51:	c3                   	retq   
    7c52:	0f 1f 40 00          	nopl   0x0(%rax)
    7c56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    7c5d:	00 00 00 

0000000000007c60 <CityHashCrc256Long>:
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:526
#undef _MM_MALLOC_H_INCLUDED
#pragma GCC pop_options

// Requires len >= 240.
static void CityHashCrc256Long(const uint8_t *s, size_t len,
                               uint32_t seed, uint64_t *result) {
    7c60:	e8 00 00 00 00       	callq  7c65 <CityHashCrc256Long+0x5>
			7c61: R_X86_64_PC32	__fentry__-0x4
    7c65:	55                   	push   %rbp
    7c66:	48 89 e5             	mov    %rsp,%rbp
    7c69:	41 57                	push   %r15
    7c6b:	41 56                	push   %r14
    7c6d:	41 55                	push   %r13
    7c6f:	41 54                	push   %r12
    7c71:	41 89 d7             	mov    %edx,%r15d
    7c74:	53                   	push   %rbx
    7c75:	48 89 fb             	mov    %rdi,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:527
  uint64_t a = Fetch64(s + 56) + k0;
    7c78:	48 8d 7f 38          	lea    0x38(%rdi),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:526
                               uint32_t seed, uint64_t *result) {
    7c7c:	49 89 f4             	mov    %rsi,%r12
/home/austen/programming/dm-afs/src/lib/city.c:527
  uint64_t a = Fetch64(s + 56) + k0;
    7c7f:	49 be 27 31 cb 97 5c 	movabs $0xc3a5c85c97cb3127,%r14
    7c86:	c8 a5 c3 
/home/austen/programming/dm-afs/src/lib/city.c:526
                               uint32_t seed, uint64_t *result) {
    7c89:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
    7c8d:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7c94:	e8 d7 fd ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:528
  uint64_t b = Fetch64(s + 96) + k0;
    7c99:	48 8d 7b 60          	lea    0x60(%rbx),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:527
  uint64_t a = Fetch64(s + 56) + k0;
    7c9d:	4e 8d 2c 30          	lea    (%rax,%r14,1),%r13
/home/austen/programming/dm-afs/src/lib/city.c:528
  uint64_t b = Fetch64(s + 96) + k0;
    7ca1:	48 89 9d 78 ff ff ff 	mov    %rbx,-0x88(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7ca8:	e8 c3 fd ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:528
  uint64_t b = Fetch64(s + 96) + k0;
    7cad:	4a 8d 1c 30          	lea    (%rax,%r14,1),%rbx
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    7cb1:	48 b9 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rcx
    7cb8:	ea df 9d 
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    7cbb:	4c 89 e0             	mov    %r12,%rax
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    7cbe:	48 89 da             	mov    %rbx,%rdx
    7cc1:	4c 31 e2             	xor    %r12,%rdx
    7cc4:	48 0f af d1          	imul   %rcx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    7cc8:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    7ccb:	48 c1 ea 2f          	shr    $0x2f,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    7ccf:	48 31 d0             	xor    %rdx,%rax
    7cd2:	48 0f af c1          	imul   %rcx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    7cd6:	48 89 c2             	mov    %rax,%rdx
    7cd9:	48 c1 ea 2f          	shr    $0x2f,%rdx
    7cdd:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    7ce0:	48 89 c7             	mov    %rax,%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:529
  uint64_t c = result[0] = HashLen16(b, len);
    7ce3:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    7cea:	48 0f af f9          	imul   %rcx,%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:529
  uint64_t c = result[0] = HashLen16(b, len);
    7cee:	48 89 38             	mov    %rdi,(%rax)
/home/austen/programming/dm-afs/src/lib/city.c:530
  uint64_t d = result[1] = Fetch64(s + 120) * k0 + len;
    7cf1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:529
  uint64_t c = result[0] = HashLen16(b, len);
    7cf8:	48 89 bd 60 ff ff ff 	mov    %rdi,-0xa0(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:530
  uint64_t d = result[1] = Fetch64(s + 120) * k0 + len;
    7cff:	48 8d 78 78          	lea    0x78(%rax),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7d03:	e8 68 fd ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:530
  uint64_t d = result[1] = Fetch64(s + 120) * k0 + len;
    7d08:	4c 0f af f0          	imul   %rax,%r14
    7d0c:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    7d13:	4f 8d 0c 26          	lea    (%r14,%r12,1),%r9
/home/austen/programming/dm-afs/src/lib/city.c:531
  uint64_t e = Fetch64(s + 184) + seed;
    7d17:	4c 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%r14
/home/austen/programming/dm-afs/src/lib/city.c:530
  uint64_t d = result[1] = Fetch64(s + 120) * k0 + len;
    7d1e:	4c 89 48 08          	mov    %r9,0x8(%rax)
    7d22:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:531
  uint64_t e = Fetch64(s + 184) + seed;
    7d29:	49 8d be b8 00 00 00 	lea    0xb8(%r14),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7d30:	e8 3b fd ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:531
  uint64_t e = Fetch64(s + 184) + seed;
    7d35:	45 89 f8             	mov    %r15d,%r8d
/home/austen/programming/dm-afs/src/lib/city.c:540
  uint64_t x = seed;
  uint64_t y = 0;
  uint64_t z = 0;

  // 240 bytes of input per iter.
  size_t iters = len / 240;
    7d38:	48 ba 89 88 88 88 88 	movabs $0x8888888888888889,%rdx
    7d3f:	88 88 88 
/home/austen/programming/dm-afs/src/lib/city.c:534
  uint64_t h = c + d;
    7d42:	4c 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%r9
/home/austen/programming/dm-afs/src/lib/city.c:531
  uint64_t e = Fetch64(s + 184) + seed;
    7d49:	49 8d 34 00          	lea    (%r8,%rax,1),%rsi
/home/austen/programming/dm-afs/src/lib/city.c:540
  size_t iters = len / 240;
    7d4d:	4c 89 e0             	mov    %r12,%rax
/home/austen/programming/dm-afs/src/lib/city.c:534
  uint64_t h = c + d;
    7d50:	48 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:540
  size_t iters = len / 240;
    7d57:	48 f7 e2             	mul    %rdx
/home/austen/programming/dm-afs/src/lib/city.c:536
  uint64_t y = 0;
    7d5a:	45 31 db             	xor    %r11d,%r11d
/home/austen/programming/dm-afs/src/lib/city.c:532
  uint64_t f = 0;
    7d5d:	45 31 d2             	xor    %r10d,%r10d
/home/austen/programming/dm-afs/src/lib/city.c:534
  uint64_t h = c + d;
    7d60:	4c 89 c9             	mov    %r9,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:530
  uint64_t d = result[1] = Fetch64(s + 120) * k0 + len;
    7d63:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:537
  uint64_t z = 0;
    7d67:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    7d6e:	00 
/home/austen/programming/dm-afs/src/lib/city.c:534
  uint64_t h = c + d;
    7d6f:	48 01 f9             	add    %rdi,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:532
  uint64_t f = 0;
    7d72:	4d 89 c1             	mov    %r8,%r9
/home/austen/programming/dm-afs/src/lib/city.c:540
  size_t iters = len / 240;
    7d75:	48 c1 ea 07          	shr    $0x7,%rdx
    7d79:	48 89 d0             	mov    %rdx,%rax
    7d7c:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
    7d83:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
    7d87:	48 c1 e0 04          	shl    $0x4,%rax
    7d8b:	48 29 d0             	sub    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:532
  uint64_t f = 0;
    7d8e:	48 89 ca             	mov    %rcx,%rdx
    7d91:	4c 89 e9             	mov    %r13,%rcx
    7d94:	48 c1 e0 04          	shl    $0x4,%rax
    7d98:	49 89 f5             	mov    %rsi,%r13
    7d9b:	4c 89 de             	mov    %r11,%rsi
    7d9e:	49 29 c4             	sub    %rax,%r12
/home/austen/programming/dm-afs/src/lib/city.c:533
  uint64_t g = 0;
    7da1:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/city.c:532
  uint64_t f = 0;
    7da3:	49 89 db             	mov    %rbx,%r11
    7da6:	4c 89 65 c0          	mov    %r12,-0x40(%rbp)
    7daa:	4c 89 d3             	mov    %r10,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:529
  uint64_t c = result[0] = HashLen16(b, len);
    7dad:	49 89 fc             	mov    %rdi,%r12
/home/austen/programming/dm-afs/src/lib/city.c:532
  uint64_t f = 0;
    7db0:	49 89 c0             	mov    %rax,%r8
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7db3:	4c 89 f7             	mov    %r14,%rdi
    7db6:	4c 89 45 90          	mov    %r8,-0x70(%rbp)
    7dba:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
    7dbe:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    7dc2:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    7dc6:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
    7dca:	4c 89 5d b8          	mov    %r11,-0x48(%rbp)
    7dce:	e8 9d fc ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    x = _mm_crc32_u64(x, f + a);                \
    e = Rotate(e, r);                           \
    c += e;                                     \
    s += 40

    CHUNK(0); PERMUTE3(a, h, c);
    7dd3:	4c 8b 5d b8          	mov    -0x48(%rbp),%r11
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7dd7:	49 8d 7e 08          	lea    0x8(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    CHUNK(0); PERMUTE3(a, h, c);
    7ddb:	4d 8d 3c 03          	lea    (%r11,%rax,1),%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7ddf:	e8 8c fc ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    7de4:	49 8d 7e 10          	lea    0x10(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    CHUNK(0); PERMUTE3(a, h, c);
    7de8:	4d 8d 14 04          	lea    (%r12,%rax,1),%r10
    7dec:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7df0:	e8 7b fc ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    CHUNK(0); PERMUTE3(a, h, c);
    7df5:	48 03 45 d0          	add    -0x30(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7df9:	49 8d 7e 18          	lea    0x18(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    CHUNK(0); PERMUTE3(a, h, c);
    7dfd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7e01:	e8 6a fc ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    7e06:	49 8d 7e 20          	lea    0x20(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    CHUNK(0); PERMUTE3(a, h, c);
    7e0a:	49 01 c5             	add    %rax,%r13
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7e0d:	e8 5e fc ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    CHUNK(0); PERMUTE3(a, h, c);
    7e12:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    7e16:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
    7e1a:	4c 8d 24 03          	lea    (%rbx,%rax,1),%r12
    7e1e:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    7e22:	4c 8b 45 90          	mov    -0x70(%rbp),%r8
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7e26:	49 8d 7e 28          	lea    0x28(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    CHUNK(0); PERMUTE3(a, h, c);
    7e2a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    7e2e:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
    7e32:	4f 8d 1c 17          	lea    (%r15,%r10,1),%r11
    7e36:	4b 8d 1c 29          	lea    (%r9,%r13,1),%rbx
    7e3a:	49 01 f5             	add    %rsi,%r13
    7e3d:	4d 01 c5             	add    %r8,%r13
    7e40:	4c 01 e2             	add    %r12,%rdx
    7e43:	4c 03 65 d0          	add    -0x30(%rbp),%r12
    7e47:	4b 8d 04 2b          	lea    (%r11,%r13,1),%rax
    7e4b:	4c 01 f9             	add    %r15,%rcx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)

#ifdef __x86_64__
extern __inline unsigned long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_crc32_u64 (unsigned long long __C, unsigned long long __V)
{
  return __builtin_ia32_crc32di (__C, __V);
    7e4e:	4c 8b 7d c8          	mov    -0x38(%rbp),%r15
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    7e52:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    7e56:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7e5a:	f2 4c 0f 38 f1 c8    	crc32q %rax,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    7e60:	48 8d 04 1a          	lea    (%rdx,%rbx,1),%rax
    7e64:	49 8d 14 1a          	lea    (%r10,%rbx,1),%rdx
    7e68:	4c 89 5d b0          	mov    %r11,-0x50(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7e6c:	f2 4c 0f 38 f1 f8    	crc32q %rax,%r15
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:565 (discriminator 1)
    7e72:	4a 8d 04 21          	lea    (%rcx,%r12,1),%rax
    7e76:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7e7a:	4c 89 4d 90          	mov    %r9,-0x70(%rbp)
    7e7e:	f2 48 0f 38 f1 f0    	crc32q %rax,%rsi
    7e84:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7e88:	e8 e3 fb ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7e8d:	4c 8b 5d b0          	mov    -0x50(%rbp),%r11
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7e91:	49 8d 7e 30          	lea    0x30(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7e95:	49 01 c3             	add    %rax,%r11
    7e98:	4c 89 5d b0          	mov    %r11,-0x50(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7e9c:	e8 cf fb ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7ea1:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7ea5:	49 8d 7e 38          	lea    0x38(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7ea9:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
    7ead:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7eb1:	e8 ba fb ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7eb6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7eba:	49 8d 7e 40          	lea    0x40(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7ebe:	48 01 c2             	add    %rax,%rdx
    7ec1:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7ec5:	e8 a6 fb ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    7eca:	49 8d 7e 48          	lea    0x48(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7ece:	48 01 c3             	add    %rax,%rbx
    7ed1:	49 01 dd             	add    %rbx,%r13
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7ed4:	e8 97 fb ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7ed9:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    7edd:	4c 8b 5d b0          	mov    -0x50(%rbp),%r11
    7ee1:	4d 01 fd             	add    %r15,%r13
    7ee4:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    7ee8:	49 01 c4             	add    %rax,%r12
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7eeb:	4d 89 fa             	mov    %r15,%r10
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7eee:	49 8d 7e 50          	lea    0x50(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7ef2:	4a 8d 14 1e          	lea    (%rsi,%r11,1),%rdx
    7ef6:	4c 03 5d c8          	add    -0x38(%rbp),%r11
    7efa:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    7efe:	4e 8d 04 21          	lea    (%rcx,%r12,1),%r8
    7f02:	4c 03 65 d0          	add    -0x30(%rbp),%r12
    7f06:	48 01 f3             	add    %rsi,%rbx
    7f09:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
    7f0d:	4b 8d 04 2b          	lea    (%r11,%r13,1),%rax
    7f11:	4c 89 5d 98          	mov    %r11,-0x68(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7f15:	f2 48 0f 38 f1 f0    	crc32q %rax,%rsi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    7f1b:	49 8d 04 18          	lea    (%r8,%rbx,1),%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    7f1f:	48 c1 c3 1f          	rol    $0x1f,%rbx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7f23:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
    7f27:	4c 8b 4d 90          	mov    -0x70(%rbp),%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, f);
    7f2b:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7f2f:	f2 4c 0f 38 f1 c8    	crc32q %rax,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:566 (discriminator 1)
    7f35:	4a 8d 04 22          	lea    (%rdx,%r12,1),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7f39:	f2 4c 0f 38 f1 d0    	crc32q %rax,%r10
    7f3f:	4c 89 4d a8          	mov    %r9,-0x58(%rbp)
    7f43:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7f47:	e8 24 fb ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, f);
    7f4c:	4c 8b 5d 98          	mov    -0x68(%rbp),%r11
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7f50:	49 8d 7e 58          	lea    0x58(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, f);
    7f54:	4d 8d 3c 03          	lea    (%r11,%rax,1),%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7f58:	e8 13 fb ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    7f5d:	48 03 45 c8          	add    -0x38(%rbp),%rax
    7f61:	49 8d 7e 60          	lea    0x60(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, f);
    7f65:	48 8d 34 18          	lea    (%rax,%rbx,1),%rsi
    7f69:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7f6d:	e8 fe fa ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, f);
    7f72:	48 03 45 d0          	add    -0x30(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7f76:	49 8d 7e 68          	lea    0x68(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, f);
    7f7a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7f7e:	e8 ed fa ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    7f83:	49 8d 7e 70          	lea    0x70(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, f);
    7f87:	48 01 c3             	add    %rax,%rbx
    7f8a:	4d 01 fc             	add    %r15,%r12
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7f8d:	e8 de fa ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, f);
    7f92:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    7f96:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7f9a:	49 8d 7e 78          	lea    0x78(%r14),%rdi
    7f9e:	4c 8b 4d a8          	mov    -0x58(%rbp),%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, f);
    7fa2:	4c 8b 55 b8          	mov    -0x48(%rbp),%r10
    7fa6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    7faa:	49 01 c0             	add    %rax,%r8
    7fad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    7fb1:	49 8d 0c 37          	lea    (%r15,%rsi,1),%rcx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7fb5:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    7fb9:	4c 01 c2             	add    %r8,%rdx
    7fbc:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    7fc0:	4e 8d 3c 00          	lea    (%rax,%r8,1),%r15
    7fc4:	4b 8d 44 0d 00       	lea    0x0(%r13,%r9,1),%rax
    7fc9:	4e 8d 2c 13          	lea    (%rbx,%r10,1),%r13
    7fcd:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    7fd1:	48 01 c3             	add    %rax,%rbx
    7fd4:	48 8d 04 19          	lea    (%rcx,%rbx,1),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7fd8:	f2 4c 0f 38 f1 d0    	crc32q %rax,%r10
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    7fde:	4a 8d 04 2a          	lea    (%rdx,%r13,1),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7fe2:	f2 48 0f 38 f1 f0    	crc32q %rax,%rsi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:567 (discriminator 1)
    7fe8:	4b 8d 04 3c          	lea    (%r12,%r15,1),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    7fec:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
    7ff0:	f2 4c 0f 38 f1 c8    	crc32q %rax,%r9
    7ff6:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
    7ffa:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    7ffe:	e8 6d fa ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    8003:	49 8d be 80 00 00 00 	lea    0x80(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    CHUNK(42); PERMUTE3(b, h, d);
    800a:	4d 8d 1c 07          	lea    (%r15,%rax,1),%r11
    800e:	4c 89 5d b8          	mov    %r11,-0x48(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8012:	e8 59 fa ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    8017:	48 03 45 c8          	add    -0x38(%rbp),%rax
    801b:	49 8d be 88 00 00 00 	lea    0x88(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    CHUNK(42); PERMUTE3(b, h, d);
    8022:	49 8d 54 05 00       	lea    0x0(%r13,%rax,1),%rdx
    8027:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    802b:	e8 40 fa ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    CHUNK(42); PERMUTE3(b, h, d);
    8030:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8034:	49 8d be 90 00 00 00 	lea    0x90(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    CHUNK(42); PERMUTE3(b, h, d);
    803b:	4c 8d 3c 01          	lea    (%rcx,%rax,1),%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    803f:	e8 2c fa ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    8044:	49 8d be 98 00 00 00 	lea    0x98(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    CHUNK(42); PERMUTE3(b, h, d);
    804b:	4d 8d 44 05 00       	lea    0x0(%r13,%rax,1),%r8
    8050:	4c 89 45 d0          	mov    %r8,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8054:	e8 17 fa ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    CHUNK(42); PERMUTE3(b, h, d);
    8059:	4c 8b 5d b8          	mov    -0x48(%rbp),%r11
    805d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    8061:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    8065:	4c 8b 45 d0          	mov    -0x30(%rbp),%r8
    8069:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
    806d:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
    8071:	4d 8d 2c 33          	lea    (%r11,%rsi,1),%r13
    8075:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    8079:	48 01 d0             	add    %rdx,%rax
    807c:	4b 8d 14 1c          	lea    (%r12,%r11,1),%rdx
    8080:	48 01 c1             	add    %rax,%rcx
    8083:	4d 8d 24 07          	lea    (%r15,%rax,1),%r12
    8087:	48 8d 3c 33          	lea    (%rbx,%rsi,1),%rdi
    808b:	4b 8d 1c 08          	lea    (%r8,%r9,1),%rbx
    808f:	49 01 f8             	add    %rdi,%r8
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8092:	49 8d be a0 00 00 00 	lea    0xa0(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    CHUNK(42); PERMUTE3(b, h, d);
    8099:	4b 8d 44 05 00       	lea    0x0(%r13,%r8,1),%rax
    809e:	4c 89 45 98          	mov    %r8,-0x68(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    80a2:	f2 4c 0f 38 f1 c8    	crc32q %rax,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    80a8:	48 8d 04 19          	lea    (%rcx,%rbx,1),%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    80ac:	48 c1 c3 16          	rol    $0x16,%rbx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    80b0:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    CHUNK(42); PERMUTE3(b, h, d);
    80b4:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    80b8:	4c 8b 55 90          	mov    -0x70(%rbp),%r10
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    80bc:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    80c0:	f2 4c 0f 38 f1 d0    	crc32q %rax,%r10
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:568 (discriminator 1)
    80c6:	4a 8d 04 22          	lea    (%rdx,%r12,1),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    80ca:	f2 48 0f 38 f1 f0    	crc32q %rax,%rsi
    80d0:	4c 89 55 a0          	mov    %r10,-0x60(%rbp)
    80d4:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    80d8:	e8 93 f9 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    80dd:	49 8d be a8 00 00 00 	lea    0xa8(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, e);
    80e4:	49 01 c7             	add    %rax,%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    80e7:	e8 84 f9 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    80ec:	48 03 45 c8          	add    -0x38(%rbp),%rax
    80f0:	49 8d be b0 00 00 00 	lea    0xb0(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, e);
    80f7:	48 01 d8             	add    %rbx,%rax
    80fa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    80fe:	e8 6d f9 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, e);
    8103:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8107:	49 8d be b8 00 00 00 	lea    0xb8(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, e);
    810e:	48 01 c1             	add    %rax,%rcx
    8111:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8115:	e8 56 f9 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    811a:	49 8d be c0 00 00 00 	lea    0xc0(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, e);
    8121:	48 8d 0c 18          	lea    (%rax,%rbx,1),%rcx
    8125:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8129:	e8 42 f9 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    812e:	4c 8b 55 a0          	mov    -0x60(%rbp),%r10
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, e);
    8132:	49 8d 1c 04          	lea    (%r12,%rax,1),%rbx
    8136:	4c 8b 45 98          	mov    -0x68(%rbp),%r8
    813a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    813e:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8142:	49 8d be c8 00 00 00 	lea    0xc8(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    CHUNK(0); PERMUTE3(b, h, e);
    8149:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    814d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
    8151:	4d 8d 64 1d 00       	lea    0x0(%r13,%rbx,1),%r12
    8156:	4d 01 d0             	add    %r10,%r8
    8159:	48 03 5d c8          	add    -0x38(%rbp),%rbx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    815d:	4c 8b 4d 88          	mov    -0x78(%rbp),%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    8161:	4d 8d 2c 07          	lea    (%r15,%rax,1),%r13
    8165:	49 01 c8             	add    %rcx,%r8
    8168:	4c 01 fa             	add    %r15,%rdx
    816b:	4c 8d 3c 31          	lea    (%rcx,%rsi,1),%r15
    816f:	4c 89 45 90          	mov    %r8,-0x70(%rbp)
    8173:	4b 8d 44 05 00       	lea    0x0(%r13,%r8,1),%rax
    8178:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    817c:	f2 48 0f 38 f1 f0    	crc32q %rax,%rsi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    8182:	4b 8d 04 3c          	lea    (%r12,%r15,1),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    8186:	f2 4c 0f 38 f1 c8    	crc32q %rax,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:569 (discriminator 1)
    818c:	48 8d 04 1a          	lea    (%rdx,%rbx,1),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    8190:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
    8194:	f2 4c 0f 38 f1 d0    	crc32q %rax,%r10
    819a:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
    819e:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    81a2:	e8 c9 f8 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    81a7:	49 8d be d0 00 00 00 	lea    0xd0(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, e);
    81ae:	4d 8d 1c 07          	lea    (%r15,%rax,1),%r11
    81b2:	4c 89 5d b8          	mov    %r11,-0x48(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    81b6:	e8 b5 f8 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    81bb:	48 03 45 d0          	add    -0x30(%rbp),%rax
    81bf:	49 8d be d8 00 00 00 	lea    0xd8(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, e);
    81c6:	49 01 c7             	add    %rax,%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    81c9:	e8 a2 f8 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, e);
    81ce:	48 03 45 c8          	add    -0x38(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    81d2:	49 8d be e0 00 00 00 	lea    0xe0(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, e);
    81d9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    81dd:	e8 8e f8 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    81e2:	49 8d be e8 00 00 00 	lea    0xe8(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, e);
    81e9:	49 01 c4             	add    %rax,%r12
    81ec:	49 81 c6 f0 00 00 00 	add    $0xf0,%r14
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    81f3:	e8 78 f8 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    81f8:	4c 8b 45 90          	mov    -0x70(%rbp),%r8
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, e);
    81fc:	4c 8b 5d b8          	mov    -0x48(%rbp),%r11
    8200:	48 01 c3             	add    %rax,%rbx
    8203:	4c 8b 4d a0          	mov    -0x60(%rbp),%r9
    8207:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
    820b:	49 01 dd             	add    %rbx,%r13
    820e:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    8212:	48 03 5d d0          	add    -0x30(%rbp),%rbx
    8216:	4d 01 e0             	add    %r12,%r8
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    8219:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    821d:	4c 01 da             	add    %r11,%rdx
    8220:	4d 01 c8             	add    %r9,%r8
    8223:	4d 01 fb             	add    %r15,%r11
    8226:	4b 8d 04 03          	lea    (%r11,%r8,1),%rax
    822a:	4b 8d 0c 14          	lea    (%r12,%r10,1),%rcx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    822e:	f2 4c 0f 38 f1 d0    	crc32q %rax,%r10
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    8234:	49 8d 44 0d 00       	lea    0x0(%r13,%rcx,1),%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8239:	48 c1 c1 1f          	rol    $0x1f,%rcx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    823d:	f2 48 0f 38 f1 f0    	crc32q %rax,%rsi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:570 (discriminator 1)
    CHUNK(33); PERMUTE3(a, h, e);
    8243:	48 8d 04 1a          	lea    (%rdx,%rbx,1),%rax
    8247:	4d 8d 24 0f          	lea    (%r15,%rcx,1),%r12
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    824b:	4c 89 55 c8          	mov    %r10,-0x38(%rbp)
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:571 (discriminator 1)
  } while (--iters > 0);
    824f:	48 83 6d 80 01       	subq   $0x1,-0x80(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848 (discriminator 1)
    8254:	f2 4c 0f 38 f1 c8    	crc32q %rax,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:571 (discriminator 1)
    825a:	0f 85 53 fb ff ff    	jne    7db3 <CityHashCrc256Long+0x153>
    8260:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    8267:	49 89 da             	mov    %rbx,%r10
    826a:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    826e:	4c 89 db             	mov    %r11,%rbx
    8271:	4d 89 c8             	mov    %r9,%r8
    8274:	49 89 f3             	mov    %rsi,%r11
    8277:	4c 89 ee             	mov    %r13,%rsi
    827a:	49 89 cd             	mov    %rcx,%r13
    827d:	48 89 d1             	mov    %rdx,%rcx
    8280:	49 89 c6             	mov    %rax,%r14
    8283:	49 c1 e6 04          	shl    $0x4,%r14
    8287:	49 29 c6             	sub    %rax,%r14
    828a:	49 c1 e6 04          	shl    $0x4,%r14
    828e:	4c 03 b5 78 ff ff ff 	add    -0x88(%rbp),%r14
/home/austen/programming/dm-afs/src/lib/city.c:573

  while (len >= 40) {
    8295:	48 83 7d c0 27       	cmpq   $0x27,-0x40(%rbp)
    829a:	0f 86 01 04 00 00    	jbe    86a1 <CityHashCrc256Long+0xa41>
    82a0:	49 89 f7             	mov    %rsi,%r15
    82a3:	4c 89 ee             	mov    %r13,%rsi
    82a6:	4d 89 d5             	mov    %r10,%r13
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    82a9:	4c 89 f7             	mov    %r14,%rdi
    82ac:	4c 89 5d 98          	mov    %r11,-0x68(%rbp)
    82b0:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    82b4:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
    82b8:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    82bc:	e8 af f7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    82c1:	49 8d 7e 08          	lea    0x8(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    CHUNK(29);
    82c5:	48 01 c3             	add    %rax,%rbx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    82c8:	e8 a3 f7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    82cd:	49 8d 7e 10          	lea    0x10(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    CHUNK(29);
    82d1:	49 01 c4             	add    %rax,%r12
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    82d4:	e8 97 f7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    82d9:	49 8d 7e 18          	lea    0x18(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    CHUNK(29);
    82dd:	48 01 45 d0          	add    %rax,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    82e1:	e8 8a f7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    82e6:	49 8d 7e 20          	lea    0x20(%r14),%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    CHUNK(29);
    82ea:	49 01 c7             	add    %rax,%r15
    82ed:	49 83 c6 28          	add    $0x28,%r14
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    82f1:	e8 7a f7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    CHUNK(29);
    82f6:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    82fa:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    82fe:	4a 8d 3c 28          	lea    (%rax,%r13,1),%rdi
    8302:	4c 8b 5d 98          	mov    -0x68(%rbp),%r11
    8306:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    830a:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
/home/austen/programming/dm-afs/src/lib/city.c:580
    e ^= Rotate(a, 20);
    h += Rotate(b, 30);
    g ^= Rotate(c, 40);
    f += Rotate(d, 34);
    PERMUTE3(c, h, g);
    len -= 40;
    830e:	48 83 6d c0 28       	subq   $0x28,-0x40(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:574
    CHUNK(29);
    8313:	4c 8d 14 0f          	lea    (%rdi,%rcx,1),%r10
    8317:	4b 8d 0c 07          	lea    (%r15,%r8,1),%rcx
    831b:	48 03 7d d0          	add    -0x30(%rbp),%rdi
    831f:	4d 01 df             	add    %r11,%r15
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    8322:	4d 89 c1             	mov    %r8,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    8325:	4c 01 fa             	add    %r15,%rdx
    8328:	48 01 de             	add    %rbx,%rsi
    832b:	4c 01 e3             	add    %r12,%rbx
    832e:	48 8d 04 13          	lea    (%rbx,%rdx,1),%rax
    8332:	49 89 d5             	mov    %rdx,%r13
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    8335:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    8339:	f2 4c 0f 38 f1 c8    	crc32q %rax,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    833f:	49 8d 04 0a          	lea    (%r10,%rcx,1),%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8343:	48 c1 c9 1d          	ror    $0x1d,%rcx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    8347:	f2 48 0f 38 f1 d0    	crc32q %rax,%rdx
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    CHUNK(29);
    834d:	48 8d 04 3e          	lea    (%rsi,%rdi,1),%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8351:	49 89 cf             	mov    %rcx,%r15
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:574
    CHUNK(29);
    8354:	49 8d 0c 0c          	lea    (%r12,%rcx,1),%rcx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    8358:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
    835c:	f2 4c 0f 38 f1 d8    	crc32q %rax,%r11
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8362:	48 89 f0             	mov    %rsi,%rax
    8365:	48 c1 c8 14          	ror    $0x14,%rax
    8369:	49 89 cc             	mov    %rcx,%r12
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:575
    e ^= Rotate(a, 20);
    836c:	49 31 c7             	xor    %rax,%r15
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    836f:	49 c1 c4 18          	rol    $0x18,%r12
    8373:	48 89 d8             	mov    %rbx,%rax
    8376:	48 c1 c8 1e          	ror    $0x1e,%rax
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:577
    g ^= Rotate(c, 40);
    837a:	4d 31 ec             	xor    %r13,%r12
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    837d:	4c 8b 6d d0          	mov    -0x30(%rbp),%r13
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:576
    h += Rotate(b, 30);
    8381:	49 01 c2             	add    %rax,%r10
/home/austen/programming/dm-afs/src/lib/city.c:580
    len -= 40;
    8384:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    8388:	4d 89 d8             	mov    %r11,%r8
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:576
    h += Rotate(b, 30);
    838b:	4c 89 55 b8          	mov    %r10,-0x48(%rbp)
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    838f:	49 89 d3             	mov    %rdx,%r11
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8392:	49 c1 c5 1e          	rol    $0x1e,%r13
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:578
    f += Rotate(d, 34);
    8396:	49 01 fd             	add    %rdi,%r13
/home/austen/programming/dm-afs/src/lib/city.c:573
  while (len >= 40) {
    8399:	48 83 f8 27          	cmp    $0x27,%rax
    839d:	0f 87 06 ff ff ff    	ja     82a9 <CityHashCrc256Long+0x649>
    83a3:	4d 89 ea             	mov    %r13,%r10
    83a6:	49 89 f5             	mov    %rsi,%r13
    83a9:	4c 89 fe             	mov    %r15,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:582
  }
  if (len > 0) {
    83ac:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
    83b1:	0f 84 fb 00 00 00    	je     84b2 <CityHashCrc256Long+0x852>
/home/austen/programming/dm-afs/src/lib/city.c:583
    s = s + len - 40;
    83b7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    83bb:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
    83bf:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    83c3:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    83c7:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
    83cb:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    83cf:	4d 8d 74 06 d8       	lea    -0x28(%r14,%rax,1),%r14
    83d4:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    83d8:	4c 89 f7             	mov    %r14,%rdi
    83db:	e8 90 f6 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    83e0:	49 8d 7e 08          	lea    0x8(%r14),%rdi
    83e4:	48 01 c3             	add    %rax,%rbx
    83e7:	49 01 dd             	add    %rbx,%r13
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    83ea:	e8 81 f6 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    83ef:	49 8d 7e 10          	lea    0x10(%r14),%rdi
    83f3:	4d 8d 3c 04          	lea    (%r12,%rax,1),%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    83f7:	e8 74 f6 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    83fc:	49 8d 7e 18          	lea    0x18(%r14),%rdi
    8400:	48 01 45 d0          	add    %rax,-0x30(%rbp)
    8404:	4c 01 fb             	add    %r15,%rbx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8407:	e8 64 f6 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    840c:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    8410:	49 8d 7e 20          	lea    0x20(%r14),%rdi
    8414:	4c 8d 24 30          	lea    (%rax,%rsi,1),%r12
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8418:	e8 53 f6 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    841d:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
    8421:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    8425:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    8429:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
    842d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    8431:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    8435:	49 01 c2             	add    %rax,%r10
    8438:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    843c:	49 01 d6             	add    %rdx,%r14
    843f:	4b 8d 34 04          	lea    (%r12,%r8,1),%rsi
    8443:	4d 01 e6             	add    %r12,%r14
    8446:	4c 01 d1             	add    %r10,%rcx
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    8449:	4d 89 cb             	mov    %r9,%r11
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    844c:	4a 8d 3c 10          	lea    (%rax,%r10,1),%rdi
    8450:	4a 8d 04 33          	lea    (%rbx,%r14,1),%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8454:	4c 8b 55 d0          	mov    -0x30(%rbp),%r10
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    8458:	f2 4c 0f 38 f1 c0    	crc32q %rax,%r8
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    845e:	48 8d 04 31          	lea    (%rcx,%rsi,1),%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8462:	48 c1 c6 1f          	rol    $0x1f,%rsi
    8466:	49 c1 c2 18          	rol    $0x18,%r10
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    846a:	4d 8d 24 37          	lea    (%r15,%rsi,1),%r12
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    846e:	f2 4c 0f 38 f1 d8    	crc32q %rax,%r11
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8474:	4d 89 ef             	mov    %r13,%r15
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    8477:	49 8d 44 3d 00       	lea    0x0(%r13,%rdi,1),%rax
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    847c:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8480:	49 c1 c7 15          	rol    $0x15,%r15
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    8484:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
/home/austen/programming/dm-afs/src/lib/city.c:588
    e ^= Rotate(a, 43);
    h += Rotate(b, 42);
    g ^= Rotate(c, 41);
    f += Rotate(d, 40);
    8488:	49 01 fa             	add    %rdi,%r10
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    848b:	f2 48 0f 38 f1 d0    	crc32q %rax,%rdx
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:585
    e ^= Rotate(a, 43);
    8491:	4c 31 fe             	xor    %r15,%rsi
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8494:	4d 89 e7             	mov    %r12,%r15
    8497:	48 89 d8             	mov    %rbx,%rax
    849a:	49 c1 c7 17          	rol    $0x17,%r15
    849e:	48 c1 c0 16          	rol    $0x16,%rax
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:587
    g ^= Rotate(c, 41);
    84a2:	4d 31 f7             	xor    %r14,%r15
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    84a5:	49 89 d0             	mov    %rdx,%r8
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:586
    h += Rotate(b, 42);
    84a8:	48 01 c1             	add    %rax,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:587
    g ^= Rotate(c, 41);
    84ab:	4c 89 7d b8          	mov    %r15,-0x48(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:584
    CHUNK(33);
    84af:	4c 89 da             	mov    %r11,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:592
  }
  result[0] ^= h;
  result[1] ^= g;
  g += h;
    84b2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    84b6:	48 bf 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rdi
    84bd:	ea df 9d 
    84c0:	4d 31 cc             	xor    %r9,%r12
    84c3:	4c 0f af e7          	imul   %rdi,%r12
    84c7:	4d 89 ef             	mov    %r13,%r15
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:594
  a = HashLen16(a, g + z);
  x += y << 32;
    84ca:	48 c1 e2 20          	shl    $0x20,%rdx
    84ce:	4c 01 c2             	add    %r8,%rdx
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    84d1:	4c 8b 75 d0          	mov    -0x30(%rbp),%r14
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:592
  g += h;
    84d5:	48 01 c8             	add    %rcx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:593
  a = HashLen16(a, g + z);
    84d8:	4d 8d 1c 01          	lea    (%r9,%rax,1),%r11
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    84dc:	4d 89 e0             	mov    %r12,%r8
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    84df:	4d 31 cc             	xor    %r9,%r12
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    84e2:	4d 31 df             	xor    %r11,%r15
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    84e5:	49 c1 e8 2f          	shr    $0x2f,%r8
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    84e9:	4c 0f af ff          	imul   %rdi,%r15
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    84ed:	4d 31 c4             	xor    %r8,%r12
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:590
  result[0] ^= h;
    84f0:	4c 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%r8
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    84f7:	4c 0f af e7          	imul   %rdi,%r12
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:590
  result[0] ^= h;
    84fb:	49 31 c8             	xor    %rcx,%r8
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    84fe:	4d 89 fd             	mov    %r15,%r13
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8501:	4d 31 df             	xor    %r11,%r15
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:597
  b += x;
  c = HashLen16(c, z) + h;
  d = HashLen16(d, e + result[0]);
    8504:	49 01 f0             	add    %rsi,%r8
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8507:	49 c1 ed 2f          	shr    $0x2f,%r13
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    850b:	4d 31 c6             	xor    %r8,%r14
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    850e:	4d 89 e1             	mov    %r12,%r9
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8511:	4d 31 fd             	xor    %r15,%r13
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8514:	49 c1 e9 2f          	shr    $0x2f,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:598
  g += e;
    8518:	4c 8d 3c 06          	lea    (%rsi,%rax,1),%r15
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    851c:	4c 0f af ef          	imul   %rdi,%r13
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8520:	4d 31 cc             	xor    %r9,%r12
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:603
  h += HashLen16(x, f);
  e = HashLen16(a, d) + g;
  z = HashLen16(b, c) + a;
  y = HashLen16(g, h) + c;
  result[0] = e + z + y + x;
    8523:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    852a:	4c 0f af f7          	imul   %rdi,%r14
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    852e:	4c 0f af e7          	imul   %rdi,%r12
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8532:	4d 89 eb             	mov    %r13,%r11
    8535:	49 c1 eb 2f          	shr    $0x2f,%r11
    8539:	4d 31 dd             	xor    %r11,%r13
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:595
  b += x;
    853c:	4c 8d 1c 13          	lea    (%rbx,%rdx,1),%r11
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8540:	4c 89 f3             	mov    %r14,%rbx
    8543:	48 c1 eb 2f          	shr    $0x2f,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8547:	4d 31 c6             	xor    %r8,%r14
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:596
  c = HashLen16(c, z) + h;
    854a:	4d 8d 0c 0c          	lea    (%r12,%rcx,1),%r9
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    854e:	4c 31 f3             	xor    %r14,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    8551:	4d 89 d4             	mov    %r10,%r12
    8554:	4c 89 d8             	mov    %r11,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8557:	48 0f af df          	imul   %rdi,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    855b:	4c 0f af ef          	imul   %rdi,%r13
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    855f:	49 89 de             	mov    %rbx,%r14
    8562:	49 c1 ee 2f          	shr    $0x2f,%r14
    8566:	49 31 de             	xor    %rbx,%r14
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    8569:	4c 0f af f7          	imul   %rdi,%r14
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    856d:	49 31 d4             	xor    %rdx,%r12
    8570:	4c 31 c8             	xor    %r9,%rax
    8573:	4c 0f af e7          	imul   %rdi,%r12
    8577:	48 0f af c7          	imul   %rdi,%rax
    857b:	4c 89 f3             	mov    %r14,%rbx
    857e:	4c 31 eb             	xor    %r13,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8581:	4d 89 e0             	mov    %r12,%r8
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8584:	4d 31 e2             	xor    %r12,%r10
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    8587:	48 0f af df          	imul   %rdi,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    858b:	49 c1 e8 2f          	shr    $0x2f,%r8
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    858f:	4d 31 c2             	xor    %r8,%r10
    8592:	4c 0f af d7          	imul   %rdi,%r10
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8596:	49 89 dc             	mov    %rbx,%r12
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8599:	49 31 de             	xor    %rbx,%r14
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    859c:	49 c1 ec 2f          	shr    $0x2f,%r12
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    85a0:	4d 31 e6             	xor    %r12,%r14
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    85a3:	4d 89 d0             	mov    %r10,%r8
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    85a6:	4c 0f af f7          	imul   %rdi,%r14
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    85aa:	49 c1 e8 2f          	shr    $0x2f,%r8
    85ae:	4d 31 c2             	xor    %r8,%r10
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    85b1:	4c 0f af d7          	imul   %rdi,%r10
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    85b5:	4d 89 f4             	mov    %r14,%r12
    85b8:	49 c1 ec 2f          	shr    $0x2f,%r12
    85bc:	4d 31 e6             	xor    %r12,%r14
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:599
  h += HashLen16(x, f);
    85bf:	4d 8d 04 0a          	lea    (%r10,%rcx,1),%r8
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    85c3:	4c 0f af f7          	imul   %rdi,%r14
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:600
  e = HashLen16(a, d) + g;
    85c7:	4f 8d 24 3e          	lea    (%r14,%r15,1),%r12
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    85cb:	4d 31 c7             	xor    %r8,%r15
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    85ce:	49 89 c6             	mov    %rax,%r14
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    85d1:	4c 0f af ff          	imul   %rdi,%r15
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    85d5:	4c 31 c8             	xor    %r9,%rax
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    85d8:	49 c1 ee 2f          	shr    $0x2f,%r14
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    85dc:	49 31 c6             	xor    %rax,%r14
    85df:	4c 0f af f7          	imul   %rdi,%r14
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    85e3:	4c 89 fb             	mov    %r15,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    85e6:	4d 31 f8             	xor    %r15,%r8
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:591
  result[1] ^= g;
    85e9:	4c 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%r15
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    85f0:	48 c1 eb 2f          	shr    $0x2f,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    85f4:	4c 31 c3             	xor    %r8,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    85f7:	4c 89 f0             	mov    %r14,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    85fa:	48 0f af df          	imul   %rdi,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    85fe:	48 c1 e8 2f          	shr    $0x2f,%rax
    8602:	49 31 c6             	xor    %rax,%r14
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:603
  result[0] = e + z + y + x;
    8605:	4a 8d 04 2a          	lea    (%rdx,%r13,1),%rax
/home/austen/programming/dm-afs/src/lib/city.c:604
  a = ShiftMix((a + y) * k0) * k0 + b;
    8609:	48 ba 27 31 cb 97 5c 	movabs $0xc3a5c85c97cb3127,%rdx
    8610:	c8 a5 c3 
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8613:	48 89 d9             	mov    %rbx,%rcx
    8616:	48 c1 e9 2f          	shr    $0x2f,%rcx
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:591
  result[1] ^= g;
    861a:	4c 33 7d b8          	xor    -0x48(%rbp),%r15
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    861e:	48 31 cb             	xor    %rcx,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    8621:	48 0f af df          	imul   %rdi,%rbx
    8625:	49 0f af fe          	imul   %r14,%rdi
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:602
  y = HashLen16(g, h) + c;
    8629:	4c 01 cb             	add    %r9,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:603
  result[0] = e + z + y + x;
    862c:	48 01 f8             	add    %rdi,%rax
    862f:	4c 01 e0             	add    %r12,%rax
    8632:	48 01 d8             	add    %rbx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:604
  a = ShiftMix((a + y) * k0) * k0 + b;
    8635:	4c 01 eb             	add    %r13,%rbx
    8638:	48 0f af da          	imul   %rdx,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:603
  result[0] = e + z + y + x;
    863c:	48 89 06             	mov    %rax,(%rsi)
/home/austen/programming/dm-afs/src/lib/city.c:605
  result[1] += a + result[0];
    863f:	4c 01 f8             	add    %r15,%rax
/home/austen/programming/dm-afs/src/lib/city.c:604
  a = ShiftMix((a + y) * k0) * k0 + b;
    8642:	49 89 dd             	mov    %rbx,%r13
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    8645:	48 c1 eb 2f          	shr    $0x2f,%rbx
    8649:	4c 31 eb             	xor    %r13,%rbx
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:604
  a = ShiftMix((a + y) * k0) * k0 + b;
    864c:	48 0f af da          	imul   %rdx,%rbx
    8650:	4c 01 db             	add    %r11,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:605
  result[1] += a + result[0];
    8653:	48 01 d8             	add    %rbx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:606
  a = ShiftMix(a * k0) * k0 + c;
    8656:	48 0f af da          	imul   %rdx,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:605
  result[1] += a + result[0];
    865a:	48 89 46 08          	mov    %rax,0x8(%rsi)
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    865e:	49 89 db             	mov    %rbx,%r11
    8661:	49 c1 eb 2f          	shr    $0x2f,%r11
    8665:	4c 31 db             	xor    %r11,%rbx
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:606
  a = ShiftMix(a * k0) * k0 + c;
    8668:	48 0f af da          	imul   %rdx,%rbx
    866c:	49 01 d9             	add    %rbx,%r9
/home/austen/programming/dm-afs/src/lib/city.c:607
  result[2] = a + result[1];
    866f:	4c 01 c8             	add    %r9,%rax
/home/austen/programming/dm-afs/src/lib/city.c:608
  a = ShiftMix((a + e) * k0) * k0;
    8672:	4d 01 e1             	add    %r12,%r9
    8675:	4c 0f af ca          	imul   %rdx,%r9
/home/austen/programming/dm-afs/src/lib/city.c:607
  result[2] = a + result[1];
    8679:	48 89 46 10          	mov    %rax,0x10(%rsi)
/home/austen/programming/dm-afs/src/lib/city.c:608
  a = ShiftMix((a + e) * k0) * k0;
    867d:	4d 89 cc             	mov    %r9,%r12
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    8680:	49 c1 e9 2f          	shr    $0x2f,%r9
    8684:	4d 31 e1             	xor    %r12,%r9
CityHashCrc256Long():
/home/austen/programming/dm-afs/src/lib/city.c:608
  a = ShiftMix((a + e) * k0) * k0;
    8687:	49 0f af d1          	imul   %r9,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:609
  result[3] = a + result[2];
    868b:	48 01 d0             	add    %rdx,%rax
    868e:	48 89 46 18          	mov    %rax,0x18(%rsi)
/home/austen/programming/dm-afs/src/lib/city.c:610
}
    8692:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
    8696:	5b                   	pop    %rbx
    8697:	41 5c                	pop    %r12
    8699:	41 5d                	pop    %r13
    869b:	41 5e                	pop    %r14
    869d:	41 5f                	pop    %r15
    869f:	5d                   	pop    %rbp
    86a0:	c3                   	retq   
_mm_crc32_u64():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    86a1:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
    86a5:	4c 89 da             	mov    %r11,%rdx
    86a8:	e9 ff fc ff ff       	jmpq   83ac <CityHashCrc256Long+0x74c>
CityHashCrc256Long():
/usr/lib/gcc/x86_64-linux-gnu/7/include/smmintrin.h:848
    86ad:	0f 1f 00             	nopl   (%rax)

00000000000086b0 <CityHashCrc256Short>:
CityHashCrc256Short():
/home/austen/programming/dm-afs/src/lib/city.c:613

// Requires len < 240.
static void CityHashCrc256Short(const uint8_t *s, size_t len, uint64_t *result) {
    86b0:	e8 00 00 00 00       	callq  86b5 <CityHashCrc256Short+0x5>
			86b1: R_X86_64_PC32	__fentry__-0x4
    86b5:	55                   	push   %rbp
    86b6:	48 89 e5             	mov    %rsp,%rbp
    86b9:	41 54                	push   %r12
    86bb:	53                   	push   %rbx
    86bc:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
    86c3:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    86ca:	00 00 
    86cc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    86d0:	31 c0                	xor    %eax,%eax
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:342
    86d2:	48 81 fe f0 00 00 00 	cmp    $0xf0,%rsi
    86d9:	0f 87 c0 00 00 00    	ja     879f <CityHashCrc256Short+0xef>
    86df:	49 89 f4             	mov    %rsi,%r12
    86e2:	48 89 d3             	mov    %rdx,%rbx
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    86e5:	48 89 f2             	mov    %rsi,%rdx
    86e8:	48 89 fe             	mov    %rdi,%rsi
    86eb:	48 8d bd f0 fe ff ff 	lea    -0x110(%rbp),%rdi
    86f2:	e8 00 00 00 00       	callq  86f7 <CityHashCrc256Short+0x47>
			86f3: R_X86_64_PC32	memcpy-0x4
CityHashCrc256Short():
/home/austen/programming/dm-afs/src/lib/city.c:616
  char buf[240];
  memcpy(buf, s, len);
  memset(buf + len, 0, 240 - len);
    86f7:	b9 f0 00 00 00       	mov    $0xf0,%ecx
    86fc:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
    8703:	4c 29 e1             	sub    %r12,%rcx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    8706:	83 f9 08             	cmp    $0x8,%ecx
CityHashCrc256Short():
/home/austen/programming/dm-afs/src/lib/city.c:616
    8709:	4a 8d 14 20          	lea    (%rax,%r12,1),%rdx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    870d:	73 45                	jae    8754 <CityHashCrc256Short+0xa4>
    870f:	f6 c1 04             	test   $0x4,%cl
    8712:	75 69                	jne    877d <CityHashCrc256Short+0xcd>
    8714:	85 c9                	test   %ecx,%ecx
    8716:	74 08                	je     8720 <CityHashCrc256Short+0x70>
    8718:	f6 c1 02             	test   $0x2,%cl
    871b:	c6 02 00             	movb   $0x0,(%rdx)
    871e:	75 6f                	jne    878f <CityHashCrc256Short+0xdf>
CityHashCrc256Short():
/home/austen/programming/dm-afs/src/lib/city.c:617
  CityHashCrc256Long(buf, 240, ~(uint32_t)(len), result);
    8720:	44 89 e2             	mov    %r12d,%edx
    8723:	48 8d bd f0 fe ff ff 	lea    -0x110(%rbp),%rdi
    872a:	48 89 d9             	mov    %rbx,%rcx
    872d:	f7 d2                	not    %edx
    872f:	be f0 00 00 00       	mov    $0xf0,%esi
    8734:	e8 27 f5 ff ff       	callq  7c60 <CityHashCrc256Long>
/home/austen/programming/dm-afs/src/lib/city.c:618
}
    8739:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    873d:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    8744:	00 00 
    8746:	75 52                	jne    879a <CityHashCrc256Short+0xea>
    8748:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
    874f:	5b                   	pop    %rbx
    8750:	41 5c                	pop    %r12
    8752:	5d                   	pop    %rbp
    8753:	c3                   	retq   
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    8754:	48 8d 7a 08          	lea    0x8(%rdx),%rdi
    8758:	89 c8                	mov    %ecx,%eax
    875a:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    8761:	48 c7 44 02 f8 00 00 	movq   $0x0,-0x8(%rdx,%rax,1)
    8768:	00 00 
    876a:	31 c0                	xor    %eax,%eax
    876c:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    8770:	48 29 fa             	sub    %rdi,%rdx
    8773:	01 d1                	add    %edx,%ecx
    8775:	c1 e9 03             	shr    $0x3,%ecx
    8778:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    877b:	eb a3                	jmp    8720 <CityHashCrc256Short+0x70>
    877d:	89 c8                	mov    %ecx,%eax
    877f:	c7 02 00 00 00 00    	movl   $0x0,(%rdx)
    8785:	c7 44 02 fc 00 00 00 	movl   $0x0,-0x4(%rdx,%rax,1)
    878c:	00 
    878d:	eb 91                	jmp    8720 <CityHashCrc256Short+0x70>
    878f:	89 c8                	mov    %ecx,%eax
    8791:	31 c9                	xor    %ecx,%ecx
    8793:	66 89 4c 02 fe       	mov    %cx,-0x2(%rdx,%rax,1)
    8798:	eb 86                	jmp    8720 <CityHashCrc256Short+0x70>
CityHashCrc256Short():
/home/austen/programming/dm-afs/src/lib/city.c:618
    879a:	e8 00 00 00 00       	callq  879f <CityHashCrc256Short+0xef>
			879b: R_X86_64_PC32	__stack_chk_fail-0x4
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:343
    879f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			87a2: R_X86_64_32S	.rodata+0x25e0
    87a6:	e8 00 00 00 00       	callq  87ab <CityHashCrc256Short+0xfb>
			87a7: R_X86_64_PC32	fortify_panic-0x4
CityHashCrc256Short():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:343
    87ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000087b0 <Hash128to64>:
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    87b0:	48 b9 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rcx
    87b7:	ea df 9d 
    87ba:	48 31 f7             	xor    %rsi,%rdi
/home/austen/programming/dm-afs/src/lib/city.c:83
inline uint64_t Hash128to64(const uint128 x) {
    87bd:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    87be:	48 0f af f9          	imul   %rcx,%rdi
/home/austen/programming/dm-afs/src/lib/city.c:83
inline uint64_t Hash128to64(const uint128 x) {
    87c2:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/city.c:94
}
    87c5:	5d                   	pop    %rbp
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    87c6:	48 89 fa             	mov    %rdi,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    87c9:	48 31 fe             	xor    %rdi,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    87cc:	48 c1 ea 2f          	shr    $0x2f,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    87d0:	48 31 d6             	xor    %rdx,%rsi
    87d3:	48 0f af f1          	imul   %rcx,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    87d7:	48 89 f0             	mov    %rsi,%rax
    87da:	48 c1 e8 2f          	shr    $0x2f,%rax
    87de:	48 31 c6             	xor    %rax,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    87e1:	48 89 f0             	mov    %rsi,%rax
    87e4:	48 0f af c1          	imul   %rcx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:94
}
    87e8:	c3                   	retq   
    87e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000087f0 <CityHash32>:
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:174
uint32_t CityHash32(const uint8_t *s, size_t len) {
    87f0:	e8 00 00 00 00       	callq  87f5 <CityHash32+0x5>
			87f1: R_X86_64_PC32	__fentry__-0x4
    87f5:	55                   	push   %rbp
    87f6:	48 89 e5             	mov    %rsp,%rbp
    87f9:	41 57                	push   %r15
    87fb:	41 56                	push   %r14
    87fd:	41 55                	push   %r13
    87ff:	41 54                	push   %r12
    8801:	53                   	push   %rbx
    8802:	48 89 fb             	mov    %rdi,%rbx
    8805:	48 83 ec 20          	sub    $0x20,%rsp
/home/austen/programming/dm-afs/src/lib/city.c:177
  if (len <= 24) {
    8809:	48 83 fe 18          	cmp    $0x18,%rsi
    880d:	0f 87 a4 00 00 00    	ja     88b7 <CityHash32+0xc7>
/home/austen/programming/dm-afs/src/lib/city.c:179
        (len <= 4 ? Hash32Len0to4(s, len) : Hash32Len5to12(s, len)) :
    8813:	48 83 fe 0c          	cmp    $0xc,%rsi
    8817:	0f 87 fb 02 00 00    	ja     8b18 <CityHash32+0x328>
/home/austen/programming/dm-afs/src/lib/city.c:179 (discriminator 1)
    881d:	48 83 fe 04          	cmp    $0x4,%rsi
    8821:	0f 87 02 04 00 00    	ja     8c29 <CityHash32+0x439>
Hash32Len0to4():
/home/austen/programming/dm-afs/src/lib/city.c:158
  for (i = 0; i < len; i++) {
    8827:	48 85 f6             	test   %rsi,%rsi
    882a:	0f 84 86 04 00 00    	je     8cb6 <CityHash32+0x4c6>
    8830:	48 8d 3c 37          	lea    (%rdi,%rsi,1),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:156
  uint32_t c = 9;
    8834:	b9 09 00 00 00       	mov    $0x9,%ecx
/home/austen/programming/dm-afs/src/lib/city.c:155
  uint32_t b = 0;
    8839:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/city.c:160
    b = b * c1 + v;
    883b:	0f be 13             	movsbl (%rbx),%edx
    883e:	48 83 c3 01          	add    $0x1,%rbx
    8842:	69 c0 51 2d 9e cc    	imul   $0xcc9e2d51,%eax,%eax
    8848:	01 d0                	add    %edx,%eax
/home/austen/programming/dm-afs/src/lib/city.c:161
    c ^= b;
    884a:	31 c1                	xor    %eax,%ecx
/home/austen/programming/dm-afs/src/lib/city.c:158
  for (i = 0; i < len; i++) {
    884c:	48 39 df             	cmp    %rbx,%rdi
    884f:	75 ea                	jne    883b <CityHash32+0x4b>
    8851:	69 c0 51 2d 9e cc    	imul   $0xcc9e2d51,%eax,%eax
    8857:	c1 c0 0f             	rol    $0xf,%eax
    885a:	69 c0 93 35 87 1b    	imul   $0x1b873593,%eax,%eax
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8860:	69 f6 51 2d 9e cc    	imul   $0xcc9e2d51,%esi,%esi
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8866:	c1 c6 0f             	rol    $0xf,%esi
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8869:	69 f6 93 35 87 1b    	imul   $0x1b873593,%esi,%esi
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    886f:	31 f1                	xor    %esi,%ecx
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8871:	c1 c1 0d             	rol    $0xd,%ecx
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8874:	8d 94 89 64 6b 54 e6 	lea    -0x19ab949c(%rcx,%rcx,4),%edx
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    887b:	31 d0                	xor    %edx,%eax
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    887d:	48 83 c4 20          	add    $0x20,%rsp
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8881:	c1 c0 0d             	rol    $0xd,%eax
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8884:	8d 94 80 64 6b 54 e6 	lea    -0x19ab949c(%rax,%rax,4),%edx
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    888b:	5b                   	pop    %rbx
fmix():
/home/austen/programming/dm-afs/src/lib/city.c:116
  h ^= h >> 16;
    888c:	89 d0                	mov    %edx,%eax
    888e:	c1 e8 10             	shr    $0x10,%eax
    8891:	31 d0                	xor    %edx,%eax
/home/austen/programming/dm-afs/src/lib/city.c:117
  h *= 0x85ebca6b;
    8893:	69 c0 6b ca eb 85    	imul   $0x85ebca6b,%eax,%eax
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    8899:	41 5c                	pop    %r12
    889b:	41 5d                	pop    %r13
fmix():
/home/austen/programming/dm-afs/src/lib/city.c:118
  h ^= h >> 13;
    889d:	89 c2                	mov    %eax,%edx
    889f:	c1 ea 0d             	shr    $0xd,%edx
    88a2:	31 d0                	xor    %edx,%eax
/home/austen/programming/dm-afs/src/lib/city.c:119
  h *= 0xc2b2ae35;
    88a4:	69 c0 35 ae b2 c2    	imul   $0xc2b2ae35,%eax,%eax
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    88aa:	41 5e                	pop    %r14
    88ac:	41 5f                	pop    %r15
fmix():
/home/austen/programming/dm-afs/src/lib/city.c:120
  h ^= h >> 16;
    88ae:	89 c2                	mov    %eax,%edx
    88b0:	c1 ea 10             	shr    $0x10,%edx
    88b3:	31 d0                	xor    %edx,%eax
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    88b5:	5d                   	pop    %rbp
    88b6:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/city.c:184
  h = len, g = c1 * len, f = g;
    88b7:	69 d6 51 2d 9e cc    	imul   $0xcc9e2d51,%esi,%edx
/home/austen/programming/dm-afs/src/lib/city.c:185
  a0 = Rotate32(Fetch32(s + len - 4) * c1, 17) * c2;
    88bd:	48 8d 7c 37 fc       	lea    -0x4(%rdi,%rsi,1),%rdi
    88c2:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:184
  h = len, g = c1 * len, f = g;
    88c6:	89 55 c8             	mov    %edx,-0x38(%rbp)
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    88c9:	e8 42 f2 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:186
  a1 = Rotate32(Fetch32(s + len - 8) * c1, 17) * c2;
    88ce:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    88d2:	41 89 c7             	mov    %eax,%r15d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:185
  a0 = Rotate32(Fetch32(s + len - 4) * c1, 17) * c2;
    88d5:	45 69 ff 51 2d 9e cc 	imul   $0xcc9e2d51,%r15d,%r15d
/home/austen/programming/dm-afs/src/lib/city.c:186
  a1 = Rotate32(Fetch32(s + len - 8) * c1, 17) * c2;
    88dc:	48 8d 7c 33 f8       	lea    -0x8(%rbx,%rsi,1),%rdi
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    88e1:	41 c1 c7 0f          	rol    $0xf,%r15d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    88e5:	e8 26 f2 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:187
  a2 = Rotate32(Fetch32(s + len - 16) * c1, 17) * c2;
    88ea:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    88ee:	41 89 c5             	mov    %eax,%r13d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:186
  a1 = Rotate32(Fetch32(s + len - 8) * c1, 17) * c2;
    88f1:	45 69 ed 51 2d 9e cc 	imul   $0xcc9e2d51,%r13d,%r13d
/home/austen/programming/dm-afs/src/lib/city.c:185
  a0 = Rotate32(Fetch32(s + len - 4) * c1, 17) * c2;
    88f8:	45 69 ff 93 35 87 1b 	imul   $0x1b873593,%r15d,%r15d
/home/austen/programming/dm-afs/src/lib/city.c:187
  a2 = Rotate32(Fetch32(s + len - 16) * c1, 17) * c2;
    88ff:	48 8d 7c 33 f0       	lea    -0x10(%rbx,%rsi,1),%rdi
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8904:	41 c1 c5 0f          	rol    $0xf,%r13d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8908:	e8 03 f2 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:188
  a3 = Rotate32(Fetch32(s + len - 12) * c1, 17) * c2;
    890d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8911:	41 89 c6             	mov    %eax,%r14d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:187
  a2 = Rotate32(Fetch32(s + len - 16) * c1, 17) * c2;
    8914:	45 69 f6 51 2d 9e cc 	imul   $0xcc9e2d51,%r14d,%r14d
/home/austen/programming/dm-afs/src/lib/city.c:186
  a1 = Rotate32(Fetch32(s + len - 8) * c1, 17) * c2;
    891b:	45 69 ed 93 35 87 1b 	imul   $0x1b873593,%r13d,%r13d
/home/austen/programming/dm-afs/src/lib/city.c:188
  a3 = Rotate32(Fetch32(s + len - 12) * c1, 17) * c2;
    8922:	48 8d 7c 33 f4       	lea    -0xc(%rbx,%rsi,1),%rdi
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8927:	41 c1 c6 0f          	rol    $0xf,%r14d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    892b:	e8 e0 f1 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:189
  a4 = Rotate32(Fetch32(s + len - 20) * c1, 17) * c2;
    8930:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8934:	41 89 c4             	mov    %eax,%r12d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:187
  a2 = Rotate32(Fetch32(s + len - 16) * c1, 17) * c2;
    8937:	45 69 f6 93 35 87 1b 	imul   $0x1b873593,%r14d,%r14d
/home/austen/programming/dm-afs/src/lib/city.c:188
  a3 = Rotate32(Fetch32(s + len - 12) * c1, 17) * c2;
    893e:	45 69 e4 51 2d 9e cc 	imul   $0xcc9e2d51,%r12d,%r12d
/home/austen/programming/dm-afs/src/lib/city.c:189
  a4 = Rotate32(Fetch32(s + len - 20) * c1, 17) * c2;
    8945:	48 8d 7c 33 ec       	lea    -0x14(%rbx,%rsi,1),%rdi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    894a:	e8 c1 f1 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:189
  a4 = Rotate32(Fetch32(s + len - 20) * c1, 17) * c2;
    894f:	69 c0 51 2d 9e cc    	imul   $0xcc9e2d51,%eax,%eax
/home/austen/programming/dm-afs/src/lib/city.c:190
  h ^= a0;
    8955:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
/home/austen/programming/dm-afs/src/lib/city.c:196
  g ^= a1;
    8959:	8b 55 c8             	mov    -0x38(%rbp),%edx
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    895c:	41 c1 c4 0f          	rol    $0xf,%r12d
    8960:	c1 c0 0f             	rol    $0xf,%eax
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:190
  h ^= a0;
    8963:	41 31 f7             	xor    %esi,%r15d
/home/austen/programming/dm-afs/src/lib/city.c:196
  g ^= a1;
    8966:	41 31 d5             	xor    %edx,%r13d
/home/austen/programming/dm-afs/src/lib/city.c:189
  a4 = Rotate32(Fetch32(s + len - 20) * c1, 17) * c2;
    8969:	69 c0 93 35 87 1b    	imul   $0x1b873593,%eax,%eax
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    896f:	41 c1 c7 0d          	rol    $0xd,%r15d
    8973:	41 c1 c5 0d          	rol    $0xd,%r13d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:192
  h = h * 5 + 0xe6546b64;
    8977:	43 8d 8c bf 64 6b 54 	lea    -0x19ab949c(%r15,%r15,4),%ecx
    897e:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:202
  f += a4;
    897f:	01 d0                	add    %edx,%eax
/home/austen/programming/dm-afs/src/lib/city.c:205
  iters = (len - 1) / 20;
    8981:	48 8d 56 ff          	lea    -0x1(%rsi),%rdx
/home/austen/programming/dm-afs/src/lib/city.c:193
  h ^= a2;
    8985:	41 31 ce             	xor    %ecx,%r14d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8988:	c1 c0 0d             	rol    $0xd,%eax
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:198
  g = g * 5 + 0xe6546b64;
    898b:	43 8d 8c ad 64 6b 54 	lea    -0x19ab949c(%r13,%r13,4),%ecx
    8992:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:205
  iters = (len - 1) / 20;
    8993:	48 be cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rsi
    899a:	cc cc cc 
/home/austen/programming/dm-afs/src/lib/city.c:204
  f = f * 5 + 0xe6546b64;
    899d:	44 8d ac 80 64 6b 54 	lea    -0x19ab949c(%rax,%rax,4),%r13d
    89a4:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:205
  iters = (len - 1) / 20;
    89a5:	48 89 d0             	mov    %rdx,%rax
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    89a8:	41 c1 c6 0d          	rol    $0xd,%r14d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:188
  a3 = Rotate32(Fetch32(s + len - 12) * c1, 17) * c2;
    89ac:	45 69 e4 93 35 87 1b 	imul   $0x1b873593,%r12d,%r12d
/home/austen/programming/dm-afs/src/lib/city.c:195
  h = h * 5 + 0xe6546b64;
    89b3:	47 8d bc b6 64 6b 54 	lea    -0x19ab949c(%r14,%r14,4),%r15d
    89ba:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:205
  iters = (len - 1) / 20;
    89bb:	48 f7 e6             	mul    %rsi
/home/austen/programming/dm-afs/src/lib/city.c:199
  g ^= a3;
    89be:	41 31 cc             	xor    %ecx,%r12d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    89c1:	41 c1 c4 0d          	rol    $0xd,%r12d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:205
  iters = (len - 1) / 20;
    89c5:	48 c1 ea 04          	shr    $0x4,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:201
  g = g * 5 + 0xe6546b64;
    89c9:	47 8d 94 a4 64 6b 54 	lea    -0x19ab949c(%r12,%r12,4),%r10d
    89d0:	e6 
    89d1:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
    89d5:	48 8d 04 83          	lea    (%rbx,%rax,4),%rax
    89d9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101 (discriminator 1)
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    89dd:	48 89 df             	mov    %rbx,%rdi
    89e0:	44 89 55 c4          	mov    %r10d,-0x3c(%rbp)
    89e4:	e8 27 f1 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:207 (discriminator 1)
    uint32_t a0 = Rotate32(Fetch32(s) * c1, 17) * c2;
    89e9:	69 c8 51 2d 9e cc    	imul   $0xcc9e2d51,%eax,%ecx
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101 (discriminator 1)
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    89ef:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    89f3:	c1 c1 0f             	rol    $0xf,%ecx
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:207 (discriminator 1)
    uint32_t a0 = Rotate32(Fetch32(s) * c1, 17) * c2;
    89f6:	69 c9 93 35 87 1b    	imul   $0x1b873593,%ecx,%ecx
    89fc:	89 4d c8             	mov    %ecx,-0x38(%rbp)
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101 (discriminator 1)
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    89ff:	e8 0c f1 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
    8a04:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
    8a08:	89 45 d0             	mov    %eax,-0x30(%rbp)
    8a0b:	e8 00 f1 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
    8a10:	48 8d 7b 0c          	lea    0xc(%rbx),%rdi
    8a14:	41 89 c6             	mov    %eax,%r14d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:209 (discriminator 1)
    uint32_t a2 = Rotate32(Fetch32(s + 8) * c1, 17) * c2;
    8a17:	45 69 f6 51 2d 9e cc 	imul   $0xcc9e2d51,%r14d,%r14d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101 (discriminator 1)
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8a1e:	e8 ed f0 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
    8a23:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
    8a27:	41 89 c4             	mov    %eax,%r12d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:230 (discriminator 1)
    s += 20;
    8a2a:	48 83 c3 14          	add    $0x14,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:210 (discriminator 1)
    uint32_t a3 = Rotate32(Fetch32(s + 12) * c1, 17) * c2;
    8a2e:	45 69 e4 51 2d 9e cc 	imul   $0xcc9e2d51,%r12d,%r12d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8a35:	41 c1 c6 0f          	rol    $0xf,%r14d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101 (discriminator 1)
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8a39:	e8 d2 f0 ff ff       	callq  7b10 <UNALIGNED_LOAD32>
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:212 (discriminator 1)
    h ^= a0;
    8a3e:	8b 4d c8             	mov    -0x38(%rbp),%ecx
/home/austen/programming/dm-afs/src/lib/city.c:215 (discriminator 1)
    f += a1;
    8a41:	8b 55 d0             	mov    -0x30(%rbp),%edx
/home/austen/programming/dm-afs/src/lib/city.c:209 (discriminator 1)
    uint32_t a2 = Rotate32(Fetch32(s + 8) * c1, 17) * c2;
    8a44:	45 69 f6 93 35 87 1b 	imul   $0x1b873593,%r14d,%r14d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8a4b:	41 c1 c4 0f          	rol    $0xf,%r12d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:218 (discriminator 1)
    g += a2;
    8a4f:	44 8b 55 c4          	mov    -0x3c(%rbp),%r10d
/home/austen/programming/dm-afs/src/lib/city.c:210 (discriminator 1)
    uint32_t a3 = Rotate32(Fetch32(s + 12) * c1, 17) * c2;
    8a53:	45 69 e4 93 35 87 1b 	imul   $0x1b873593,%r12d,%r12d
/home/austen/programming/dm-afs/src/lib/city.c:212 (discriminator 1)
    h ^= a0;
    8a5a:	41 31 cf             	xor    %ecx,%r15d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8a5d:	41 c1 c7 0e          	rol    $0xe,%r15d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:218 (discriminator 1)
    g += a2;
    8a61:	45 01 f2             	add    %r14d,%r10d
/home/austen/programming/dm-afs/src/lib/city.c:214 (discriminator 1)
    h = h * 5 + 0xe6546b64;
    8a64:	43 8d bc bf 64 6b 54 	lea    -0x19ab949c(%r15,%r15,4),%edi
    8a6b:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:215 (discriminator 1)
    f += a1;
    8a6c:	45 8d 7c 15 00       	lea    0x0(%r13,%rdx,1),%r15d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8a71:	41 c1 c2 0e          	rol    $0xe,%r10d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:221 (discriminator 1)
    h ^= a3 + a1;
    8a75:	44 01 e2             	add    %r12d,%edx
/home/austen/programming/dm-afs/src/lib/city.c:220 (discriminator 1)
    g = g * 5 + 0xe6546b64;
    8a78:	43 8d b4 92 64 6b 54 	lea    -0x19ab949c(%r10,%r10,4),%esi
    8a7f:	e6 
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8a80:	41 c1 c7 0d          	rol    $0xd,%r15d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:221 (discriminator 1)
    h ^= a3 + a1;
    8a84:	31 fa                	xor    %edi,%edx
/home/austen/programming/dm-afs/src/lib/city.c:217 (discriminator 1)
    f = f * c1;
    8a86:	45 69 ff 51 2d 9e cc 	imul   $0xcc9e2d51,%r15d,%r15d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8a8d:	c1 c2 0d             	rol    $0xd,%edx
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:224 (discriminator 1)
    g ^= a4;
    8a90:	31 c6                	xor    %eax,%esi
    8a92:	01 c2                	add    %eax,%edx
/home/austen/programming/dm-afs/src/lib/city.c:225 (discriminator 1)
    g = bswap_32(g) * 5;
    8a94:	0f ce                	bswap  %esi
/home/austen/programming/dm-afs/src/lib/city.c:226 (discriminator 1)
    h += a4 * 5;
    8a96:	44 8d 94 92 64 6b 54 	lea    -0x19ab949c(%rdx,%rdx,4),%r10d
    8a9d:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:225 (discriminator 1)
    g = bswap_32(g) * 5;
    8a9e:	44 8d 2c b6          	lea    (%rsi,%rsi,4),%r13d
/home/austen/programming/dm-afs/src/lib/city.c:228 (discriminator 1)
    f += a0;
    8aa2:	41 01 cf             	add    %ecx,%r15d
/home/austen/programming/dm-afs/src/lib/city.c:231 (discriminator 1)
  } while (--iters != 0);
    8aa5:	48 3b 5d b8          	cmp    -0x48(%rbp),%rbx
/home/austen/programming/dm-afs/src/lib/city.c:227 (discriminator 1)
    h = bswap_32(h);
    8aa9:	41 0f ca             	bswap  %r10d
/home/austen/programming/dm-afs/src/lib/city.c:231 (discriminator 1)
  } while (--iters != 0);
    8aac:	0f 85 2b ff ff ff    	jne    89dd <CityHash32+0x1ed>
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8ab2:	41 c1 ca 0b          	ror    $0xb,%r10d
    8ab6:	45 89 e8             	mov    %r13d,%r8d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    8ab9:	48 83 c4 20          	add    $0x20,%rsp
/home/austen/programming/dm-afs/src/lib/city.c:232
  g = Rotate32(g, 11) * c1;
    8abd:	41 69 c2 51 2d 9e cc 	imul   $0xcc9e2d51,%r10d,%eax
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8ac4:	41 c1 c8 0b          	ror    $0xb,%r8d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:234
  f = Rotate32(f, 11) * c1;
    8ac8:	45 69 c0 51 2d 9e cc 	imul   $0xcc9e2d51,%r8d,%r8d
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    8acf:	5b                   	pop    %rbx
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8ad0:	c1 c0 0f             	rol    $0xf,%eax
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:233
  g = Rotate32(g, 17) * c1;
    8ad3:	69 c0 51 2d 9e cc    	imul   $0xcc9e2d51,%eax,%eax
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8ad9:	41 c1 c0 0f          	rol    $0xf,%r8d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    8add:	41 5c                	pop    %r12
    8adf:	41 5d                	pop    %r13
/home/austen/programming/dm-afs/src/lib/city.c:236
  h = Rotate32(h + g, 19);
    8ae1:	41 01 c7             	add    %eax,%r15d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8ae4:	41 c1 c7 0d          	rol    $0xd,%r15d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:237
  h = h * 5 + 0xe6546b64;
    8ae8:	43 8d 84 bf 64 6b 54 	lea    -0x19ab949c(%r15,%r15,4),%eax
    8aef:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    8af0:	41 5e                	pop    %r14
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8af2:	c1 c0 0f             	rol    $0xf,%eax
    8af5:	41 01 c0             	add    %eax,%r8d
    8af8:	45 69 c0 51 2d 9e cc 	imul   $0xcc9e2d51,%r8d,%r8d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    8aff:	41 5f                	pop    %r15
    8b01:	5d                   	pop    %rbp
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8b02:	41 c1 c0 0d          	rol    $0xd,%r8d
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:240
  h = h * 5 + 0xe6546b64;
    8b06:	43 8d 84 80 64 6b 54 	lea    -0x19ab949c(%r8,%r8,4),%eax
    8b0d:	e6 
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8b0e:	c1 c0 0f             	rol    $0xf,%eax
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:241
  h = Rotate32(h, 17) * c1;
    8b11:	69 c0 51 2d 9e cc    	imul   $0xcc9e2d51,%eax,%eax
/home/austen/programming/dm-afs/src/lib/city.c:243
}
    8b17:	c3                   	retq   
Hash32Len13to24():
/home/austen/programming/dm-afs/src/lib/city.c:143
  uint32_t a = Fetch32(s - 4 + (len >> 1));
    8b18:	49 89 f5             	mov    %rsi,%r13
    8b1b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    8b1f:	49 d1 ed             	shr    %r13
    8b22:	4a 8d 7c 2f fc       	lea    -0x4(%rdi,%r13,1),%rdi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b27:	e8 e4 ef ff ff       	callq  7b10 <UNALIGNED_LOAD32>
Hash32Len13to24():
/home/austen/programming/dm-afs/src/lib/city.c:144
  uint32_t b = Fetch32(s + 4);
    8b2c:	48 8d 7b 04          	lea    0x4(%rbx),%rdi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b30:	41 89 c4             	mov    %eax,%r12d
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8b33:	45 69 e4 51 2d 9e cc 	imul   $0xcc9e2d51,%r12d,%r12d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b3a:	e8 d1 ef ff ff       	callq  7b10 <UNALIGNED_LOAD32>
Hash32Len13to24():
/home/austen/programming/dm-afs/src/lib/city.c:145
  uint32_t c = Fetch32(s + len - 8);
    8b3f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b43:	41 89 c7             	mov    %eax,%r15d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8b46:	41 c1 c4 0f          	rol    $0xf,%r12d
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8b4a:	45 69 ff 51 2d 9e cc 	imul   $0xcc9e2d51,%r15d,%r15d
Hash32Len13to24():
/home/austen/programming/dm-afs/src/lib/city.c:145
  uint32_t c = Fetch32(s + len - 8);
    8b51:	48 8d 7c 33 f8       	lea    -0x8(%rbx,%rsi,1),%rdi
    8b56:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b5a:	e8 b1 ef ff ff       	callq  7b10 <UNALIGNED_LOAD32>
Hash32Len13to24():
/home/austen/programming/dm-afs/src/lib/city.c:146
  uint32_t d = Fetch32(s + (len >> 1));
    8b5f:	4a 8d 3c 2b          	lea    (%rbx,%r13,1),%rdi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b63:	41 89 c6             	mov    %eax,%r14d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8b66:	41 c1 c7 0f          	rol    $0xf,%r15d
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8b6a:	45 69 e4 93 35 87 1b 	imul   $0x1b873593,%r12d,%r12d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b71:	e8 9a ef ff ff       	callq  7b10 <UNALIGNED_LOAD32>
    8b76:	48 89 df             	mov    %rbx,%rdi
    8b79:	41 89 c5             	mov    %eax,%r13d
    8b7c:	e8 8f ef ff ff       	callq  7b10 <UNALIGNED_LOAD32>
Hash32Len13to24():
/home/austen/programming/dm-afs/src/lib/city.c:148
  uint32_t f = Fetch32(s + len - 4);
    8b81:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b85:	89 45 d0             	mov    %eax,-0x30(%rbp)
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8b88:	45 69 f6 51 2d 9e cc 	imul   $0xcc9e2d51,%r14d,%r14d
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8b8f:	45 69 ff 93 35 87 1b 	imul   $0x1b873593,%r15d,%r15d
Hash32Len13to24():
/home/austen/programming/dm-afs/src/lib/city.c:148
  uint32_t f = Fetch32(s + len - 4);
    8b96:	48 8d 7c 33 fc       	lea    -0x4(%rbx,%rsi,1),%rdi
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8b9b:	41 c1 c6 0f          	rol    $0xf,%r14d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8b9f:	e8 6c ef ff ff       	callq  7b10 <UNALIGNED_LOAD32>
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    8ba4:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8ba8:	45 69 ed 51 2d 9e cc 	imul   $0xcc9e2d51,%r13d,%r13d
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8baf:	45 69 f6 93 35 87 1b 	imul   $0x1b873593,%r14d,%r14d
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    8bb6:	44 31 e6             	xor    %r12d,%esi
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8bb9:	c1 c6 0d             	rol    $0xd,%esi
    8bbc:	41 c1 c5 0f          	rol    $0xf,%r13d
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8bc0:	8d 8c b6 64 6b 54 e6 	lea    -0x19ab949c(%rsi,%rsi,4),%ecx
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8bc7:	69 55 d0 51 2d 9e cc 	imul   $0xcc9e2d51,-0x30(%rbp),%edx
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    8bce:	44 31 f9             	xor    %r15d,%ecx
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8bd1:	c1 c1 0d             	rol    $0xd,%ecx
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8bd4:	8d 8c 89 64 6b 54 e6 	lea    -0x19ab949c(%rcx,%rcx,4),%ecx
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8bdb:	45 69 ed 93 35 87 1b 	imul   $0x1b873593,%r13d,%r13d
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    8be2:	41 31 ce             	xor    %ecx,%r14d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8be5:	41 c1 c6 0d          	rol    $0xd,%r14d
    8be9:	c1 c2 0f             	rol    $0xf,%edx
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8bec:	43 8d 8c b6 64 6b 54 	lea    -0x19ab949c(%r14,%r14,4),%ecx
    8bf3:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8bf4:	69 c0 51 2d 9e cc    	imul   $0xcc9e2d51,%eax,%eax
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    8bfa:	41 31 cd             	xor    %ecx,%r13d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8bfd:	41 c1 c5 0d          	rol    $0xd,%r13d
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8c01:	69 d2 93 35 87 1b    	imul   $0x1b873593,%edx,%edx
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8c07:	43 8d 8c ad 64 6b 54 	lea    -0x19ab949c(%r13,%r13,4),%ecx
    8c0e:	e6 
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8c0f:	c1 c0 0f             	rol    $0xf,%eax
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    8c12:	31 ca                	xor    %ecx,%edx
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8c14:	c1 c2 0d             	rol    $0xd,%edx
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8c17:	8d 94 92 64 6b 54 e6 	lea    -0x19ab949c(%rdx,%rdx,4),%edx
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8c1e:	69 c0 93 35 87 1b    	imul   $0x1b873593,%eax,%eax
    8c24:	e9 52 fc ff ff       	jmpq   887b <CityHash32+0x8b>
Hash32Len5to12():
/home/austen/programming/dm-afs/src/lib/city.c:167
  uint32_t a = len, b = len * 5, c = 9, d = b;
    8c29:	44 8d 24 b6          	lea    (%rsi,%rsi,4),%r12d
    8c2d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8c31:	e8 da ee ff ff       	callq  7b10 <UNALIGNED_LOAD32>
Hash32Len5to12():
/home/austen/programming/dm-afs/src/lib/city.c:168
  a += Fetch32(s);
    8c36:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
/home/austen/programming/dm-afs/src/lib/city.c:169
  b += Fetch32(s + len - 4);
    8c3a:	48 8d 7c 33 fc       	lea    -0x4(%rbx,%rsi,1),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:168
  a += Fetch32(s);
    8c3f:	44 8d 34 30          	lea    (%rax,%rsi,1),%r14d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8c43:	e8 c8 ee ff ff       	callq  7b10 <UNALIGNED_LOAD32>
Hash32Len5to12():
/home/austen/programming/dm-afs/src/lib/city.c:170
  c += Fetch32(s + ((len >> 1) & 4));
    8c48:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
/home/austen/programming/dm-afs/src/lib/city.c:169
  b += Fetch32(s + len - 4);
    8c4c:	45 8d 2c 04          	lea    (%r12,%rax,1),%r13d
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8c50:	45 69 ed 51 2d 9e cc 	imul   $0xcc9e2d51,%r13d,%r13d
Hash32Len5to12():
/home/austen/programming/dm-afs/src/lib/city.c:170
  c += Fetch32(s + ((len >> 1) & 4));
    8c57:	48 d1 ee             	shr    %rsi
    8c5a:	83 e6 04             	and    $0x4,%esi
    8c5d:	48 8d 3c 33          	lea    (%rbx,%rsi,1),%rdi
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8c61:	41 c1 c5 0f          	rol    $0xf,%r13d
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8c65:	45 69 ed 93 35 87 1b 	imul   $0x1b873593,%r13d,%r13d
Fetch32():
/home/austen/programming/dm-afs/src/lib/city.c:101
  return uint32_t_in_expected_order(UNALIGNED_LOAD32(p));
    8c6c:	e8 9f ee ff ff       	callq  7b10 <UNALIGNED_LOAD32>
Hash32Len5to12():
/home/austen/programming/dm-afs/src/lib/city.c:170
  c += Fetch32(s + ((len >> 1) & 4));
    8c71:	83 c0 09             	add    $0x9,%eax
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:134
  a *= c1;
    8c74:	41 69 d6 51 2d 9e cc 	imul   $0xcc9e2d51,%r14d,%edx
    8c7b:	69 c0 51 2d 9e cc    	imul   $0xcc9e2d51,%eax,%eax
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8c81:	c1 c2 0f             	rol    $0xf,%edx
    8c84:	c1 c0 0f             	rol    $0xf,%eax
    8c87:	89 c1                	mov    %eax,%ecx
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8c89:	69 c2 93 35 87 1b    	imul   $0x1b873593,%edx,%eax
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    8c8f:	44 31 e0             	xor    %r12d,%eax
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8c92:	c1 c0 0d             	rol    $0xd,%eax
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8c95:	8d 84 80 64 6b 54 e6 	lea    -0x19ab949c(%rax,%rax,4),%eax
/home/austen/programming/dm-afs/src/lib/city.c:137
  h ^= a;
    8c9c:	41 31 c5             	xor    %eax,%r13d
Rotate32():
/home/austen/programming/dm-afs/src/lib/city.c:126
  return shift == 0 ? val : ((val >> shift) | (val << (32 - shift)));
    8c9f:	41 c1 c5 0d          	rol    $0xd,%r13d
Mur():
/home/austen/programming/dm-afs/src/lib/city.c:139
  return h * 5 + 0xe6546b64;
    8ca3:	43 8d 94 ad 64 6b 54 	lea    -0x19ab949c(%r13,%r13,4),%edx
    8caa:	e6 
/home/austen/programming/dm-afs/src/lib/city.c:136
  a *= c2;
    8cab:	69 c1 93 35 87 1b    	imul   $0x1b873593,%ecx,%eax
    8cb1:	e9 c5 fb ff ff       	jmpq   887b <CityHash32+0x8b>
Hash32Len0to4():
/home/austen/programming/dm-afs/src/lib/city.c:158
  for (i = 0; i < len; i++) {
    8cb6:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/city.c:156
  uint32_t c = 9;
    8cb8:	b9 09 00 00 00       	mov    $0x9,%ecx
    8cbd:	e9 9e fb ff ff       	jmpq   8860 <CityHash32+0x70>
CityHash32():
/home/austen/programming/dm-afs/src/lib/city.c:156
    8cc2:	0f 1f 40 00          	nopl   0x0(%rax)
    8cc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    8ccd:	00 00 00 

0000000000008cd0 <CityHash64>:
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:357
uint64_t CityHash64(const uint8_t *s, size_t len) {
    8cd0:	e8 00 00 00 00       	callq  8cd5 <CityHash64+0x5>
			8cd1: R_X86_64_PC32	__fentry__-0x4
    8cd5:	55                   	push   %rbp
    8cd6:	48 89 e5             	mov    %rsp,%rbp
    8cd9:	41 57                	push   %r15
    8cdb:	41 56                	push   %r14
    8cdd:	41 55                	push   %r13
    8cdf:	41 54                	push   %r12
    8ce1:	49 89 fc             	mov    %rdi,%r12
    8ce4:	53                   	push   %rbx
    8ce5:	49 89 f6             	mov    %rsi,%r14
    8ce8:	48 83 ec 30          	sub    $0x30,%rsp
/home/austen/programming/dm-afs/src/lib/city.c:360
  if (len <= 32) {
    8cec:	48 83 fe 20          	cmp    $0x20,%rsi
    8cf0:	77 1e                	ja     8d10 <CityHash64+0x40>
/home/austen/programming/dm-afs/src/lib/city.c:361
    if (len <= 16) {
    8cf2:	48 83 fe 10          	cmp    $0x10,%rsi
    8cf6:	0f 87 7a 02 00 00    	ja     8f76 <CityHash64+0x2a6>
/home/austen/programming/dm-afs/src/lib/city.c:362
      return HashLen0to16(s, len);
    8cfc:	e8 1f ee ff ff       	callq  7b20 <HashLen0to16>
/home/austen/programming/dm-afs/src/lib/city.c:395
}
    8d01:	48 83 c4 30          	add    $0x30,%rsp
    8d05:	5b                   	pop    %rbx
    8d06:	41 5c                	pop    %r12
    8d08:	41 5d                	pop    %r13
    8d0a:	41 5e                	pop    %r14
    8d0c:	41 5f                	pop    %r15
    8d0e:	5d                   	pop    %rbp
    8d0f:	c3                   	retq   
    8d10:	48 8d 7c 37 f0       	lea    -0x10(%rdi,%rsi,1),%rdi
    8d15:	e8 56 ed ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    8d1a:	4b 8d 7c 34 e8       	lea    -0x18(%r12,%r14,1),%rdi
    8d1f:	48 89 c3             	mov    %rax,%rbx
    8d22:	e8 49 ed ff ff       	callq  7a70 <UNALIGNED_LOAD64>
/home/austen/programming/dm-afs/src/lib/city.c:366
  } else if (len <= 64) {
    8d27:	49 83 fe 40          	cmp    $0x40,%r14
    8d2b:	49 89 c5             	mov    %rax,%r13
    8d2e:	0f 86 00 03 00 00    	jbe    9034 <CityHash64+0x364>
/home/austen/programming/dm-afs/src/lib/city.c:372
  x = Fetch64(s + len - 40);
    8d34:	4b 8d 7c 34 d8       	lea    -0x28(%r12,%r14,1),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8d39:	e8 32 ed ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:373
  y = Fetch64(s + len - 16) + Fetch64(s + len - 56);
    8d3e:	4b 8d 7c 34 c8       	lea    -0x38(%r12,%r14,1),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8d43:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    8d47:	e8 24 ed ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:374
  z = HashLen16(Fetch64(s + len - 48) + len, Fetch64(s + len - 24));
    8d4c:	4b 8d 7c 34 d0       	lea    -0x30(%r12,%r14,1),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:373
  y = Fetch64(s + len - 16) + Fetch64(s + len - 56);
    8d51:	48 01 c3             	add    %rax,%rbx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8d54:	e8 17 ed ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:374
  z = HashLen16(Fetch64(s + len - 48) + len, Fetch64(s + len - 24));
    8d59:	4c 01 f0             	add    %r14,%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    8d5c:	48 ba 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rdx
    8d63:	ea df 9d 
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:375
  v = WeakHashLen32WithSeedsArray(s + len - 64, len, z);
    8d66:	4b 8d 7c 34 c0       	lea    -0x40(%r12,%r14,1),%rdi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    8d6b:	4c 31 e8             	xor    %r13,%rax
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:375
  v = WeakHashLen32WithSeedsArray(s + len - 64, len, z);
    8d6e:	4c 89 f6             	mov    %r14,%rsi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    8d71:	48 0f af c2          	imul   %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8d75:	49 31 c5             	xor    %rax,%r13
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8d78:	48 c1 e8 2f          	shr    $0x2f,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8d7c:	49 31 c5             	xor    %rax,%r13
    8d7f:	4c 0f af ea          	imul   %rdx,%r13
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8d83:	4c 89 e8             	mov    %r13,%rax
    8d86:	48 c1 e8 2f          	shr    $0x2f,%rax
    8d8a:	49 31 c5             	xor    %rax,%r13
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    8d8d:	4c 0f af ea          	imul   %rdx,%r13
    8d91:	4c 89 ea             	mov    %r13,%rdx
    8d94:	4c 89 6d b8          	mov    %r13,-0x48(%rbp)
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:375
  v = WeakHashLen32WithSeedsArray(s + len - 64, len, z);
    8d98:	e8 e3 ec ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
/home/austen/programming/dm-afs/src/lib/city.c:376
  w = WeakHashLen32WithSeedsArray(s + len - 32, y + k1, x);
    8d9d:	49 b9 73 f2 98 be 6f 	movabs $0xb492b66fbe98f273,%r9
    8da4:	b6 92 b4 
/home/austen/programming/dm-afs/src/lib/city.c:375
  v = WeakHashLen32WithSeedsArray(s + len - 64, len, z);
    8da7:	49 89 d5             	mov    %rdx,%r13
/home/austen/programming/dm-afs/src/lib/city.c:376
  w = WeakHashLen32WithSeedsArray(s + len - 32, y + k1, x);
    8daa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    8dae:	4a 8d 34 0b          	lea    (%rbx,%r9,1),%rsi
    8db2:	4b 8d 7c 34 e0       	lea    -0x20(%r12,%r14,1),%rdi
    8db7:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:375
  v = WeakHashLen32WithSeedsArray(s + len - 64, len, z);
    8dbb:	49 89 c7             	mov    %rax,%r15
/home/austen/programming/dm-afs/src/lib/city.c:376
  w = WeakHashLen32WithSeedsArray(s + len - 32, y + k1, x);
    8dbe:	e8 bd ec ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8dc3:	4c 89 e7             	mov    %r12,%rdi
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:376
  w = WeakHashLen32WithSeedsArray(s + len - 32, y + k1, x);
    8dc6:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    8dca:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8dce:	e8 9d ec ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:377
  x = x * k1 + Fetch64(s);
    8dd3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    8dd7:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
/home/austen/programming/dm-afs/src/lib/city.c:380
  len = (len - 1) & ~(size_t)(63);
    8ddb:	4d 8d 46 ff          	lea    -0x1(%r14),%r8
/home/austen/programming/dm-afs/src/lib/city.c:382
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    8ddf:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
    8de3:	49 83 e0 c0          	and    $0xffffffffffffffc0,%r8
/home/austen/programming/dm-afs/src/lib/city.c:377
  x = x * k1 + Fetch64(s);
    8de7:	49 0f af d1          	imul   %r9,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:382
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    8deb:	4d 89 ce             	mov    %r9,%r14
/home/austen/programming/dm-afs/src/lib/city.c:377
  x = x * k1 + Fetch64(s);
    8dee:	48 01 d0             	add    %rdx,%rax
    8df1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    8df5:	4b 8d 04 04          	lea    (%r12,%r8,1),%rax
    8df9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    8dfd:	4a 8d 04 3b          	lea    (%rbx,%r15,1),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8e01:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
    8e06:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:383
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    8e0a:	4c 01 eb             	add    %r13,%rbx
    8e0d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8e11:	e8 5a ec ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:382
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    8e16:	48 03 45 c0          	add    -0x40(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8e1a:	49 8d 7c 24 30       	lea    0x30(%r12),%rdi
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:382
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    8e1f:	48 03 45 d0          	add    -0x30(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:387
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    8e23:	4d 0f af ee          	imul   %r14,%r13
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8e27:	48 c1 c0 1b          	rol    $0x1b,%rax
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:382
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    8e2b:	49 0f af c6          	imul   %r14,%rax
    8e2f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8e33:	e8 38 ec ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:383
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    8e38:	48 01 c3             	add    %rax,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:384
    x ^= w.second;
    8e3b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    8e3f:	48 33 45 c8          	xor    -0x38(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8e43:	49 8d 7c 24 28       	lea    0x28(%r12),%rdi
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8e48:	48 c1 c3 16          	rol    $0x16,%rbx
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:383
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    8e4c:	49 0f af de          	imul   %r14,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:384
    x ^= w.second;
    8e50:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8e54:	e8 17 ec ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:386
    z = Rotate(z + w.first, 33) * k1;
    8e59:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
    8e5d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
/home/austen/programming/dm-afs/src/lib/city.c:385
    y += v.first + Fetch64(s + 40);
    8e61:	4c 01 f8             	add    %r15,%rax
    8e64:	48 01 c3             	add    %rax,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:387
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    8e67:	4c 89 ee             	mov    %r13,%rsi
    8e6a:	4c 89 e7             	mov    %r12,%rdi
/home/austen/programming/dm-afs/src/lib/city.c:386
    z = Rotate(z + w.first, 33) * k1;
    8e6d:	48 01 ca             	add    %rcx,%rdx
    8e70:	48 89 d0             	mov    %rdx,%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8e73:	48 c1 c0 1f          	rol    $0x1f,%rax
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:386
    z = Rotate(z + w.first, 33) * k1;
    8e77:	48 89 c2             	mov    %rax,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:387
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    8e7a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:386
    z = Rotate(z + w.first, 33) * k1;
    8e7e:	49 0f af d6          	imul   %r14,%rdx
    8e82:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:387
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    8e86:	48 8d 14 08          	lea    (%rax,%rcx,1),%rdx
    8e8a:	e8 f1 eb ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8e8f:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:387
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    8e94:	49 89 d5             	mov    %rdx,%r13
    8e97:	49 89 c7             	mov    %rax,%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8e9a:	e8 d1 eb ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:388
    w = WeakHashLen32WithSeedsArray(s + 32, z + w.second, y + Fetch64(s + 16));
    8e9f:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    8ea3:	48 03 75 d0          	add    -0x30(%rbp),%rsi
    8ea7:	49 8d 7c 24 20       	lea    0x20(%r12),%rdi
    8eac:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
/home/austen/programming/dm-afs/src/lib/city.c:390
    s += 64;
    8eb0:	49 83 c4 40          	add    $0x40,%r12
/home/austen/programming/dm-afs/src/lib/city.c:388
    w = WeakHashLen32WithSeedsArray(s + 32, z + w.second, y + Fetch64(s + 16));
    8eb4:	e8 c7 eb ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
/home/austen/programming/dm-afs/src/lib/city.c:392
  } while (len != 0);
    8eb9:	4c 39 65 a8          	cmp    %r12,-0x58(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:388
    w = WeakHashLen32WithSeedsArray(s + 32, z + w.second, y + Fetch64(s + 16));
    8ebd:	48 89 c1             	mov    %rax,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:384
    x ^= w.second;
    8ec0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:388
    w = WeakHashLen32WithSeedsArray(s + 32, z + w.second, y + Fetch64(s + 16));
    8ec4:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:384
    x ^= w.second;
    8ec8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:392
  } while (len != 0);
    8ecc:	0f 85 2b ff ff ff    	jne    8dfd <CityHash64+0x12d>
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    8ed2:	48 bf 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rdi
    8ed9:	ea df 9d 
    8edc:	49 31 cf             	xor    %rcx,%r15
    8edf:	49 31 d5             	xor    %rdx,%r13
    8ee2:	4c 0f af ff          	imul   %rdi,%r15
    8ee6:	4c 0f af ef          	imul   %rdi,%r13
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8eea:	4c 31 f9             	xor    %r15,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8eed:	49 c1 ef 2f          	shr    $0x2f,%r15
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8ef1:	4c 31 f9             	xor    %r15,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8ef4:	4c 89 ee             	mov    %r13,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8ef7:	49 31 d5             	xor    %rdx,%r13
    8efa:	48 0f af cf          	imul   %rdi,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8efe:	48 c1 ee 2f          	shr    $0x2f,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8f02:	49 31 f5             	xor    %rsi,%r13
    8f05:	4c 0f af ef          	imul   %rdi,%r13
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8f09:	48 89 c8             	mov    %rcx,%rax
    8f0c:	48 c1 e8 2f          	shr    $0x2f,%rax
    8f10:	48 31 c1             	xor    %rax,%rcx
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    8f13:	48 89 d8             	mov    %rbx,%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8f16:	4c 89 ee             	mov    %r13,%rsi
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    8f19:	48 c1 e8 2f          	shr    $0x2f,%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8f1d:	48 c1 ee 2f          	shr    $0x2f,%rsi
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    8f21:	48 31 c3             	xor    %rax,%rbx
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8f24:	49 31 f5             	xor    %rsi,%r13
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:393
  return HashLen16(HashLen16(v.first, w.first) + ShiftMix(y) * k1 + z,
    8f27:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    8f2b:	4c 0f af f3          	imul   %rbx,%r14
    8f2f:	4c 03 75 b8          	add    -0x48(%rbp),%r14
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    8f33:	4c 0f af ef          	imul   %rdi,%r13
    8f37:	48 0f af cf          	imul   %rdi,%rcx
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:393
  return HashLen16(HashLen16(v.first, w.first) + ShiftMix(y) * k1 + z,
    8f3b:	4c 01 ee             	add    %r13,%rsi
    8f3e:	4c 01 f1             	add    %r14,%rcx
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    8f41:	48 31 f1             	xor    %rsi,%rcx
    8f44:	48 0f af cf          	imul   %rdi,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8f48:	48 31 ce             	xor    %rcx,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    8f4b:	48 c1 e9 2f          	shr    $0x2f,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    8f4f:	48 89 f2             	mov    %rsi,%rdx
    8f52:	48 31 ca             	xor    %rcx,%rdx
    8f55:	48 0f af d7          	imul   %rdi,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    8f59:	48 89 d0             	mov    %rdx,%rax
    8f5c:	48 c1 e8 2f          	shr    $0x2f,%rax
    8f60:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    8f63:	48 0f af c7          	imul   %rdi,%rax
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:395
}
    8f67:	48 83 c4 30          	add    $0x30,%rsp
    8f6b:	5b                   	pop    %rbx
    8f6c:	41 5c                	pop    %r12
    8f6e:	41 5d                	pop    %r13
    8f70:	41 5e                	pop    %r14
    8f72:	41 5f                	pop    %r15
    8f74:	5d                   	pop    %rbp
    8f75:	c3                   	retq   
HashLen17to32():
/home/austen/programming/dm-afs/src/lib/city.c:300
  uint64_t mul = k2 + len * 2;
    8f76:	48 be 4f 40 90 2f 3b 	movabs $0x9ae16a3b2f90404f,%rsi
    8f7d:	6a e1 9a 
    8f80:	4a 8d 1c 76          	lea    (%rsi,%r14,2),%rbx
    8f84:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8f88:	e8 e3 ea ff ff       	callq  7a70 <UNALIGNED_LOAD64>
HashLen17to32():
/home/austen/programming/dm-afs/src/lib/city.c:301
  uint64_t a = Fetch64(s) * k1;
    8f8d:	48 ba 73 f2 98 be 6f 	movabs $0xb492b66fbe98f273,%rdx
    8f94:	b6 92 b4 
/home/austen/programming/dm-afs/src/lib/city.c:302
  uint64_t b = Fetch64(s + 8);
    8f97:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:301
  uint64_t a = Fetch64(s) * k1;
    8f9c:	48 0f af c2          	imul   %rdx,%rax
    8fa0:	49 89 c5             	mov    %rax,%r13
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8fa3:	e8 c8 ea ff ff       	callq  7a70 <UNALIGNED_LOAD64>
HashLen17to32():
/home/austen/programming/dm-afs/src/lib/city.c:303
  uint64_t c = Fetch64(s + len - 8) * mul;
    8fa8:	4b 8d 7c 34 f8       	lea    -0x8(%r12,%r14,1),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8fad:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    8fb1:	e8 ba ea ff ff       	callq  7a70 <UNALIGNED_LOAD64>
HashLen17to32():
/home/austen/programming/dm-afs/src/lib/city.c:303
  uint64_t c = Fetch64(s + len - 8) * mul;
    8fb6:	48 0f af c3          	imul   %rbx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:304
  uint64_t d = Fetch64(s + len - 16) * k2;
    8fba:	4b 8d 7c 34 f0       	lea    -0x10(%r12,%r14,1),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:303
  uint64_t c = Fetch64(s + len - 8) * mul;
    8fbf:	49 89 c7             	mov    %rax,%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    8fc2:	e8 a9 ea ff ff       	callq  7a70 <UNALIGNED_LOAD64>
HashLen17to32():
/home/austen/programming/dm-afs/src/lib/city.c:306
                   a + Rotate(b + k2, 18) + c, mul);
    8fc7:	4c 8b 45 d0          	mov    -0x30(%rbp),%r8
    8fcb:	48 be 4f 40 90 2f 3b 	movabs $0x9ae16a3b2f90404f,%rsi
    8fd2:	6a e1 9a 
/home/austen/programming/dm-afs/src/lib/city.c:305
  return HashLen16Mul(Rotate(a + b, 43) + Rotate(c, 30) + d,
    8fd5:	4b 8d 54 3d 00       	lea    0x0(%r13,%r15,1),%rdx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8fda:	4c 89 f9             	mov    %r15,%rcx
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:395
}
    8fdd:	48 83 c4 30          	add    $0x30,%rsp
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8fe1:	48 c1 c9 1e          	ror    $0x1e,%rcx
HashLen17to32():
/home/austen/programming/dm-afs/src/lib/city.c:306
                   a + Rotate(b + k2, 18) + c, mul);
    8fe5:	49 8d 3c 30          	lea    (%r8,%rsi,1),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:304
  uint64_t d = Fetch64(s + len - 16) * k2;
    8fe9:	48 0f af f0          	imul   %rax,%rsi
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8fed:	48 c1 cf 12          	ror    $0x12,%rdi
HashLen17to32():
/home/austen/programming/dm-afs/src/lib/city.c:305
  return HashLen16Mul(Rotate(a + b, 43) + Rotate(c, 30) + d,
    8ff1:	48 01 d7             	add    %rdx,%rdi
    8ff4:	4b 8d 54 05 00       	lea    0x0(%r13,%r8,1),%rdx
    8ff9:	48 01 f1             	add    %rsi,%rcx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    8ffc:	48 c1 c2 15          	rol    $0x15,%rdx
HashLen17to32():
/home/austen/programming/dm-afs/src/lib/city.c:305
  return HashLen16Mul(Rotate(a + b, 43) + Rotate(c, 30) + d,
    9000:	48 01 ca             	add    %rcx,%rdx
HashLen16Mul():
/home/austen/programming/dm-afs/src/lib/city.c:264
  a = (u ^ v) * mul;
    9003:	48 31 fa             	xor    %rdi,%rdx
    9006:	48 0f af d3          	imul   %rbx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:265
  a ^= (a >> 47);
    900a:	48 89 d0             	mov    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:266
  b = (v ^ a) * mul;
    900d:	48 31 fa             	xor    %rdi,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:265
  a ^= (a >> 47);
    9010:	48 c1 e8 2f          	shr    $0x2f,%rax
/home/austen/programming/dm-afs/src/lib/city.c:266
  b = (v ^ a) * mul;
    9014:	48 31 d0             	xor    %rdx,%rax
    9017:	48 0f af c3          	imul   %rbx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:267
  b ^= (b >> 47);
    901b:	48 89 c2             	mov    %rax,%rdx
    901e:	48 c1 ea 2f          	shr    $0x2f,%rdx
    9022:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:268
  b *= mul;
    9025:	48 0f af c3          	imul   %rbx,%rax
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:395
}
    9029:	5b                   	pop    %rbx
    902a:	41 5c                	pop    %r12
    902c:	41 5d                	pop    %r13
    902e:	41 5e                	pop    %r14
    9030:	41 5f                	pop    %r15
    9032:	5d                   	pop    %rbp
    9033:	c3                   	retq   
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:337
  uint64_t mul = k2 + len * 2;
    9034:	49 ba 4f 40 90 2f 3b 	movabs $0x9ae16a3b2f90404f,%r10
    903b:	6a e1 9a 
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    903e:	4c 89 e7             	mov    %r12,%rdi
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:337
  uint64_t mul = k2 + len * 2;
    9041:	4f 8d 3c 72          	lea    (%r10,%r14,2),%r15
    9045:	4c 89 55 a8          	mov    %r10,-0x58(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9049:	e8 22 ea ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    904e:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
    9053:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:345
  uint64_t h = Fetch64(s + len - 16) * mul;
    9057:	49 0f af df          	imul   %r15,%rbx
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    905b:	e8 10 ea ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    9060:	4b 8d 7c 34 e0       	lea    -0x20(%r12,%r14,1),%rdi
    9065:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    9069:	e8 02 ea ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    906e:	49 8d 7c 24 10       	lea    0x10(%r12),%rdi
    9073:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    9077:	e8 f4 e9 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:343
  uint64_t f = Fetch64(s + 24) * 9;
    907c:	49 8d 7c 24 18       	lea    0x18(%r12),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9081:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    9085:	e8 e6 e9 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:344
  uint64_t g = Fetch64(s + len - 8);
    908a:	4b 8d 7c 34 f8       	lea    -0x8(%r12,%r14,1),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:343
  uint64_t f = Fetch64(s + 24) * 9;
    908f:	4c 8d 1c c0          	lea    (%rax,%rax,8),%r11
    9093:	4c 89 5d c8          	mov    %r11,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9097:	e8 d4 e9 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:338
  uint64_t a = Fetch64(s) * k2;
    909c:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
    90a0:	49 ba 4f 40 90 2f 3b 	movabs $0x9ae16a3b2f90404f,%r10
    90a7:	6a e1 9a 
/home/austen/programming/dm-afs/src/lib/city.c:347
  uint64_t v = ((a + g) ^ d) + f + 1;
    90aa:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    90ae:	4c 8b 5d c8          	mov    -0x38(%rbp),%r11
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    90b2:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:342
  uint64_t e = Fetch64(s + 16) * k2;
    90b6:	4c 8b 75 d0          	mov    -0x30(%rbp),%r14
/home/austen/programming/dm-afs/src/lib/city.c:338
  uint64_t a = Fetch64(s) * k2;
    90ba:	4d 0f af ca          	imul   %r10,%r9
/home/austen/programming/dm-afs/src/lib/city.c:347
  uint64_t v = ((a + g) ^ d) + f + 1;
    90be:	48 89 f2             	mov    %rsi,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:353
  b = ShiftMix((z + a) * mul + d + h) * mul;
    90c1:	48 01 de             	add    %rbx,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:342
  uint64_t e = Fetch64(s + 16) * k2;
    90c4:	4d 0f af f2          	imul   %r10,%r14
/home/austen/programming/dm-afs/src/lib/city.c:346
  uint64_t u = Rotate(a + g, 43) + (Rotate(b, 30) + c) * 9;
    90c8:	49 01 c1             	add    %rax,%r9
/home/austen/programming/dm-afs/src/lib/city.c:347
  uint64_t v = ((a + g) ^ d) + f + 1;
    90cb:	4c 31 ca             	xor    %r9,%rdx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    90ce:	49 c1 c1 15          	rol    $0x15,%r9
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:347
  uint64_t v = ((a + g) ^ d) + f + 1;
    90d2:	4d 8d 44 13 01       	lea    0x1(%r11,%rdx,1),%r8
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    90d7:	48 89 ca             	mov    %rcx,%rdx
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:349
  uint64_t x = Rotate(e + f, 42) + c;
    90da:	4d 01 f3             	add    %r14,%r11
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    90dd:	48 c1 ca 1e          	ror    $0x1e,%rdx
    90e1:	4c 89 df             	mov    %r11,%rdi
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:346
  uint64_t u = Rotate(a + g, 43) + (Rotate(b, 30) + c) * 9;
    90e4:	4c 01 ea             	add    %r13,%rdx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    90e7:	48 c1 c7 16          	rol    $0x16,%rdi
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:346
  uint64_t u = Rotate(a + g, 43) + (Rotate(b, 30) + c) * 9;
    90eb:	48 8d 14 d2          	lea    (%rdx,%rdx,8),%rdx
/home/austen/programming/dm-afs/src/lib/city.c:349
  uint64_t x = Rotate(e + f, 42) + c;
    90ef:	4c 01 ef             	add    %r13,%rdi
/home/austen/programming/dm-afs/src/lib/city.c:351
  uint64_t z = e + f + c;
    90f2:	4d 01 dd             	add    %r11,%r13
/home/austen/programming/dm-afs/src/lib/city.c:346
  uint64_t u = Rotate(a + g, 43) + (Rotate(b, 30) + c) * 9;
    90f5:	4c 01 ca             	add    %r9,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:348
  uint64_t w = bswap_64((u + v) * mul) + h;
    90f8:	4c 01 c2             	add    %r8,%rdx
    90fb:	49 0f af d7          	imul   %r15,%rdx
    90ff:	48 0f ca             	bswap  %rdx
    9102:	48 01 da             	add    %rbx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:350
  uint64_t y = (bswap_64((v + w) * mul) + g) * mul;
    9105:	4c 01 c2             	add    %r8,%rdx
    9108:	49 0f af d7          	imul   %r15,%rdx
    910c:	48 0f ca             	bswap  %rdx
/home/austen/programming/dm-afs/src/lib/city.c:352
  a = bswap_64((x + z) * mul + y) + b;
    910f:	48 01 c2             	add    %rax,%rdx
    9112:	4c 01 ea             	add    %r13,%rdx
    9115:	48 01 fa             	add    %rdi,%rdx
    9118:	49 0f af d7          	imul   %r15,%rdx
    911c:	48 0f ca             	bswap  %rdx
    911f:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
/home/austen/programming/dm-afs/src/lib/city.c:353
  b = ShiftMix((z + a) * mul + d + h) * mul;
    9123:	4c 01 e8             	add    %r13,%rax
    9126:	49 0f af c7          	imul   %r15,%rax
    912a:	48 01 c6             	add    %rax,%rsi
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    912d:	48 89 f0             	mov    %rsi,%rax
    9130:	48 c1 e8 2f          	shr    $0x2f,%rax
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:395
}
    9134:	48 83 c4 30          	add    $0x30,%rsp
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    9138:	48 31 f0             	xor    %rsi,%rax
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:353
  b = ShiftMix((z + a) * mul + d + h) * mul;
    913b:	49 0f af c7          	imul   %r15,%rax
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:395
}
    913f:	5b                   	pop    %rbx
    9140:	41 5c                	pop    %r12
    9142:	41 5d                	pop    %r13
HashLen33to64():
/home/austen/programming/dm-afs/src/lib/city.c:354
  return b + x;
    9144:	48 01 f8             	add    %rdi,%rax
CityHash64():
/home/austen/programming/dm-afs/src/lib/city.c:395
}
    9147:	41 5e                	pop    %r14
    9149:	41 5f                	pop    %r15
    914b:	5d                   	pop    %rbp
    914c:	c3                   	retq   
    914d:	0f 1f 00             	nopl   (%rax)

0000000000009150 <CityHash64WithSeeds>:
CityHash64WithSeeds():
/home/austen/programming/dm-afs/src/lib/city.c:402
                           uint64_t seed0, uint64_t seed1) {
    9150:	e8 00 00 00 00       	callq  9155 <CityHash64WithSeeds+0x5>
			9151: R_X86_64_PC32	__fentry__-0x4
    9155:	55                   	push   %rbp
    9156:	48 89 e5             	mov    %rsp,%rbp
    9159:	41 54                	push   %r12
    915b:	53                   	push   %rbx
    915c:	49 89 d4             	mov    %rdx,%r12
    915f:	48 89 cb             	mov    %rcx,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:403
  return HashLen16(CityHash64(s, len) - seed0, seed1);
    9162:	e8 00 00 00 00       	callq  9167 <CityHash64WithSeeds+0x17>
			9163: R_X86_64_PC32	CityHash64-0x4
    9167:	4c 29 e0             	sub    %r12,%rax
    916a:	48 89 c6             	mov    %rax,%rsi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    916d:	48 b8 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rax
    9174:	ea df 9d 
    9177:	48 31 de             	xor    %rbx,%rsi
    917a:	48 0f af f0          	imul   %rax,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    917e:	48 31 f3             	xor    %rsi,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9181:	48 89 f2             	mov    %rsi,%rdx
    9184:	48 c1 ea 2f          	shr    $0x2f,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9188:	48 89 d9             	mov    %rbx,%rcx
    918b:	48 31 d1             	xor    %rdx,%rcx
    918e:	48 0f af c8          	imul   %rax,%rcx
CityHash64WithSeeds():
/home/austen/programming/dm-afs/src/lib/city.c:404
}
    9192:	5b                   	pop    %rbx
    9193:	41 5c                	pop    %r12
    9195:	5d                   	pop    %rbp
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9196:	48 89 ca             	mov    %rcx,%rdx
    9199:	48 c1 ea 2f          	shr    $0x2f,%rdx
    919d:	48 31 d1             	xor    %rdx,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    91a0:	48 0f af c1          	imul   %rcx,%rax
CityHash64WithSeeds():
/home/austen/programming/dm-afs/src/lib/city.c:404
}
    91a4:	c3                   	retq   
    91a5:	90                   	nop
    91a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    91ad:	00 00 00 

00000000000091b0 <CityHash64WithSeed>:
CityHash64WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:397
uint64_t CityHash64WithSeed(const uint8_t *s, size_t len, uint64_t seed) {
    91b0:	e8 00 00 00 00       	callq  91b5 <CityHash64WithSeed+0x5>
			91b1: R_X86_64_PC32	__fentry__-0x4
    91b5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/city.c:398
  return CityHash64WithSeeds(s, len, k2, seed);
    91b6:	48 89 d1             	mov    %rdx,%rcx
    91b9:	48 ba 4f 40 90 2f 3b 	movabs $0x9ae16a3b2f90404f,%rdx
    91c0:	6a e1 9a 
/home/austen/programming/dm-afs/src/lib/city.c:397
uint64_t CityHash64WithSeed(const uint8_t *s, size_t len, uint64_t seed) {
    91c3:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/city.c:398
  return CityHash64WithSeeds(s, len, k2, seed);
    91c6:	e8 00 00 00 00       	callq  91cb <CityHash64WithSeed+0x1b>
			91c7: R_X86_64_PC32	CityHash64WithSeeds-0x4
/home/austen/programming/dm-afs/src/lib/city.c:399
}
    91cb:	5d                   	pop    %rbp
    91cc:	c3                   	retq   
    91cd:	0f 1f 00             	nopl   (%rax)

00000000000091d0 <CityHash128WithSeed>:
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:441
uint128 CityHash128WithSeed(const uint8_t *s, size_t len, uint128 seed) {
    91d0:	e8 00 00 00 00       	callq  91d5 <CityHash128WithSeed+0x5>
			91d1: R_X86_64_PC32	__fentry__-0x4
    91d5:	55                   	push   %rbp
    91d6:	48 89 e5             	mov    %rsp,%rbp
    91d9:	41 57                	push   %r15
    91db:	41 56                	push   %r14
    91dd:	41 55                	push   %r13
    91df:	41 54                	push   %r12
    91e1:	49 89 cc             	mov    %rcx,%r12
    91e4:	53                   	push   %rbx
    91e5:	48 89 fb             	mov    %rdi,%rbx
    91e8:	48 83 ec 48          	sub    $0x48,%rsp
/home/austen/programming/dm-afs/src/lib/city.c:446
  if (len < 128) {
    91ec:	48 83 fe 7f          	cmp    $0x7f,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:441
uint128 CityHash128WithSeed(const uint8_t *s, size_t len, uint128 seed) {
    91f0:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
    91f4:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:446
  if (len < 128) {
    91f8:	0f 86 01 04 00 00    	jbe    95ff <CityHash128WithSeed+0x42f>
/home/austen/programming/dm-afs/src/lib/city.c:454
  z = len * k1;
    91fe:	4c 8b 6d 90          	mov    -0x70(%rbp),%r13
    9202:	49 bf 73 f2 98 be 6f 	movabs $0xb492b66fbe98f273,%r15
    9209:	b6 92 b4 
    920c:	4d 0f af ef          	imul   %r15,%r13
    9210:	4c 89 6d c0          	mov    %r13,-0x40(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9214:	e8 57 e8 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:455
  v.first = Rotate(y ^ k1, 49) * k1 + Fetch64(s);
    9219:	4c 89 e6             	mov    %r12,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:456
  v.second = Rotate(v.first, 42) * k1 + Fetch64(s + 8);
    921c:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:455
  v.first = Rotate(y ^ k1, 49) * k1 + Fetch64(s);
    9220:	4c 31 fe             	xor    %r15,%rsi
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    9223:	48 c1 c6 0f          	rol    $0xf,%rsi
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:455
  v.first = Rotate(y ^ k1, 49) * k1 + Fetch64(s);
    9227:	49 0f af f7          	imul   %r15,%rsi
    922b:	4c 8d 34 06          	lea    (%rsi,%rax,1),%r14
    922f:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    9233:	49 c1 c6 16          	rol    $0x16,%r14
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9237:	e8 34 e8 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:457
  w.first = Rotate(y + z, 35) * k1 + x;
    923c:	4b 8d 14 2c          	lea    (%r12,%r13,1),%rdx
    9240:	4c 8b 6d d0          	mov    -0x30(%rbp),%r13
/home/austen/programming/dm-afs/src/lib/city.c:458
  w.second = Rotate(x + Fetch64(s + 88), 53) * k1;
    9244:	48 8d 7b 58          	lea    0x58(%rbx),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:456
  v.second = Rotate(v.first, 42) * k1 + Fetch64(s + 8);
    9248:	4d 0f af f7          	imul   %r15,%r14
    924c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    9250:	48 c1 c2 1d          	rol    $0x1d,%rdx
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:457
  w.first = Rotate(y + z, 35) * k1 + x;
    9254:	49 0f af d7          	imul   %r15,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:456
  v.second = Rotate(v.first, 42) * k1 + Fetch64(s + 8);
    9258:	49 01 c6             	add    %rax,%r14
/home/austen/programming/dm-afs/src/lib/city.c:457
  w.first = Rotate(y + z, 35) * k1 + x;
    925b:	4c 01 ea             	add    %r13,%rdx
    925e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9262:	e8 09 e8 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:458
  w.second = Rotate(x + Fetch64(s + 88), 53) * k1;
    9267:	4d 8d 6c 05 00       	lea    0x0(%r13,%rax,1),%r13
    926c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:462
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    9270:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    9274:	49 c1 c5 0b          	rol    $0xb,%r13
    9278:	48 83 c0 80          	add    $0xffffffffffffff80,%rax
    927c:	48 83 e0 80          	and    $0xffffffffffffff80,%rax
    9280:	48 8d 84 03 80 00 00 	lea    0x80(%rbx,%rax,1),%rax
    9287:	00 
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:458
  w.second = Rotate(x + Fetch64(s + 88), 53) * k1;
    9288:	4d 0f af ef          	imul   %r15,%r13
    928c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    9290:	eb 13                	jmp    92a5 <CityHash128WithSeed+0xd5>
    9292:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    9296:	48 81 c7 88 00 00 00 	add    $0x88,%rdi
    929d:	e8 ce e7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
    92a2:	48 89 c1             	mov    %rax,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:462 (discriminator 1)
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    92a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    92a9:	48 8d 7b 30          	lea    0x30(%rbx),%rdi
    92ad:	48 89 5d a0          	mov    %rbx,-0x60(%rbp)
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:462 (discriminator 1)
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    92b1:	4c 01 e0             	add    %r12,%rax
    92b4:	48 03 45 d0          	add    -0x30(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:463 (discriminator 1)
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    92b8:	4d 01 f4             	add    %r14,%r12
/home/austen/programming/dm-afs/src/lib/city.c:467 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    92bb:	4d 0f af f7          	imul   %r15,%r14
/home/austen/programming/dm-afs/src/lib/city.c:462 (discriminator 1)
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    92bf:	48 01 c8             	add    %rcx,%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    92c2:	48 c1 c0 1b          	rol    $0x1b,%rax
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:462 (discriminator 1)
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    92c6:	49 0f af c7          	imul   %r15,%rax
    92ca:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    92ce:	e8 9d e7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:463 (discriminator 1)
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    92d3:	49 01 c4             	add    %rax,%r12
/home/austen/programming/dm-afs/src/lib/city.c:464 (discriminator 1)
    x ^= w.second;
    92d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    92da:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    92de:	49 c1 c4 16          	rol    $0x16,%r12
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:463 (discriminator 1)
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    92e2:	4d 0f af e7          	imul   %r15,%r12
/home/austen/programming/dm-afs/src/lib/city.c:464 (discriminator 1)
    x ^= w.second;
    92e6:	4c 31 e8             	xor    %r13,%rax
    92e9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    92ed:	e8 7e e7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:466 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    92f2:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
/home/austen/programming/dm-afs/src/lib/city.c:465 (discriminator 1)
    y += v.first + Fetch64(s + 40);
    92f6:	48 03 45 c8          	add    -0x38(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:467 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    92fa:	48 89 df             	mov    %rbx,%rdi
/home/austen/programming/dm-afs/src/lib/city.c:466 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    92fd:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    9301:	48 01 ce             	add    %rcx,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:465 (discriminator 1)
    y += v.first + Fetch64(s + 40);
    9304:	49 01 c4             	add    %rax,%r12
/home/austen/programming/dm-afs/src/lib/city.c:467 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    9307:	48 03 4d d0          	add    -0x30(%rbp),%rcx
/home/austen/programming/dm-afs/src/lib/city.c:466 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    930b:	48 89 f0             	mov    %rsi,%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    930e:	48 c1 c0 1f          	rol    $0x1f,%rax
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:466 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    9312:	48 89 c6             	mov    %rax,%rsi
    9315:	49 0f af f7          	imul   %r15,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:467 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    9319:	48 89 ca             	mov    %rcx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:466 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    931c:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:467 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    9320:	4c 89 f6             	mov    %r14,%rsi
    9323:	e8 58 e7 ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9328:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:467 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    932c:	49 89 d6             	mov    %rdx,%r14
    932f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9333:	e8 38 e7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:468 (discriminator 1)
    w = WeakHashLen32WithSeedsArray(s + 32, z + w.second, y + Fetch64(s + 16));
    9338:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    933c:	48 8d 7b 20          	lea    0x20(%rbx),%rdi
    9340:	49 8d 14 04          	lea    (%r12,%rax,1),%rdx
    9344:	4c 01 ee             	add    %r13,%rsi
    9347:	e8 34 e7 ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    934c:	48 8d 7b 48          	lea    0x48(%rbx),%rdi
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:468 (discriminator 1)
    w = WeakHashLen32WithSeedsArray(s + 32, z + w.second, y + Fetch64(s + 16));
    9350:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    9354:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9358:	e8 13 e7 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:471 (discriminator 1)
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    935d:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9361:	48 8d 7b 70          	lea    0x70(%rbx),%rdi
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:471 (discriminator 1)
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    9365:	4d 8d 2c 00          	lea    (%r8,%rax,1),%r13
    9369:	4c 03 6d c8          	add    -0x38(%rbp),%r13
    936d:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9371:	e8 fa e6 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:473 (discriminator 1)
    x ^= w.second;
    9376:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
/home/austen/programming/dm-afs/src/lib/city.c:472 (discriminator 1)
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    937a:	4c 01 f0             	add    %r14,%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    937d:	48 8d 7b 68          	lea    0x68(%rbx),%rdi
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:471 (discriminator 1)
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    9381:	4d 01 e5             	add    %r12,%r13
/home/austen/programming/dm-afs/src/lib/city.c:472 (discriminator 1)
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    9384:	49 01 c4             	add    %rax,%r12
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    9387:	49 c1 c5 1b          	rol    $0x1b,%r13
    938b:	49 c1 c4 16          	rol    $0x16,%r12
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:473 (discriminator 1)
    x ^= w.second;
    938f:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:471 (discriminator 1)
    x = Rotate(x + y + v.first + Fetch64(s + 8), 37) * k1;
    9393:	4d 0f af ef          	imul   %r15,%r13
/home/austen/programming/dm-afs/src/lib/city.c:472 (discriminator 1)
    y = Rotate(y + v.second + Fetch64(s + 48), 42) * k1;
    9397:	4d 0f af e7          	imul   %r15,%r12
/home/austen/programming/dm-afs/src/lib/city.c:473 (discriminator 1)
    x ^= w.second;
    939b:	4d 31 cd             	xor    %r9,%r13
    939e:	4c 89 6d c0          	mov    %r13,-0x40(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    93a2:	e8 c9 e6 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:474 (discriminator 1)
    y += v.first + Fetch64(s + 40);
    93a7:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
/home/austen/programming/dm-afs/src/lib/city.c:475 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    93ab:	4c 8b 55 a8          	mov    -0x58(%rbp),%r10
/home/austen/programming/dm-afs/src/lib/city.c:476 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    93af:	4c 89 f6             	mov    %r14,%rsi
    93b2:	49 0f af f7          	imul   %r15,%rsi
    93b6:	48 8d 7b 40          	lea    0x40(%rbx),%rdi
/home/austen/programming/dm-afs/src/lib/city.c:474 (discriminator 1)
    y += v.first + Fetch64(s + 40);
    93ba:	49 01 c0             	add    %rax,%r8
/home/austen/programming/dm-afs/src/lib/city.c:475 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    93bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:476 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    93c1:	4b 8d 14 2a          	lea    (%r10,%r13,1),%rdx
/home/austen/programming/dm-afs/src/lib/city.c:474 (discriminator 1)
    y += v.first + Fetch64(s + 40);
    93c5:	4d 01 c4             	add    %r8,%r12
/home/austen/programming/dm-afs/src/lib/city.c:475 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    93c8:	4c 01 d0             	add    %r10,%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249 (discriminator 1)
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    93cb:	48 c1 c0 1f          	rol    $0x1f,%rax
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:475 (discriminator 1)
    z = Rotate(z + w.first, 33) * k1;
    93cf:	49 0f af c7          	imul   %r15,%rax
    93d3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:476 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    93d7:	e8 a4 e6 ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    93dc:	48 8d 7b 50          	lea    0x50(%rbx),%rdi
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:476 (discriminator 1)
    v = WeakHashLen32WithSeedsArray(s, v.second * k1, x + w.first);
    93e0:	49 89 d6             	mov    %rdx,%r14
    93e3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97 (discriminator 1)
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    93e7:	e8 84 e6 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:477 (discriminator 1)
    w = WeakHashLen32WithSeedsArray(s + 32, z + w.second, y + Fetch64(s + 16));
    93ec:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    93f0:	4a 8d 14 20          	lea    (%rax,%r12,1),%rdx
    93f4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    93f8:	48 8d 7b 60          	lea    0x60(%rbx),%rdi
    93fc:	48 83 eb 80          	sub    $0xffffffffffffff80,%rbx
    9400:	49 8d 34 01          	lea    (%r9,%rax,1),%rsi
    9404:	e8 77 e6 ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
/home/austen/programming/dm-afs/src/lib/city.c:481 (discriminator 1)
  } while (LIKELY(len >= 128));
    9409:	48 3b 5d 98          	cmp    -0x68(%rbp),%rbx
/home/austen/programming/dm-afs/src/lib/city.c:477 (discriminator 1)
    w = WeakHashLen32WithSeedsArray(s + 32, z + w.second, y + Fetch64(s + 16));
    940d:	49 89 d1             	mov    %rdx,%r9
    9410:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    9414:	49 89 d5             	mov    %rdx,%r13
/home/austen/programming/dm-afs/src/lib/city.c:481 (discriminator 1)
  } while (LIKELY(len >= 128));
    9417:	0f 85 75 fe ff ff    	jne    9292 <CityHash128WithSeed+0xc2>
/home/austen/programming/dm-afs/src/lib/city.c:482
  x += Rotate(v.first + z, 49) * k0;
    941d:	48 ba 27 31 cb 97 5c 	movabs $0xc3a5c85c97cb3127,%rdx
    9424:	c8 a5 c3 
    9427:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    942b:	4c 89 c8             	mov    %r9,%rax
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:483
  y = y * k0 + Rotate(w.second, 37);
    942e:	4c 0f af e2          	imul   %rdx,%r12
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    9432:	48 c1 c0 1b          	rol    $0x1b,%rax
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:482
  x += Rotate(v.first + z, 49) * k0;
    9436:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    943a:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:482
  x += Rotate(v.first + z, 49) * k0;
    943e:	49 89 f7             	mov    %rsi,%r15
/home/austen/programming/dm-afs/src/lib/city.c:483
  y = y * k0 + Rotate(w.second, 37);
    9441:	4c 01 e0             	add    %r12,%rax
/home/austen/programming/dm-afs/src/lib/city.c:482
  x += Rotate(v.first + z, 49) * k0;
    9444:	49 01 cf             	add    %rcx,%r15
/home/austen/programming/dm-afs/src/lib/city.c:483
  y = y * k0 + Rotate(w.second, 37);
    9447:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:484
  z = z * k0 + Rotate(w.first, 27);
    944b:	48 89 c8             	mov    %rcx,%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    944e:	48 89 f9             	mov    %rdi,%rcx
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:484
  z = z * k0 + Rotate(w.first, 27);
    9451:	48 0f af c2          	imul   %rdx,%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    9455:	48 c1 c9 1b          	ror    $0x1b,%rcx
    9459:	49 c1 c7 0f          	rol    $0xf,%r15
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:482
  x += Rotate(v.first + z, 49) * k0;
    945d:	4c 0f af fa          	imul   %rdx,%r15
    9461:	4c 03 7d d0          	add    -0x30(%rbp),%r15
/home/austen/programming/dm-afs/src/lib/city.c:484
  z = z * k0 + Rotate(w.first, 27);
    9465:	48 01 c8             	add    %rcx,%rax
    9468:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:485
  w.first *= 9;
    946c:	48 8d 04 ff          	lea    (%rdi,%rdi,8),%rax
/home/austen/programming/dm-afs/src/lib/city.c:486
  v.first *= k0;
    9470:	48 0f af f2          	imul   %rdx,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:485
  w.first *= 9;
    9474:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:488
  for (tail_done = 0; tail_done < len; ) {
    9478:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    947c:	83 e0 7f             	and    $0x7f,%eax
/home/austen/programming/dm-afs/src/lib/city.c:486
  v.first *= k0;
    947f:	49 89 f0             	mov    %rsi,%r8
/home/austen/programming/dm-afs/src/lib/city.c:488
  for (tail_done = 0; tail_done < len; ) {
    9482:	0f 84 9c 00 00 00    	je     9524 <CityHash128WithSeed+0x354>
    9488:	4c 8d 64 03 f0       	lea    -0x10(%rbx,%rax,1),%r12
    948d:	48 8d 48 d0          	lea    -0x30(%rax),%rcx
    9491:	48 83 e8 01          	sub    $0x1,%rax
    9495:	48 83 e0 e0          	and    $0xffffffffffffffe0,%rax
    9499:	48 29 c1             	sub    %rax,%rcx
    949c:	48 89 c8             	mov    %rcx,%rax
    949f:	48 01 d8             	add    %rbx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:490
    y = Rotate(x + y, 42) * k0 + v.second;
    94a2:	48 89 d3             	mov    %rdx,%rbx
    94a5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    94a9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    94ad:	4c 89 e7             	mov    %r12,%rdi
    94b0:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:490
    y = Rotate(x + y, 42) * k0 + v.second;
    94b4:	4c 01 f8             	add    %r15,%rax
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    94b7:	48 c1 c0 16          	rol    $0x16,%rax
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:490
    y = Rotate(x + y, 42) * k0 + v.second;
    94bb:	48 0f af c3          	imul   %rbx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:492
    x = x * k0 + w.first;
    94bf:	4c 0f af fb          	imul   %rbx,%r15
/home/austen/programming/dm-afs/src/lib/city.c:490
    y = Rotate(x + y, 42) * k0 + v.second;
    94c3:	4c 01 f0             	add    %r14,%rax
    94c6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    94ca:	e8 a1 e5 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:491
    w.first += Fetch64(s + len - tail_done + 16);
    94cf:	48 01 45 d0          	add    %rax,-0x30(%rbp)
    94d3:	49 8d 4c 24 f0       	lea    -0x10(%r12),%rcx
    94d8:	49 83 ec 20          	sub    $0x20,%r12
    94dc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    94e0:	48 89 cf             	mov    %rcx,%rdi
    94e3:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:492
    x = x * k0 + w.first;
    94e7:	49 01 c7             	add    %rax,%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    94ea:	e8 81 e5 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:493
    z += w.second + Fetch64(s + len - tail_done);
    94ef:	4c 01 e8             	add    %r13,%rax
    94f2:	48 01 45 c8          	add    %rax,-0x38(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:494
    w.second += v.first;
    94f6:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
/home/austen/programming/dm-afs/src/lib/city.c:493
    z += w.second + Fetch64(s + len - tail_done);
    94fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
/home/austen/programming/dm-afs/src/lib/city.c:495
    v = WeakHashLen32WithSeedsArray(s + len - tail_done, v.first + z, v.second);
    94fe:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    9502:	4c 89 f2             	mov    %r14,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:494
    w.second += v.first;
    9505:	4d 01 c5             	add    %r8,%r13
/home/austen/programming/dm-afs/src/lib/city.c:495
    v = WeakHashLen32WithSeedsArray(s + len - tail_done, v.first + z, v.second);
    9508:	4a 8d 34 00          	lea    (%rax,%r8,1),%rsi
    950c:	48 89 cf             	mov    %rcx,%rdi
    950f:	e8 6c e5 ff ff       	callq  7a80 <WeakHashLen32WithSeedsArray>
    9514:	49 89 c0             	mov    %rax,%r8
    9517:	49 89 d6             	mov    %rdx,%r14
/home/austen/programming/dm-afs/src/lib/city.c:496
    v.first *= k0;
    951a:	4c 0f af c3          	imul   %rbx,%r8
/home/austen/programming/dm-afs/src/lib/city.c:488
  for (tail_done = 0; tail_done < len; ) {
    951e:	4c 39 65 a8          	cmp    %r12,-0x58(%rbp)
    9522:	75 85                	jne    94a9 <CityHash128WithSeed+0x2d9>
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9524:	48 bf 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rdi
    952b:	ea df 9d 
    952e:	4d 31 c7             	xor    %r8,%r15
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:502
  y = HashLen16(y + z, w.first);
    9531:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9535:	4c 0f af ff          	imul   %rdi,%r15
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:502
  y = HashLen16(y + z, w.first);
    9539:	48 03 45 c8          	add    -0x38(%rbp),%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    953d:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9541:	4c 89 fe             	mov    %r15,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9544:	4d 31 f8             	xor    %r15,%r8
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9547:	48 31 d8             	xor    %rbx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    954a:	48 c1 ee 2f          	shr    $0x2f,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    954e:	49 31 f0             	xor    %rsi,%r8
    9551:	4c 0f af c7          	imul   %rdi,%r8
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9555:	48 0f af c7          	imul   %rdi,%rax
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9559:	4d 89 c7             	mov    %r8,%r15
    955c:	49 c1 ef 2f          	shr    $0x2f,%r15
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9560:	48 31 c3             	xor    %rax,%rbx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9563:	48 89 c2             	mov    %rax,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9566:	4d 31 f8             	xor    %r15,%r8
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9569:	48 c1 ea 2f          	shr    $0x2f,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    956d:	49 89 dc             	mov    %rbx,%r12
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    9570:	4c 0f af c7          	imul   %rdi,%r8
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9574:	49 31 d4             	xor    %rdx,%r12
    9577:	4c 0f af e7          	imul   %rdi,%r12
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:503
  output.first = HashLen16(x+v.second, w.second) + y;
    957b:	4b 8d 14 30          	lea    (%r8,%r14,1),%rdx
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    957f:	4c 89 e6             	mov    %r12,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9582:	4c 31 ea             	xor    %r13,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9585:	48 c1 ee 2f          	shr    $0x2f,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9589:	48 0f af d7          	imul   %rdi,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    958d:	49 31 f4             	xor    %rsi,%r12
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    9590:	4c 0f af e7          	imul   %rdi,%r12
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9594:	48 89 d0             	mov    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9597:	4c 31 ea             	xor    %r13,%rdx
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:504
  output.second = HashLen16(x+w.second, y+v.second);
    959a:	4d 01 c5             	add    %r8,%r13
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    959d:	48 c1 e8 2f          	shr    $0x2f,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    95a1:	48 31 d0             	xor    %rdx,%rax
    95a4:	48 0f af c7          	imul   %rdi,%rax
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    95a8:	48 89 c2             	mov    %rax,%rdx
    95ab:	48 c1 ea 2f          	shr    $0x2f,%rdx
    95af:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    95b2:	48 0f af c7          	imul   %rdi,%rax
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:503
  output.first = HashLen16(x+v.second, w.second) + y;
    95b6:	4c 01 e0             	add    %r12,%rax
/home/austen/programming/dm-afs/src/lib/city.c:504
  output.second = HashLen16(x+w.second, y+v.second);
    95b9:	4d 01 f4             	add    %r14,%r12
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    95bc:	4d 31 e5             	xor    %r12,%r13
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:503
  output.first = HashLen16(x+v.second, w.second) + y;
    95bf:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 95c6 <CityHash128WithSeed+0x3f6>
			95c2: R_X86_64_PC32	.bss+0xa695c
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    95c6:	4c 0f af ef          	imul   %rdi,%r13
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    95ca:	4d 89 ee             	mov    %r13,%r14
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    95cd:	4d 31 ec             	xor    %r13,%r12
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    95d0:	49 c1 ee 2f          	shr    $0x2f,%r14
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    95d4:	4d 31 e6             	xor    %r12,%r14
    95d7:	4c 0f af f7          	imul   %rdi,%r14
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    95db:	4c 89 f2             	mov    %r14,%rdx
    95de:	48 c1 ea 2f          	shr    $0x2f,%rdx
    95e2:	4c 31 f2             	xor    %r14,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    95e5:	48 0f af d7          	imul   %rdi,%rdx
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:504
  output.second = HashLen16(x+w.second, y+v.second);
    95e9:	48 89 15 00 00 00 00 	mov    %rdx,0x0(%rip)        # 95f0 <CityHash128WithSeed+0x420>
			95ec: R_X86_64_PC32	.bss+0xa6964
/home/austen/programming/dm-afs/src/lib/city.c:506
}
    95f0:	48 83 c4 48          	add    $0x48,%rsp
    95f4:	5b                   	pop    %rbx
    95f5:	41 5c                	pop    %r12
    95f7:	41 5d                	pop    %r13
    95f9:	41 5e                	pop    %r14
    95fb:	41 5f                	pop    %r15
    95fd:	5d                   	pop    %rbp
    95fe:	c3                   	retq   
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:414
  signed long l = len - 16;
    95ff:	4c 8d 46 f0          	lea    -0x10(%rsi),%r8
    9603:	49 89 d6             	mov    %rdx,%r14
/home/austen/programming/dm-afs/src/lib/city.c:415
  if (l <= 0) {  // len <= 16
    9606:	4d 85 c0             	test   %r8,%r8
    9609:	0f 8e b8 01 00 00    	jle    97c7 <CityHash128WithSeed+0x5f7>
/home/austen/programming/dm-afs/src/lib/city.c:420
    c = HashLen16(Fetch64(s + len - 8) + k1, a);
    960f:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
    9613:	4c 89 45 d0          	mov    %r8,-0x30(%rbp)
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9617:	49 bd 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%r13
    961e:	ea df 9d 
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:420
    c = HashLen16(Fetch64(s + len - 8) + k1, a);
    9621:	48 8d 7c 0f f8       	lea    -0x8(%rdi,%rcx,1),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9626:	e8 45 e4 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:420
    c = HashLen16(Fetch64(s + len - 8) + k1, a);
    962b:	48 b9 73 f2 98 be 6f 	movabs $0xb492b66fbe98f273,%rcx
    9632:	b6 92 b4 
/home/austen/programming/dm-afs/src/lib/city.c:421
    d = HashLen16(b + len, c + Fetch64(s + len - 16));
    9635:	4c 8b 45 d0          	mov    -0x30(%rbp),%r8
/home/austen/programming/dm-afs/src/lib/city.c:420
    c = HashLen16(Fetch64(s + len - 8) + k1, a);
    9639:	48 8d 14 08          	lea    (%rax,%rcx,1),%rdx
    963d:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9641:	4c 31 f2             	xor    %r14,%rdx
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:421
    d = HashLen16(b + len, c + Fetch64(s + len - 16));
    9644:	4a 8d 3c 03          	lea    (%rbx,%r8,1),%rdi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9648:	49 0f af d5          	imul   %r13,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    964c:	48 89 d6             	mov    %rdx,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    964f:	4c 31 f2             	xor    %r14,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9652:	48 c1 ee 2f          	shr    $0x2f,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9656:	48 31 f2             	xor    %rsi,%rdx
    9659:	49 0f af d5          	imul   %r13,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    965d:	48 89 d0             	mov    %rdx,%rax
    9660:	48 c1 e8 2f          	shr    $0x2f,%rax
    9664:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    9667:	49 0f af c5          	imul   %r13,%rax
    966b:	49 89 c7             	mov    %rax,%r15
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    966e:	e8 fd e3 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:421
    d = HashLen16(b + len, c + Fetch64(s + len - 16));
    9673:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
    9677:	49 8d 14 07          	lea    (%r15,%rax,1),%rdx
    967b:	49 8d 3c 0c          	lea    (%r12,%rcx,1),%rdi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    967f:	48 31 d7             	xor    %rdx,%rdi
    9682:	49 0f af fd          	imul   %r13,%rdi
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9686:	48 89 f8             	mov    %rdi,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9689:	48 31 fa             	xor    %rdi,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    968c:	48 c1 e8 2f          	shr    $0x2f,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9690:	48 31 d0             	xor    %rdx,%rax
    9693:	49 0f af c5          	imul   %r13,%rax
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9697:	48 89 c2             	mov    %rax,%rdx
    969a:	48 c1 ea 2f          	shr    $0x2f,%rdx
    969e:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    96a1:	49 0f af c5          	imul   %r13,%rax
    96a5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:422
    a += d;
    96a9:	49 01 c6             	add    %rax,%r14
    96ac:	48 8d 41 ef          	lea    -0x11(%rcx),%rax
/home/austen/programming/dm-afs/src/lib/city.c:424
      a ^= ShiftMix(Fetch64(s) * k1) * k1;
    96b0:	48 b9 73 f2 98 be 6f 	movabs $0xb492b66fbe98f273,%rcx
    96b7:	b6 92 b4 
    96ba:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    96be:	49 89 cd             	mov    %rcx,%r13
    96c1:	48 8d 44 03 10       	lea    0x10(%rbx,%rax,1),%rax
    96c6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    96ca:	48 89 df             	mov    %rbx,%rdi
    96cd:	e8 9e e3 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:424
      a ^= ShiftMix(Fetch64(s) * k1) * k1;
    96d2:	49 0f af c5          	imul   %r13,%rax
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    96d6:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:430
      s += 16;
    96da:	48 83 c3 10          	add    $0x10,%rbx
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    96de:	48 89 c2             	mov    %rax,%rdx
    96e1:	48 c1 ea 2f          	shr    $0x2f,%rdx
    96e5:	48 31 c2             	xor    %rax,%rdx
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:424
      a ^= ShiftMix(Fetch64(s) * k1) * k1;
    96e8:	49 0f af d5          	imul   %r13,%rdx
    96ec:	49 31 d6             	xor    %rdx,%r14
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    96ef:	e8 7c e3 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:427
      c ^= ShiftMix(Fetch64(s + 8) * k1) * k1;
    96f4:	49 0f af c5          	imul   %r13,%rax
/home/austen/programming/dm-afs/src/lib/city.c:425
      a *= k1;
    96f8:	4d 0f af f5          	imul   %r13,%r14
/home/austen/programming/dm-afs/src/lib/city.c:427
      c ^= ShiftMix(Fetch64(s + 8) * k1) * k1;
    96fc:	48 89 c2             	mov    %rax,%rdx
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    96ff:	48 c1 e8 2f          	shr    $0x2f,%rax
    9703:	48 31 d0             	xor    %rdx,%rax
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:426
      b ^= a;
    9706:	4d 31 f4             	xor    %r14,%r12
/home/austen/programming/dm-afs/src/lib/city.c:427
      c ^= ShiftMix(Fetch64(s + 8) * k1) * k1;
    9709:	49 0f af c5          	imul   %r13,%rax
    970d:	4c 31 f8             	xor    %r15,%rax
/home/austen/programming/dm-afs/src/lib/city.c:428
      c *= k1;
    9710:	49 0f af c5          	imul   %r13,%rax
/home/austen/programming/dm-afs/src/lib/city.c:429
      d ^= c;
    9714:	48 31 45 d0          	xor    %rax,-0x30(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:432
    } while (l > 0);
    9718:	48 3b 5d c8          	cmp    -0x38(%rbp),%rbx
/home/austen/programming/dm-afs/src/lib/city.c:428
      c *= k1;
    971c:	49 89 c7             	mov    %rax,%r15
/home/austen/programming/dm-afs/src/lib/city.c:432
    } while (l > 0);
    971f:	75 a9                	jne    96ca <CityHash128WithSeed+0x4fa>
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9721:	4d 31 fe             	xor    %r15,%r14
    9724:	48 bf 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rdi
    972b:	ea df 9d 
    972e:	4c 8b 6d d0          	mov    -0x30(%rbp),%r13
    9732:	4c 89 f0             	mov    %r14,%rax
    9735:	48 0f af c7          	imul   %rdi,%rax
    9739:	4d 31 e5             	xor    %r12,%r13
    973c:	4c 0f af ef          	imul   %rdi,%r13
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9740:	48 89 c2             	mov    %rax,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9743:	4c 31 f8             	xor    %r15,%rax
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9746:	48 c1 ea 2f          	shr    $0x2f,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    974a:	48 31 d0             	xor    %rdx,%rax
    974d:	4d 31 ec             	xor    %r13,%r12
    9750:	48 0f af c7          	imul   %rdi,%rax
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9754:	48 89 c2             	mov    %rax,%rdx
    9757:	48 c1 ea 2f          	shr    $0x2f,%rdx
    975b:	48 31 d0             	xor    %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    975e:	48 0f af c7          	imul   %rdi,%rax
    9762:	48 89 c2             	mov    %rax,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9765:	4c 89 e8             	mov    %r13,%rax
    9768:	48 c1 e8 2f          	shr    $0x2f,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    976c:	4c 31 e0             	xor    %r12,%rax
    976f:	48 0f af c7          	imul   %rdi,%rax
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9773:	49 89 c4             	mov    %rax,%r12
    9776:	49 c1 ec 2f          	shr    $0x2f,%r12
    977a:	4c 31 e0             	xor    %r12,%rax
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    977d:	48 0f af c7          	imul   %rdi,%rax
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:436
  output.first = a^b;
    9781:	48 31 d0             	xor    %rdx,%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9784:	48 89 c6             	mov    %rax,%rsi
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:436
  output.first = a^b;
    9787:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 978e <CityHash128WithSeed+0x5be>
			978a: R_X86_64_PC32	.bss+0xa694c
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    978e:	48 0f af f7          	imul   %rdi,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9792:	48 89 f1             	mov    %rsi,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9795:	48 31 f2             	xor    %rsi,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9798:	48 c1 e9 2f          	shr    $0x2f,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    979c:	48 31 d1             	xor    %rdx,%rcx
    979f:	48 0f af cf          	imul   %rdi,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    97a3:	48 89 ca             	mov    %rcx,%rdx
    97a6:	48 c1 ea 2f          	shr    $0x2f,%rdx
    97aa:	48 31 ca             	xor    %rcx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:92
  b *= kMul;
    97ad:	48 0f af d7          	imul   %rdi,%rdx
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:437
  output.second = HashLen16(b, a);
    97b1:	48 89 15 00 00 00 00 	mov    %rdx,0x0(%rip)        # 97b8 <CityHash128WithSeed+0x5e8>
			97b4: R_X86_64_PC32	.bss+0xa6954
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:506
}
    97b8:	48 83 c4 48          	add    $0x48,%rsp
    97bc:	5b                   	pop    %rbx
    97bd:	41 5c                	pop    %r12
    97bf:	41 5d                	pop    %r13
    97c1:	41 5e                	pop    %r14
    97c3:	41 5f                	pop    %r15
    97c5:	5d                   	pop    %rbp
    97c6:	c3                   	retq   
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:416
    a = ShiftMix(a * k1) * k1;
    97c7:	49 bd 73 f2 98 be 6f 	movabs $0xb492b66fbe98f273,%r13
    97ce:	b6 92 b4 
    97d1:	4d 0f af f5          	imul   %r13,%r14
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    97d5:	4c 89 f0             	mov    %r14,%rax
    97d8:	48 c1 e8 2f          	shr    $0x2f,%rax
    97dc:	49 31 c6             	xor    %rax,%r14
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:416
    a = ShiftMix(a * k1) * k1;
    97df:	4d 0f af f5          	imul   %r13,%r14
/home/austen/programming/dm-afs/src/lib/city.c:417
    c = b * k1 + HashLen0to16(s, len);
    97e3:	4d 0f af ec          	imul   %r12,%r13
    97e7:	e8 34 e3 ff ff       	callq  7b20 <HashLen0to16>
/home/austen/programming/dm-afs/src/lib/city.c:418
    d = ShiftMix(a + (len >= 8 ? Fetch64(s) : c));
    97ec:	48 83 7d 90 07       	cmpq   $0x7,-0x70(%rbp)
/home/austen/programming/dm-afs/src/lib/city.c:417
    c = b * k1 + HashLen0to16(s, len);
    97f1:	4d 8d 7c 05 00       	lea    0x0(%r13,%rax,1),%r15
/home/austen/programming/dm-afs/src/lib/city.c:418
    d = ShiftMix(a + (len >= 8 ? Fetch64(s) : c));
    97f6:	4c 89 f8             	mov    %r15,%rax
    97f9:	76 08                	jbe    9803 <CityHash128WithSeed+0x633>
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    97fb:	48 89 df             	mov    %rbx,%rdi
    97fe:	e8 6d e2 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityMurmur():
/home/austen/programming/dm-afs/src/lib/city.c:418
    d = ShiftMix(a + (len >= 8 ? Fetch64(s) : c));
    9803:	4c 01 f0             	add    %r14,%rax
ShiftMix():
/home/austen/programming/dm-afs/src/lib/city.c:253
  return val ^ (val >> 47);
    9806:	49 89 c5             	mov    %rax,%r13
    9809:	49 c1 ed 2f          	shr    $0x2f,%r13
    980d:	49 31 c5             	xor    %rax,%r13
    9810:	4c 89 6d d0          	mov    %r13,-0x30(%rbp)
    9814:	e9 08 ff ff ff       	jmpq   9721 <CityHash128WithSeed+0x551>
CityHash128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:253
    9819:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000009820 <CityHash128>:
CityHash128():
/home/austen/programming/dm-afs/src/lib/city.c:508
uint128 CityHash128(const uint8_t *s, size_t len) {
    9820:	e8 00 00 00 00       	callq  9825 <CityHash128+0x5>
			9821: R_X86_64_PC32	__fentry__-0x4
    9825:	55                   	push   %rbp
    9826:	48 89 e5             	mov    %rsp,%rbp
    9829:	41 55                	push   %r13
    982b:	41 54                	push   %r12
    982d:	53                   	push   %rbx
    982e:	48 89 fb             	mov    %rdi,%rbx
    9831:	49 89 f4             	mov    %rsi,%r12
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    9834:	e8 37 e2 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128():
/home/austen/programming/dm-afs/src/lib/city.c:509
  uint128 output1 = {Fetch64(s), Fetch64(s+8) + k0};
    9839:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
Fetch64():
/home/austen/programming/dm-afs/src/lib/city.c:97
  return uint64_t_in_expected_order(UNALIGNED_LOAD64(p));
    983d:	49 89 c5             	mov    %rax,%r13
    9840:	e8 2b e2 ff ff       	callq  7a70 <UNALIGNED_LOAD64>
CityHash128():
/home/austen/programming/dm-afs/src/lib/city.c:509
  uint128 output1 = {Fetch64(s), Fetch64(s+8) + k0};
    9845:	48 ba 27 31 cb 97 5c 	movabs $0xc3a5c85c97cb3127,%rdx
    984c:	c8 a5 c3 
/home/austen/programming/dm-afs/src/lib/city.c:512
      CityHash128WithSeed(s + 16, len - 16, output1) : CityHash128WithSeed(s, len, output2);
    984f:	49 83 fc 0f          	cmp    $0xf,%r12
/home/austen/programming/dm-afs/src/lib/city.c:509
  uint128 output1 = {Fetch64(s), Fetch64(s+8) + k0};
    9853:	48 8d 0c 10          	lea    (%rax,%rdx,1),%rcx
/home/austen/programming/dm-afs/src/lib/city.c:512
      CityHash128WithSeed(s + 16, len - 16, output1) : CityHash128WithSeed(s, len, output2);
    9857:	77 1c                	ja     9875 <CityHash128+0x55>
/home/austen/programming/dm-afs/src/lib/city.c:512 (discriminator 2)
    9859:	4c 89 e6             	mov    %r12,%rsi
    985c:	48 89 df             	mov    %rbx,%rdi
    985f:	48 b9 73 f2 98 be 6f 	movabs $0xb492b66fbe98f273,%rcx
    9866:	b6 92 b4 
    9869:	e8 00 00 00 00       	callq  986e <CityHash128+0x4e>
			986a: R_X86_64_PC32	CityHash128WithSeed-0x4
/home/austen/programming/dm-afs/src/lib/city.c:513 (discriminator 2)
}
    986e:	5b                   	pop    %rbx
    986f:	41 5c                	pop    %r12
    9871:	41 5d                	pop    %r13
    9873:	5d                   	pop    %rbp
    9874:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/city.c:512 (discriminator 1)
      CityHash128WithSeed(s + 16, len - 16, output1) : CityHash128WithSeed(s, len, output2);
    9875:	49 8d 74 24 f0       	lea    -0x10(%r12),%rsi
    987a:	48 8d 7b 10          	lea    0x10(%rbx),%rdi
    987e:	4c 89 ea             	mov    %r13,%rdx
    9881:	e8 00 00 00 00       	callq  9886 <CityHash128+0x66>
			9882: R_X86_64_PC32	CityHash128WithSeed-0x4
/home/austen/programming/dm-afs/src/lib/city.c:513 (discriminator 1)
}
    9886:	5b                   	pop    %rbx
    9887:	41 5c                	pop    %r12
    9889:	41 5d                	pop    %r13
    988b:	5d                   	pop    %rbp
    988c:	c3                   	retq   
    988d:	0f 1f 00             	nopl   (%rax)

0000000000009890 <CityHashCrc256>:
CityHashCrc256():
/home/austen/programming/dm-afs/src/lib/city.c:620

void CityHashCrc256(const uint8_t *s, size_t len, uint64_t *result) {
    9890:	e8 00 00 00 00       	callq  9895 <CityHashCrc256+0x5>
			9891: R_X86_64_PC32	__fentry__-0x4
    9895:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/lib/city.c:621
  if (LIKELY(len >= 240)) {
    9896:	48 81 fe ef 00 00 00 	cmp    $0xef,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:620
void CityHashCrc256(const uint8_t *s, size_t len, uint64_t *result) {
    989d:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/lib/city.c:621
  if (LIKELY(len >= 240)) {
    98a0:	77 07                	ja     98a9 <CityHashCrc256+0x19>
/home/austen/programming/dm-afs/src/lib/city.c:624
    CityHashCrc256Long(s, len, 0, result);
  } else {
    CityHashCrc256Short(s, len, result);
    98a2:	e8 09 ee ff ff       	callq  86b0 <CityHashCrc256Short>
/home/austen/programming/dm-afs/src/lib/city.c:626
  }
}
    98a7:	5d                   	pop    %rbp
    98a8:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/city.c:622
    CityHashCrc256Long(s, len, 0, result);
    98a9:	48 89 d1             	mov    %rdx,%rcx
    98ac:	31 d2                	xor    %edx,%edx
    98ae:	e8 ad e3 ff ff       	callq  7c60 <CityHashCrc256Long>
/home/austen/programming/dm-afs/src/lib/city.c:626
}
    98b3:	5d                   	pop    %rbp
    98b4:	c3                   	retq   
    98b5:	90                   	nop
    98b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    98bd:	00 00 00 

00000000000098c0 <CityHashCrc128WithSeed>:
CityHashCrc128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:628

uint128 CityHashCrc128WithSeed(const uint8_t *s, size_t len, uint128 seed) {
    98c0:	e8 00 00 00 00       	callq  98c5 <CityHashCrc128WithSeed+0x5>
			98c1: R_X86_64_PC32	__fentry__-0x4
    98c5:	55                   	push   %rbp
    98c6:	48 89 e5             	mov    %rsp,%rbp
    98c9:	53                   	push   %rbx
    98ca:	48 89 d3             	mov    %rdx,%rbx
    98cd:	48 83 ec 48          	sub    $0x48,%rsp
    98d1:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    98d8:	00 00 
    98da:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    98de:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/city.c:629
  if (len <= 900) {
    98e0:	48 81 fe 84 03 00 00 	cmp    $0x384,%rsi
    98e7:	0f 86 a8 00 00 00    	jbe    9995 <CityHashCrc128WithSeed+0xd5>
/home/austen/programming/dm-afs/src/lib/city.c:635
    return CityHash128WithSeed(s, len, seed);
  } else {
    uint64_t result[4];
    uint128 crc128;
    uint64_t u, v;
    CityHashCrc256(s, len, result);
    98ed:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
    98f1:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    98f5:	e8 00 00 00 00       	callq  98fa <CityHashCrc128WithSeed+0x3a>
			98f6: R_X86_64_PC32	CityHashCrc256-0x4
/home/austen/programming/dm-afs/src/lib/city.c:637
    u = Uint128High64(seed) + result[0];
    v = Uint128Low64(seed) + result[1];
    98fa:	48 03 5d c8          	add    -0x38(%rbp),%rbx
/home/austen/programming/dm-afs/src/lib/city.c:638
    crc128.first = HashLen16(u, v + result[2]);
    98fe:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9902:	48 ba 69 2d 38 eb 08 	movabs $0x9ddfea08eb382d69,%rdx
    9909:	ea df 9d 
CityHashCrc128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:636
    u = Uint128High64(seed) + result[0];
    990c:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    9910:	48 03 4d c0          	add    -0x40(%rbp),%rcx
/home/austen/programming/dm-afs/src/lib/city.c:638
    crc128.first = HashLen16(u, v + result[2]);
    9914:	48 01 de             	add    %rbx,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:637
    v = Uint128Low64(seed) + result[1];
    9917:	48 89 df             	mov    %rbx,%rdi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    991a:	49 89 f0             	mov    %rsi,%r8
Rotate():
/home/austen/programming/dm-afs/src/lib/city.c:249
  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
    991d:	48 c1 c7 20          	rol    $0x20,%rdi
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9921:	49 31 c8             	xor    %rcx,%r8
    9924:	4c 0f af c2          	imul   %rdx,%r8
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9928:	4c 89 c0             	mov    %r8,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    992b:	4c 31 c6             	xor    %r8,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    992e:	48 c1 e8 2f          	shr    $0x2f,%rax
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9932:	48 31 f0             	xor    %rsi,%rax
    9935:	48 0f af c2          	imul   %rdx,%rax
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9939:	48 89 c6             	mov    %rax,%rsi
    993c:	48 c1 ee 2f          	shr    $0x2f,%rsi
    9940:	48 31 f0             	xor    %rsi,%rax
CityHashCrc128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:639
    crc128.second = HashLen16(Rotate(v, 32), u * k0 + result[3]);
    9943:	48 be 27 31 cb 97 5c 	movabs $0xc3a5c85c97cb3127,%rsi
    994a:	c8 a5 c3 
    994d:	48 0f af ce          	imul   %rsi,%rcx
    9951:	48 03 4d d8          	add    -0x28(%rbp),%rcx
/home/austen/programming/dm-afs/src/lib/city.c:640
    return crc128;
    9955:	48 0f af c2          	imul   %rdx,%rax
Hash128to64():
/home/austen/programming/dm-afs/src/lib/city.c:88
  a = (Uint128Low64(x) ^ Uint128High64(x)) * kMul;
    9959:	48 31 cf             	xor    %rcx,%rdi
    995c:	48 0f af fa          	imul   %rdx,%rdi
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9960:	48 89 fe             	mov    %rdi,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    9963:	48 31 f9             	xor    %rdi,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:89
  a ^= (a >> 47);
    9966:	48 c1 ee 2f          	shr    $0x2f,%rsi
/home/austen/programming/dm-afs/src/lib/city.c:90
  b = (Uint128High64(x) ^ a) * kMul;
    996a:	48 31 f1             	xor    %rsi,%rcx
    996d:	48 0f af ca          	imul   %rdx,%rcx
/home/austen/programming/dm-afs/src/lib/city.c:91
  b ^= (b >> 47);
    9971:	48 89 ce             	mov    %rcx,%rsi
    9974:	48 c1 ee 2f          	shr    $0x2f,%rsi
    9978:	48 31 f1             	xor    %rsi,%rcx
CityHashCrc128WithSeed():
/home/austen/programming/dm-afs/src/lib/city.c:640
    return crc128;
    997b:	48 0f af d1          	imul   %rcx,%rdx
/home/austen/programming/dm-afs/src/lib/city.c:642 (discriminator 1)
  }
}
    997f:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
    9983:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
    998a:	00 00 
    998c:	75 0e                	jne    999c <CityHashCrc128WithSeed+0xdc>
/home/austen/programming/dm-afs/src/lib/city.c:642
    998e:	48 83 c4 48          	add    $0x48,%rsp
    9992:	5b                   	pop    %rbx
    9993:	5d                   	pop    %rbp
    9994:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/city.c:630
    return CityHash128WithSeed(s, len, seed);
    9995:	e8 00 00 00 00       	callq  999a <CityHashCrc128WithSeed+0xda>
			9996: R_X86_64_PC32	CityHash128WithSeed-0x4
    999a:	eb e3                	jmp    997f <CityHashCrc128WithSeed+0xbf>
/home/austen/programming/dm-afs/src/lib/city.c:642
}
    999c:	e8 00 00 00 00       	callq  99a1 <CityHashCrc128WithSeed+0xe1>
			999d: R_X86_64_PC32	__stack_chk_fail-0x4
    99a1:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    99a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    99ad:	00 00 00 

00000000000099b0 <CityHashCrc128>:
CityHashCrc128():
/home/austen/programming/dm-afs/src/lib/city.c:644

uint128 CityHashCrc128(const uint8_t *s, size_t len) {
    99b0:	e8 00 00 00 00       	callq  99b5 <CityHashCrc128+0x5>
			99b1: R_X86_64_PC32	__fentry__-0x4
    99b5:	55                   	push   %rbp
    99b6:	48 89 e5             	mov    %rsp,%rbp
    99b9:	48 83 ec 30          	sub    $0x30,%rsp
    99bd:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    99c4:	00 00 
    99c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    99ca:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/lib/city.c:645
  if (len <= 900) {
    99cc:	48 81 fe 84 03 00 00 	cmp    $0x384,%rsi
    99d3:	76 22                	jbe    99f7 <CityHashCrc128+0x47>
/home/austen/programming/dm-afs/src/lib/city.c:650
    return CityHash128(s, len);
  } else {
    uint128 crc128;
    uint64_t result[4];
    CityHashCrc256(s, len, result);
    99d5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
    99d9:	e8 00 00 00 00       	callq  99de <CityHashCrc128+0x2e>
			99da: R_X86_64_PC32	CityHashCrc256-0x4
/home/austen/programming/dm-afs/src/lib/city.c:653
    crc128.first = result[2];
    crc128.second = result[3];
    return crc128;
    99de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    99e2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
/home/austen/programming/dm-afs/src/lib/city.c:655 (discriminator 1)
  }
}
    99e6:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    99ea:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    99f1:	00 00 
    99f3:	75 09                	jne    99fe <CityHashCrc128+0x4e>
/home/austen/programming/dm-afs/src/lib/city.c:655
    99f5:	c9                   	leaveq 
    99f6:	c3                   	retq   
/home/austen/programming/dm-afs/src/lib/city.c:646
    return CityHash128(s, len);
    99f7:	e8 00 00 00 00       	callq  99fc <CityHashCrc128+0x4c>
			99f8: R_X86_64_PC32	CityHash128-0x4
    99fc:	eb e8                	jmp    99e6 <CityHashCrc128+0x36>
/home/austen/programming/dm-afs/src/lib/city.c:655
}
    99fe:	e8 00 00 00 00       	callq  9a03 <CityHashCrc128+0x53>
			99ff: R_X86_64_PC32	__stack_chk_fail-0x4
    9a03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    9a0a:	00 00 00 
    9a0d:	0f 1f 00             	nopl   (%rax)

0000000000009a10 <afs_fat32_detect>:
afs_fat32_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:373
 * @fs      The file system information to be filled in.
 * @return  boolean.
 */
bool
afs_fat32_detect(const void *data, struct block_device *device, struct afs_passive_fs *fs)
{
    9a10:	e8 00 00 00 00       	callq  9a15 <afs_fat32_detect+0x5>
			9a11: R_X86_64_PC32	__fentry__-0x4
    9a15:	55                   	push   %rbp
    9a16:	48 89 e5             	mov    %rsp,%rbp
    9a19:	41 57                	push   %r15
    9a1b:	41 56                	push   %r14
    9a1d:	41 55                	push   %r13
    9a1f:	41 54                	push   %r12
    9a21:	49 89 fd             	mov    %rdi,%r13
    9a24:	53                   	push   %rbx
    9a25:	48 83 ec 38          	sub    $0x38,%rsp
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    9a29:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 9a30 <afs_fat32_detect+0x20>
			9a2c: R_X86_64_PC32	kmalloc_caches+0xc
afs_fat32_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:373
    9a30:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    9a34:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    9a38:	be c0 00 40 01       	mov    $0x14000c0,%esi
    9a3d:	ba 90 00 00 00       	mov    $0x90,%edx
    9a42:	e8 00 00 00 00       	callq  9a47 <afs_fat32_detect+0x37>
			9a43: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
afs_fat32_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:379
    struct fat_volume *vol = NULL;
    int ret;

    // Allocate memory for volume.
    vol = kmalloc(sizeof(*vol), GFP_KERNEL);
    afs_action(!IS_ERR(vol), ret = PTR_ERR(vol), vol_err, "could not allocate vol [%d]", ret);
    9a47:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    9a4d:	48 89 c3             	mov    %rax,%rbx
afs_fat32_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:379
    9a50:	0f 87 96 05 00 00    	ja     9fec <afs_fat32_detect+0x5dc>
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    9a56:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 9a5d <afs_fat32_detect+0x4d>
			9a59: R_X86_64_PC32	kmalloc_caches+0x44
    9a5d:	ba 00 02 00 00       	mov    $0x200,%edx
    9a62:	be c0 00 40 01       	mov    $0x14000c0,%esi
    9a67:	e8 00 00 00 00       	callq  9a6c <afs_fat32_detect+0x5c>
			9a68: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:242
    afs_action(!IS_ERR(boot_sec), ret = PTR_ERR(boot_sec), out_invalid, "could not allocate boot_sec [%d]", ret);
    9a6c:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    9a72:	49 89 c4             	mov    %rax,%r12
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:242
    9a75:	0f 87 92 05 00 00    	ja     a00d <afs_fat32_detect+0x5fd>
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    9a7b:	48 89 c7             	mov    %rax,%rdi
    9a7e:	b9 40 00 00 00       	mov    $0x40,%ecx
    9a83:	4c 89 ee             	mov    %r13,%rsi
    9a86:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:116
    vol->bytes_sector = le16_to_cpu(boot_sec->bytes_sec);
    9a89:	41 0f b7 54 24 0b    	movzwl 0xb(%r12),%edx
    9a8f:	48 8b 40 03          	mov    0x3(%rax),%rax
bsr():
/home/austen/programming/dm-afs/include/dm_afs.h:131
 * Primarily used to verify data sizes for file system processing
 */
static inline uint64_t
bsr(uint64_t n)
{
    __asm__("bsr %1,%0"
    9a93:	48 0f bd ca          	bsr    %rdx,%rcx
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:117
    vol->sector_order = bsr(vol->bytes_sector);
    9a97:	66 89 4b 42          	mov    %cx,0x42(%rbx)
    9a9b:	48 89 43 30          	mov    %rax,0x30(%rbx)
is_power_of_2():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/log2.h:51
    9a9f:	48 85 d2             	test   %rdx,%rdx
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:116
    vol->bytes_sector = le16_to_cpu(boot_sec->bytes_sec);
    9aa2:	66 89 53 40          	mov    %dx,0x40(%rbx)
is_power_of_2():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/log2.h:51
    9aa6:	0f 84 a9 05 00 00    	je     a055 <afs_fat32_detect+0x645>
    9aac:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:118
    afs_assert(is_power_of_2(vol->bytes_sector) && vol->sector_order >= 5 && vol->sector_order <= 12,
    9ab0:	48 85 d0             	test   %rdx,%rax
    9ab3:	0f 85 9c 05 00 00    	jne    a055 <afs_fat32_detect+0x645>
    9ab9:	8d 41 fb             	lea    -0x5(%rcx),%eax
    9abc:	66 83 f8 07          	cmp    $0x7,%ax
    9ac0:	0f 87 8f 05 00 00    	ja     a055 <afs_fat32_detect+0x645>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:121
    vol->sec_cluster = boot_sec->sec_cluster;
    9ac6:	41 0f b6 54 24 0d    	movzbl 0xd(%r12),%edx
bsr():
/home/austen/programming/dm-afs/include/dm_afs.h:131
    9acc:	48 0f bd c2          	bsr    %rdx,%rax
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:122
    vol->sec_cluster_order = bsr(vol->sec_cluster);
    9ad0:	88 43 45             	mov    %al,0x45(%rbx)
is_power_of_2():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/log2.h:51
    9ad3:	48 85 d2             	test   %rdx,%rdx
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:121
    vol->sec_cluster = boot_sec->sec_cluster;
    9ad6:	88 53 44             	mov    %dl,0x44(%rbx)
is_power_of_2():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/log2.h:51
    9ad9:	75 46                	jne    9b21 <afs_fat32_detect+0x111>
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:123
    afs_assert(is_power_of_2(vol->sec_cluster) && vol->sec_cluster_order <= 7, out_invalid,
    9adb:	0f b6 c8             	movzbl %al,%ecx
    9ade:	ba 7c 00 00 00       	mov    $0x7c,%edx
    9ae3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9ae6: R_X86_64_32S	.rodata+0x2600
    9aea:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9aed: R_X86_64_32S	.rodata.str1.8+0x19f8
    9af1:	31 c0                	xor    %eax,%eax
    9af3:	e8 00 00 00 00       	callq  9af8 <afs_fat32_detect+0xe8>
			9af4: R_X86_64_PC32	printk-0x4
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:253
        afs_debug("failed to read dos 2.0 bpb");
    9af8:	44 8b 0d 00 00 00 00 	mov    0x0(%rip),%r9d        # 9aff <afs_fat32_detect+0xef>
			9afb: R_X86_64_PC32	afs_debug_mode-0x4
    9aff:	45 85 c9             	test   %r9d,%r9d
    9b02:	0f 85 b1 05 00 00    	jne    a0b9 <afs_fat32_detect+0x6a9>
afs_fat32_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:410
	kfree(vol);
        return true;
    }

vol_err:
    kfree(vol);
    9b08:	48 89 df             	mov    %rbx,%rdi
    9b0b:	e8 00 00 00 00       	callq  9b10 <afs_fat32_detect+0x100>
			9b0c: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:411
    return false;
    9b10:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:412
}
    9b12:	48 83 c4 38          	add    $0x38,%rsp
    9b16:	5b                   	pop    %rbx
    9b17:	41 5c                	pop    %r12
    9b19:	41 5d                	pop    %r13
    9b1b:	41 5e                	pop    %r14
    9b1d:	41 5f                	pop    %r15
    9b1f:	5d                   	pop    %rbp
    9b20:	c3                   	retq   
is_power_of_2():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/log2.h:51
    9b21:	48 8d 72 ff          	lea    -0x1(%rdx),%rsi
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:123
    afs_assert(is_power_of_2(vol->sec_cluster) && vol->sec_cluster_order <= 7, out_invalid,
    9b25:	48 85 d6             	test   %rdx,%rsi
    9b28:	75 b1                	jne    9adb <afs_fat32_detect+0xcb>
    9b2a:	3c 07                	cmp    $0x7,%al
    9b2c:	77 ad                	ja     9adb <afs_fat32_detect+0xcb>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:126
    vol->cluster_order = vol->sector_order + vol->sec_cluster_order;
    9b2e:	0f b6 c0             	movzbl %al,%eax
    9b31:	01 c8                	add    %ecx,%eax
    9b33:	66 89 43 46          	mov    %ax,0x46(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:127
    vol->reserved = le16_to_cpu(boot_sec->res_sec);
    9b37:	41 0f b7 44 24 0e    	movzwl 0xe(%r12),%eax
    9b3d:	66 89 43 48          	mov    %ax,0x48(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:129
    vol->tables = boot_sec->num_tables;
    9b41:	41 0f b6 44 24 10    	movzbl 0x10(%r12),%eax
    9b47:	88 43 4a             	mov    %al,0x4a(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:130
    afs_assert(vol->tables == 1 || vol->tables == 2, out_invalid, "incorrect number of tables");
    9b4a:	83 e8 01             	sub    $0x1,%eax
    9b4d:	3c 01                	cmp    $0x1,%al
    9b4f:	0f 87 22 05 00 00    	ja     a077 <afs_fat32_detect+0x667>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:132
    vol->root_entries = le16_to_cpu(boot_sec->max_root_ent);
    9b55:	41 0f b7 44 24 11    	movzwl 0x11(%r12),%eax
    9b5b:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 9b61 <afs_fat32_detect+0x151>
			9b5d: R_X86_64_PC32	afs_debug_mode-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:133
    if (vol->root_entries == 0) {
    9b61:	66 85 c0             	test   %ax,%ax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:132
    vol->root_entries = le16_to_cpu(boot_sec->max_root_ent);
    9b64:	66 89 43 4c          	mov    %ax,0x4c(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:133
    if (vol->root_entries == 0) {
    9b68:	75 08                	jne    9b72 <afs_fat32_detect+0x162>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:135
        afs_debug("FS is Fat32, not Fat16 or 12");
    9b6a:	85 d2                	test   %edx,%edx
    9b6c:	0f 85 24 05 00 00    	jne    a096 <afs_fat32_detect+0x686>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:140
    vol->media_desc = boot_sec->media_desc;
    9b72:	41 0f b6 4c 24 15    	movzbl 0x15(%r12),%ecx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:139
    vol->total_sec = le16_to_cpu(boot_sec->total_sectors);
    9b78:	41 0f b7 44 24 13    	movzwl 0x13(%r12),%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:140
    vol->media_desc = boot_sec->media_desc;
    9b7e:	88 4b 4e             	mov    %cl,0x4e(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:141
    vol->sec_fat = le16_to_cpu(boot_sec->sec_fat);
    9b81:	41 0f b7 4c 24 16    	movzwl 0x16(%r12),%ecx
fat_read_dos_3_31_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:161
    if (vol->total_sec == 0) {
    9b87:	85 c0                	test   %eax,%eax
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:139
    vol->total_sec = le16_to_cpu(boot_sec->total_sectors);
    9b89:	89 43 50             	mov    %eax,0x50(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:141
    vol->sec_fat = le16_to_cpu(boot_sec->sec_fat);
    9b8c:	89 4b 54             	mov    %ecx,0x54(%rbx)
fat_read_dos_3_31_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:158
    vol->sec_track = le16_to_cpu(boot_sec->sec_track);
    9b8f:	41 0f b7 4c 24 18    	movzwl 0x18(%r12),%ecx
    9b95:	66 89 4b 58          	mov    %cx,0x58(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:159
    vol->num_heads = le16_to_cpu(boot_sec->num_heads);
    9b99:	41 0f b7 4c 24 1a    	movzwl 0x1a(%r12),%ecx
    9b9f:	66 89 4b 5a          	mov    %cx,0x5a(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:160
    vol->hidden_sec = le32_to_cpu(boot_sec->hidden_sec);
    9ba3:	41 8b 4c 24 1c       	mov    0x1c(%r12),%ecx
    9ba8:	89 4b 5c             	mov    %ecx,0x5c(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:161
    if (vol->total_sec == 0) {
    9bab:	75 08                	jne    9bb5 <afs_fat32_detect+0x1a5>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:162
        vol->total_sec = le32_to_cpu(boot_sec->total_sec_32);
    9bad:	41 8b 44 24 20       	mov    0x20(%r12),%eax
    9bb2:	89 43 50             	mov    %eax,0x50(%rbx)
fat_read_fat32_ebpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:192
    if (le32_to_cpu(ebpb->sec_fat) != 0) {
    9bb5:	41 8b 44 24 24       	mov    0x24(%r12),%eax
    9bba:	85 c0                	test   %eax,%eax
    9bbc:	74 19                	je     9bd7 <afs_fat32_detect+0x1c7>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:194
        if ((((size_t)vol->sec_fat << vol->sector_order) >> vol->sector_order) != (size_t)vol->sec_fat) {
    9bbe:	0f b7 4b 42          	movzwl 0x42(%rbx),%ecx
    9bc2:	48 89 c6             	mov    %rax,%rsi
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:193
        vol->sec_fat = le32_to_cpu(ebpb->sec_fat);
    9bc5:	89 43 54             	mov    %eax,0x54(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:194
        if ((((size_t)vol->sec_fat << vol->sector_order) >> vol->sector_order) != (size_t)vol->sec_fat) {
    9bc8:	48 d3 e6             	shl    %cl,%rsi
    9bcb:	48 d3 ee             	shr    %cl,%rsi
    9bce:	48 39 f0             	cmp    %rsi,%rax
    9bd1:	0f 85 12 02 00 00    	jne    9de9 <afs_fat32_detect+0x3d9>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:199
    vol->driv_desc = le16_to_cpu(ebpb->drive_desc);
    9bd7:	41 0f b7 44 24 28    	movzwl 0x28(%r12),%eax
    9bdd:	66 89 43 60          	mov    %ax,0x60(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:200
    vol->version = le16_to_cpu(ebpb->version);
    9be1:	41 0f b7 44 24 2a    	movzwl 0x2a(%r12),%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:201
    if (vol->version != 0) {
    9be7:	66 85 c0             	test   %ax,%ax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:200
    vol->version = le16_to_cpu(ebpb->version);
    9bea:	66 89 43 62          	mov    %ax,0x62(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:201
    if (vol->version != 0) {
    9bee:	0f 85 f5 01 00 00    	jne    9de9 <afs_fat32_detect+0x3d9>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:205
    vol->root_dir_start = le32_to_cpu(ebpb->root_start_clust);
    9bf4:	41 8b 44 24 2c       	mov    0x2c(%r12),%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:206
    if (vol->root_dir_start == 0) {
    9bf9:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:205
    vol->root_dir_start = le32_to_cpu(ebpb->root_start_clust);
    9bfb:	89 43 64             	mov    %eax,0x64(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:206
    if (vol->root_dir_start == 0) {
    9bfe:	0f 84 e5 01 00 00    	je     9de9 <afs_fat32_detect+0x3d9>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:210
    vol->fs_info_sec = le16_to_cpu(ebpb->fs_info_sec);
    9c04:	41 0f b7 44 24 30    	movzwl 0x30(%r12),%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:211
    vol->alt_boot_sec = le16_to_cpu(ebpb->alt_boot_sec);
    9c0a:	41 0f b7 4c 24 32    	movzwl 0x32(%r12),%ecx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:212
    if (vol->fs_info_sec == 0xffff) {
    9c10:	66 83 f8 ff          	cmp    $0xffff,%ax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:211
    vol->alt_boot_sec = le16_to_cpu(ebpb->alt_boot_sec);
    9c14:	66 89 4b 6a          	mov    %cx,0x6a(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:210
    vol->fs_info_sec = le16_to_cpu(ebpb->fs_info_sec);
    9c18:	66 89 43 68          	mov    %ax,0x68(%rbx)
    9c1c:	0f b7 4b 42          	movzwl 0x42(%rbx),%ecx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:212
    if (vol->fs_info_sec == 0xffff) {
    9c20:	0f 84 b9 03 00 00    	je     9fdf <afs_fat32_detect+0x5cf>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:216
    if (vol->fs_info_sec != 0 && vol->sector_order < 9) {
    9c26:	66 85 c0             	test   %ax,%ax
    9c29:	74 0a                	je     9c35 <afs_fat32_detect+0x225>
    9c2b:	66 83 f9 08          	cmp    $0x8,%cx
    9c2f:	0f 86 b4 01 00 00    	jbe    9de9 <afs_fat32_detect+0x3d9>
fat_read_nonfat32_ebpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:176
    vol->phys_driv_num = ebpb->physical_drive_num;
    9c35:	41 0f b6 44 24 24    	movzbl 0x24(%r12),%eax
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:269
    num_data_sectors = vol->total_sec - vol->reserved - (vol->sec_fat * vol->tables) - ((vol->root_entries << 5) >> vol->sector_order);
    9c3b:	44 8b 6b 50          	mov    0x50(%rbx),%r13d
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    9c3f:	49 8b 7c 24 2b       	mov    0x2b(%r12),%rdi
    9c44:	41 0f b6 74 24 35    	movzbl 0x35(%r12),%esi
fat_read_nonfat32_ebpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:176
    vol->phys_driv_num = ebpb->physical_drive_num;
    9c4a:	88 43 6c             	mov    %al,0x6c(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:177
    vol->ext_boot_sig = ebpb->extended_boot_sig;
    9c4d:	41 0f b6 44 24 26    	movzbl 0x26(%r12),%eax
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    9c53:	48 89 7b 74          	mov    %rdi,0x74(%rbx)
    9c57:	41 0f b7 7c 24 33    	movzwl 0x33(%r12),%edi
    9c5d:	40 88 73 7e          	mov    %sil,0x7e(%rbx)
fat_read_nonfat32_ebpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:177
    9c61:	88 43 6d             	mov    %al,0x6d(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:178
    vol->vol_id = le32_to_cpu(ebpb->volume_id);
    9c64:	41 8b 44 24 27       	mov    0x27(%r12),%eax
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    9c69:	66 89 7b 7c          	mov    %di,0x7c(%rbx)
fat_read_nonfat32_ebpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:178
    9c6d:	89 43 70             	mov    %eax,0x70(%rbx)
    9c70:	49 8b 44 24 36       	mov    0x36(%r12),%rax
    9c75:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:269
    num_data_sectors = vol->total_sec - vol->reserved - (vol->sec_fat * vol->tables) - ((vol->root_entries << 5) >> vol->sector_order);
    9c7c:	0f b7 43 48          	movzwl 0x48(%rbx),%eax
    9c80:	41 29 c5             	sub    %eax,%r13d
    9c83:	0f b6 43 4a          	movzbl 0x4a(%rbx),%eax
    9c87:	0f af 43 54          	imul   0x54(%rbx),%eax
    9c8b:	41 29 c5             	sub    %eax,%r13d
    9c8e:	0f b7 43 4c          	movzwl 0x4c(%rbx),%eax
    9c92:	c1 e0 05             	shl    $0x5,%eax
    9c95:	d3 f8                	sar    %cl,%eax
    9c97:	41 29 c5             	sub    %eax,%r13d
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:270
    afs_debug("Number of data sectors: %u", num_data_sectors);
    9c9a:	85 d2                	test   %edx,%edx
    9c9c:	0f 85 78 04 00 00    	jne    a11a <afs_fat32_detect+0x70a>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:273
    vol->num_data_clusters = num_data_sectors / vol->sec_cluster;
    9ca2:	0f b6 4b 44          	movzbl 0x44(%rbx),%ecx
    9ca6:	44 89 e8             	mov    %r13d,%eax
    9ca9:	31 d2                	xor    %edx,%edx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:274
    kfree(boot_sec);
    9cab:	4c 89 e7             	mov    %r12,%rdi
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:273
    vol->num_data_clusters = num_data_sectors / vol->sec_cluster;
    9cae:	f7 f1                	div    %ecx
    9cb0:	89 43 10             	mov    %eax,0x10(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:274
    kfree(boot_sec);
    9cb3:	e8 00 00 00 00       	callq  9cb8 <afs_fat32_detect+0x2a8>
			9cb4: R_X86_64_PC32	kfree-0x4
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    9cb8:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 9cbf <afs_fat32_detect+0x2af>
			9cbb: R_X86_64_PC32	kmalloc_caches+0x5c
    9cbf:	ba 00 10 00 00       	mov    $0x1000,%edx
    9cc4:	be c0 00 40 01       	mov    $0x14000c0,%esi
    9cc9:	e8 00 00 00 00       	callq  9cce <afs_fat32_detect+0x2be>
			9cca: R_X86_64_PC32	kmem_cache_alloc_trace-0x4
fat_map():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:308
    fat_offset = (off_t)vol->reserved << vol->sector_order;
    9cce:	44 0f b7 63 48       	movzwl 0x48(%rbx),%r12d
    9cd3:	0f b7 4b 42          	movzwl 0x42(%rbx),%ecx
kmalloc():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/slab.h:499
    9cd7:	49 89 c6             	mov    %rax,%r14
fat_map():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:310
    fat_size_bytes = (size_t)(vol->sec_fat * vol->bytes_sector);
    9cda:	0f b7 53 40          	movzwl 0x40(%rbx),%edx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:308
    fat_offset = (off_t)vol->reserved << vol->sector_order;
    9cde:	4c 89 e0             	mov    %r12,%rax
    9ce1:	49 d3 e4             	shl    %cl,%r12
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:310
    fat_size_bytes = (size_t)(vol->sec_fat * vol->bytes_sector);
    9ce4:	8b 4b 54             	mov    0x54(%rbx),%ecx
    9ce7:	89 d7                	mov    %edx,%edi
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:309
    fat_aligned_offset = fat_offset & ~(page_size - 1);
    9ce9:	4d 89 e5             	mov    %r12,%r13
    9cec:	41 81 e5 00 f0 ff ff 	and    $0xfffff000,%r13d
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:310
    fat_size_bytes = (size_t)(vol->sec_fat * vol->bytes_sector);
    9cf3:	0f af f9             	imul   %ecx,%edi
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:311
    fat_aligned_size_bytes = fat_size_bytes + (fat_offset - fat_aligned_offset);
    9cf6:	4d 29 ec             	sub    %r13,%r12
    9cf9:	49 01 fc             	add    %rdi,%r12
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:310
    fat_size_bytes = (size_t)(vol->sec_fat * vol->bytes_sector);
    9cfc:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:312
    page_number = fat_aligned_size_bytes / 4096 + 1;
    9d00:	4c 89 e2             	mov    %r12,%rdx
    9d03:	48 c1 ea 0c          	shr    $0xc,%rdx
    9d07:	8d 7a 01             	lea    0x1(%rdx),%edi
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:313
    vol->data_start_off = (off_t)((vol->tables * vol->sec_fat) + vol->reserved);
    9d0a:	0f b6 53 4a          	movzbl 0x4a(%rbx),%edx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:312
    page_number = fat_aligned_size_bytes / 4096 + 1;
    9d0e:	89 7d c4             	mov    %edi,-0x3c(%rbp)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:315
    afs_debug("Data start offset: %zu ", vol->data_start_off);
    9d11:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 9d17 <afs_fat32_detect+0x307>
			9d13: R_X86_64_PC32	afs_debug_mode-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:313
    vol->data_start_off = (off_t)((vol->tables * vol->sec_fat) + vol->reserved);
    9d17:	0f af d1             	imul   %ecx,%edx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:315
    afs_debug("Data start offset: %zu ", vol->data_start_off);
    9d1a:	85 ff                	test   %edi,%edi
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:313
    vol->data_start_off = (off_t)((vol->tables * vol->sec_fat) + vol->reserved);
    9d1c:	8d 0c 02             	lea    (%rdx,%rax,1),%ecx
    9d1f:	48 89 4b 18          	mov    %rcx,0x18(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:315
    afs_debug("Data start offset: %zu ", vol->data_start_off);
    9d23:	0f 85 e7 00 00 00    	jne    9e10 <afs_fat32_detect+0x400>
    9d29:	4d 01 ec             	add    %r13,%r12
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:322
    if (fat_aligned_offset + fat_aligned_size_bytes > 4096) {
    9d2c:	49 81 fc 00 10 00 00 	cmp    $0x1000,%r12
    9d33:	0f 87 d7 01 00 00    	ja     9f10 <afs_fat32_detect+0x500>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:302
    uint8_t *fat_data = NULL;
    9d39:	45 31 e4             	xor    %r12d,%r12d
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:340
    vol->fat_map = fat_data;
    9d3c:	4c 89 23             	mov    %r12,(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:346
    empty_clusters = vmalloc(fat_size_bytes);
    9d3f:	4c 8b 7d b0          	mov    -0x50(%rbp),%r15
    9d43:	4c 89 ff             	mov    %r15,%rdi
    9d46:	e8 00 00 00 00       	callq  9d4b <afs_fat32_detect+0x33b>
			9d47: R_X86_64_PC32	vmalloc-0x4
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    9d4b:	4c 89 fa             	mov    %r15,%rdx
    9d4e:	31 f6                	xor    %esi,%esi
    9d50:	48 89 c7             	mov    %rax,%rdi
    9d53:	e8 00 00 00 00       	callq  9d58 <afs_fat32_detect+0x348>
			9d54: R_X86_64_PC32	memset-0x4
fat_map():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:349
    for (i = 0; i < vol->num_data_clusters; i++) {
    9d58:	8b 53 10             	mov    0x10(%rbx),%edx
memset():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:329
    9d5b:	49 89 c0             	mov    %rax,%r8
fat_map():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:349
    9d5e:	85 d2                	test   %edx,%edx
    9d60:	74 21                	je     9d83 <afs_fat32_detect+0x373>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:345
    cluster_number = 0;
    9d62:	31 d2                	xor    %edx,%edx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:349
    for (i = 0; i < vol->num_data_clusters; i++) {
    9d64:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:351
        if (p[i] == 0) {
    9d66:	48 63 c8             	movslq %eax,%rcx
    9d69:	41 8b 0c 8c          	mov    (%r12,%rcx,4),%ecx
    9d6d:	85 c9                	test   %ecx,%ecx
    9d6f:	75 0a                	jne    9d7b <afs_fat32_detect+0x36b>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:352
            empty_clusters[cluster_number] = i;
    9d71:	48 63 ca             	movslq %edx,%rcx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:353
            cluster_number++;
    9d74:	83 c2 01             	add    $0x1,%edx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:352
            empty_clusters[cluster_number] = i;
    9d77:	41 89 04 88          	mov    %eax,(%r8,%rcx,4)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:349
    for (i = 0; i < vol->num_data_clusters; i++) {
    9d7b:	83 c0 01             	add    $0x1,%eax
    9d7e:	3b 43 10             	cmp    0x10(%rbx),%eax
    9d81:	72 e3                	jb     9d66 <afs_fat32_detect+0x356>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:357
    vol->num_empty_clusters = cluster_number;
    9d83:	89 53 3c             	mov    %edx,0x3c(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:356
    vol->empty_clusters = empty_clusters;
    9d86:	4c 89 43 08          	mov    %r8,0x8(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:358
    kfree(reader);
    9d8a:	4c 89 f7             	mov    %r14,%rdi
    9d8d:	e8 00 00 00 00       	callq  9d92 <afs_fat32_detect+0x382>
			9d8e: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:359
    vfree(fat_data);
    9d92:	4c 89 e7             	mov    %r12,%rdi
    9d95:	e8 00 00 00 00       	callq  9d9a <afs_fat32_detect+0x38a>
			9d96: R_X86_64_PC32	vfree-0x4
afs_fat32_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:396
    vol->data_start_off = (off_t)((vol->tables * vol->sec_fat) + vol->reserved);
    9d9a:	0f b6 43 4a          	movzbl 0x4a(%rbx),%eax
    9d9e:	0f b7 53 48          	movzwl 0x48(%rbx),%edx
    9da2:	0f af 43 54          	imul   0x54(%rbx),%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:399
    if (fs) {
    9da6:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
    9daa:	48 85 f6             	test   %rsi,%rsi
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:396
    vol->data_start_off = (off_t)((vol->tables * vol->sec_fat) + vol->reserved);
    9dad:	8d 3c 10             	lea    (%rax,%rdx,1),%edi
    9db0:	48 89 7b 18          	mov    %rdi,0x18(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:399
    if (fs) {
    9db4:	0f 84 4e fd ff ff    	je     9b08 <afs_fat32_detect+0xf8>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:400
        fs->total_blocks = vol->num_data_clusters;
    9dba:	8b 53 10             	mov    0x10(%rbx),%edx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:404
        fs->data_start_off = vol->data_start_off; // Data start in sectors, blocks are relative to this.
    9dbd:	89 7e 14             	mov    %edi,0x14(%rsi)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:405
	kfree(vol);
    9dc0:	48 89 df             	mov    %rbx,%rdi
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:400
        fs->total_blocks = vol->num_data_clusters;
    9dc3:	89 56 10             	mov    %edx,0x10(%rsi)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:401
        fs->sectors_per_block = vol->sec_cluster;
    9dc6:	0f b6 53 44          	movzbl 0x44(%rbx),%edx
    9dca:	88 56 0c             	mov    %dl,0xc(%rsi)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:402
        fs->block_list = vol->empty_clusters;
    9dcd:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    9dd1:	48 89 16             	mov    %rdx,(%rsi)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:403
        fs->list_len = vol->num_empty_clusters;
    9dd4:	8b 53 3c             	mov    0x3c(%rbx),%edx
    9dd7:	89 56 08             	mov    %edx,0x8(%rsi)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:405
	kfree(vol);
    9dda:	e8 00 00 00 00       	callq  9ddf <afs_fat32_detect+0x3cf>
			9ddb: R_X86_64_PC32	kfree-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:406
        return true;
    9ddf:	b8 01 00 00 00       	mov    $0x1,%eax
    9de4:	e9 29 fd ff ff       	jmpq   9b12 <afs_fat32_detect+0x102>
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:264
        afs_debug("Failed to read fat32 ebpb");
    9de9:	85 d2                	test   %edx,%edx
    9deb:	0f 84 17 fd ff ff    	je     9b08 <afs_fat32_detect+0xf8>
    9df1:	ba 08 01 00 00       	mov    $0x108,%edx
    9df6:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9df9: R_X86_64_32S	.rodata+0x2620
    9dfd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9e00: R_X86_64_32S	.rodata.str1.8+0x1ae0
    9e04:	31 c0                	xor    %eax,%eax
    9e06:	e8 00 00 00 00       	callq  9e0b <afs_fat32_detect+0x3fb>
			9e07: R_X86_64_PC32	printk-0x4
    9e0b:	e9 19 02 00 00       	jmpq   a029 <afs_fat32_detect+0x619>
fat_map():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:315
    afs_debug("Data start offset: %zu ", vol->data_start_off);
    9e10:	31 c0                	xor    %eax,%eax
    9e12:	ba 3b 01 00 00       	mov    $0x13b,%edx
    9e17:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9e1a: R_X86_64_32S	.rodata+0x25f0
    9e1e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9e21: R_X86_64_32S	.rodata.str1.8+0x1bb8
    9e25:	4f 8d 7c 25 00       	lea    0x0(%r13,%r12,1),%r15
    9e2a:	e8 00 00 00 00       	callq  9e2f <afs_fat32_detect+0x41f>
			9e2b: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:316
    afs_debug("Root starting cluster: %u", vol->root_dir_start);
    9e2f:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 9e36 <afs_fat32_detect+0x426>
			9e31: R_X86_64_PC32	afs_debug_mode-0x5
    9e36:	0f 84 a3 00 00 00    	je     9edf <afs_fat32_detect+0x4cf>
    9e3c:	8b 4b 64             	mov    0x64(%rbx),%ecx
    9e3f:	31 c0                	xor    %eax,%eax
    9e41:	ba 3c 01 00 00       	mov    $0x13c,%edx
    9e46:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9e49: R_X86_64_32S	.rodata+0x25f0
    9e4d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9e50: R_X86_64_32S	.rodata.str1.8+0x1bf0
    9e54:	e8 00 00 00 00       	callq  9e59 <afs_fat32_detect+0x449>
			9e55: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:317
    afs_debug("FAT aligned size in bytes: %zu ", fat_aligned_size_bytes);
    9e59:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 9e60 <afs_fat32_detect+0x450>
			9e5b: R_X86_64_PC32	afs_debug_mode-0x5
    9e60:	0f 84 c3 fe ff ff    	je     9d29 <afs_fat32_detect+0x319>
    9e66:	31 c0                	xor    %eax,%eax
    9e68:	4c 89 e1             	mov    %r12,%rcx
    9e6b:	ba 3d 01 00 00       	mov    $0x13d,%edx
    9e70:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9e73: R_X86_64_32S	.rodata+0x25f0
    9e77:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9e7a: R_X86_64_32S	.rodata.str1.8+0x1c28
    9e7e:	e8 00 00 00 00       	callq  9e83 <afs_fat32_detect+0x473>
			9e7f: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:318
    afs_debug("FAT aligned offset: %d ", (int)fat_aligned_offset);
    9e83:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 9e8a <afs_fat32_detect+0x47a>
			9e85: R_X86_64_PC32	afs_debug_mode-0x5
    9e8a:	0f 84 48 02 00 00    	je     a0d8 <afs_fat32_detect+0x6c8>
    9e90:	31 c0                	xor    %eax,%eax
    9e92:	44 89 e9             	mov    %r13d,%ecx
    9e95:	ba 3e 01 00 00       	mov    $0x13e,%edx
    9e9a:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9e9d: R_X86_64_32S	.rodata+0x25f0
    9ea1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9ea4: R_X86_64_32S	.rodata.str1.8+0x1c68
    9ea8:	4f 8d 7c 25 00       	lea    0x0(%r13,%r12,1),%r15
    9ead:	e8 00 00 00 00       	callq  9eb2 <afs_fat32_detect+0x4a2>
			9eae: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:319
    afs_debug("FAT size in pages: %u ", page_number);
    9eb2:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 9eb9 <afs_fat32_detect+0x4a9>
			9eb4: R_X86_64_PC32	afs_debug_mode-0x5
    9eb9:	4d 89 fc             	mov    %r15,%r12
    9ebc:	0f 84 6a fe ff ff    	je     9d2c <afs_fat32_detect+0x31c>
    9ec2:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
    9ec5:	ba 3f 01 00 00       	mov    $0x13f,%edx
    9eca:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9ecd: R_X86_64_32S	.rodata+0x25f0
    9ed1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9ed4: R_X86_64_32S	.rodata.str1.8+0x1ca0
    9ed8:	31 c0                	xor    %eax,%eax
    9eda:	e8 00 00 00 00       	callq  9edf <afs_fat32_detect+0x4cf>
			9edb: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:322
    if (fat_aligned_offset + fat_aligned_size_bytes > 4096) {
    9edf:	49 81 ff 00 10 00 00 	cmp    $0x1000,%r15
    9ee6:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 9eec <afs_fat32_detect+0x4dc>
			9ee8: R_X86_64_PC32	afs_debug_mode-0x4
    9eec:	0f 86 f8 01 00 00    	jbe    a0ea <afs_fat32_detect+0x6da>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:323
        afs_debug("Read more data to map the FAT");
    9ef2:	85 c0                	test   %eax,%eax
    9ef4:	74 1a                	je     9f10 <afs_fat32_detect+0x500>
    9ef6:	ba 43 01 00 00       	mov    $0x143,%edx
    9efb:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9efe: R_X86_64_32S	.rodata+0x25f0
    9f02:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9f05: R_X86_64_32S	.rodata.str1.8+0x1cd0
    9f09:	31 c0                	xor    %eax,%eax
    9f0b:	e8 00 00 00 00       	callq  9f10 <afs_fat32_detect+0x500>
			9f0c: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:326
        fat_data = vmalloc(page_number * AFS_BLOCK_SIZE);
    9f10:	44 8b 7d c4          	mov    -0x3c(%rbp),%r15d
    9f14:	44 89 ff             	mov    %r15d,%edi
    9f17:	c1 e7 0c             	shl    $0xc,%edi
    9f1a:	e8 00 00 00 00       	callq  9f1f <afs_fat32_detect+0x50f>
			9f1b: R_X86_64_PC32	vmalloc-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:327
        for(i = 0; i < page_number; i++){
    9f1f:	45 85 ff             	test   %r15d,%r15d
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:326
        fat_data = vmalloc(page_number * AFS_BLOCK_SIZE);
    9f22:	49 89 c4             	mov    %rax,%r12
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:327
        for(i = 0; i < page_number; i++){
    9f25:	0f 84 81 00 00 00    	je     9fac <afs_fat32_detect+0x59c>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:328
            read_page(reader, device, (fat_aligned_offset / 4096) + i, 0, true);
    9f2b:	49 c1 fd 0c          	sar    $0xc,%r13
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:327
        for(i = 0; i < page_number; i++){
    9f2f:	45 31 ff             	xor    %r15d,%r15d
    9f32:	48 89 5d a8          	mov    %rbx,-0x58(%rbp)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:328
            read_page(reader, device, (fat_aligned_offset / 4096) + i, 0, true);
    9f36:	44 89 e8             	mov    %r13d,%eax
    9f39:	4c 89 f3             	mov    %r14,%rbx
    9f3c:	4d 8d ae 08 10 00 00 	lea    0x1008(%r14),%r13
    9f43:	45 89 fe             	mov    %r15d,%r14d
    9f46:	41 89 c7             	mov    %eax,%r15d
    9f49:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    9f4d:	43 8d 14 3e          	lea    (%r14,%r15,1),%edx
    9f51:	31 c9                	xor    %ecx,%ecx
    9f53:	48 89 df             	mov    %rbx,%rdi
    9f56:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    9f5c:	e8 00 00 00 00       	callq  9f61 <afs_fat32_detect+0x551>
			9f5d: R_X86_64_PC32	read_page-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:329
            memcpy(&fat_data[i * 4096], reader, 4096);
    9f61:	44 89 f1             	mov    %r14d,%ecx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    9f64:	48 8b 03             	mov    (%rbx),%rax
    9f67:	48 89 de             	mov    %rbx,%rsi
fat_map():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:329
    9f6a:	c1 e1 0c             	shl    $0xc,%ecx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:327
        for(i = 0; i < page_number; i++){
    9f6d:	41 83 c6 01          	add    $0x1,%r14d
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:329
            memcpy(&fat_data[i * 4096], reader, 4096);
    9f71:	48 63 c9             	movslq %ecx,%rcx
    9f74:	4c 01 e1             	add    %r12,%rcx
memcpy():
/usr/src/linux-headers-4.15.0-54-generic/./include/linux/string.h:344
    9f77:	48 89 01             	mov    %rax,(%rcx)
    9f7a:	48 8d 79 08          	lea    0x8(%rcx),%rdi
    9f7e:	49 8b 45 f0          	mov    -0x10(%r13),%rax
    9f82:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    9f86:	48 89 81 f8 0f 00 00 	mov    %rax,0xff8(%rcx)
    9f8d:	48 29 f9             	sub    %rdi,%rcx
    9f90:	48 29 ce             	sub    %rcx,%rsi
    9f93:	81 c1 00 10 00 00    	add    $0x1000,%ecx
    9f99:	c1 e9 03             	shr    $0x3,%ecx
    9f9c:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
fat_map():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:327
        for(i = 0; i < page_number; i++){
    9f9f:	44 3b 75 c4          	cmp    -0x3c(%rbp),%r14d
    9fa3:	75 a4                	jne    9f49 <afs_fat32_detect+0x539>
    9fa5:	49 89 de             	mov    %rbx,%r14
    9fa8:	48 8b 5d a8          	mov    -0x58(%rbp),%rbx
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:337
        afs_debug("FAT read successfully.");
    9fac:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 9fb2 <afs_fat32_detect+0x5a2>
			9fae: R_X86_64_PC32	afs_debug_mode-0x4
    9fb2:	85 f6                	test   %esi,%esi
    9fb4:	0f 84 82 fd ff ff    	je     9d3c <afs_fat32_detect+0x32c>
    9fba:	ba 51 01 00 00       	mov    $0x151,%edx
    9fbf:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9fc2: R_X86_64_32S	.rodata+0x25f0
    9fc6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9fc9: R_X86_64_32S	.rodata.str1.8+0x1d08
    9fcd:	31 c0                	xor    %eax,%eax
    9fcf:	e8 00 00 00 00       	callq  9fd4 <afs_fat32_detect+0x5c4>
			9fd0: R_X86_64_PC32	printk-0x4
    9fd4:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 9fda <afs_fat32_detect+0x5ca>
			9fd6: R_X86_64_PC32	afs_debug_mode-0x4
    9fda:	e9 0e 01 00 00       	jmpq   a0ed <afs_fat32_detect+0x6dd>
fat_read_fat32_ebpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:213
        vol->fs_info_sec = 0;
    9fdf:	45 31 c0             	xor    %r8d,%r8d
    9fe2:	66 44 89 43 68       	mov    %r8w,0x68(%rbx)
    9fe7:	e9 49 fc ff ff       	jmpq   9c35 <afs_fat32_detect+0x225>
afs_fat32_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:379
    afs_action(!IS_ERR(vol), ret = PTR_ERR(vol), vol_err, "could not allocate vol [%d]", ret);
    9fec:	89 c1                	mov    %eax,%ecx
    9fee:	ba 7b 01 00 00       	mov    $0x17b,%edx
    9ff3:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			9ff6: R_X86_64_32S	.rodata+0x2640
    9ffa:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9ffd: R_X86_64_32S	.rodata.str1.8+0x1948
    a001:	31 c0                	xor    %eax,%eax
    a003:	e8 00 00 00 00       	callq  a008 <afs_fat32_detect+0x5f8>
			a004: R_X86_64_PC32	printk-0x4
    a008:	e9 fb fa ff ff       	jmpq   9b08 <afs_fat32_detect+0xf8>
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:242
    afs_action(!IS_ERR(boot_sec), ret = PTR_ERR(boot_sec), out_invalid, "could not allocate boot_sec [%d]", ret);
    a00d:	89 c1                	mov    %eax,%ecx
    a00f:	ba f2 00 00 00       	mov    $0xf2,%edx
    a014:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a017: R_X86_64_32S	.rodata+0x2620
    a01b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a01e: R_X86_64_32S	.rodata.str1.8+0x1980
    a022:	31 c0                	xor    %eax,%eax
    a024:	e8 00 00 00 00       	callq  a029 <afs_fat32_detect+0x619>
			a025: R_X86_64_PC32	printk-0x4
afs_fat32_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:384
        afs_debug("Failed to read boot sector");
    a029:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # a030 <afs_fat32_detect+0x620>
			a02b: R_X86_64_PC32	afs_debug_mode-0x5
    a030:	0f 84 d2 fa ff ff    	je     9b08 <afs_fat32_detect+0xf8>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:384 (discriminator 1)
    a036:	ba 80 01 00 00       	mov    $0x180,%edx
    a03b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a03e: R_X86_64_32S	.rodata+0x2640
    a042:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a045: R_X86_64_32S	.rodata.str1.8+0x1b80
    a049:	31 c0                	xor    %eax,%eax
    a04b:	e8 00 00 00 00       	callq  a050 <afs_fat32_detect+0x640>
			a04c: R_X86_64_PC32	printk-0x4
    a050:	e9 b3 fa ff ff       	jmpq   9b08 <afs_fat32_detect+0xf8>
fat_read_dos_2_0_bpb():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:118
    afs_assert(is_power_of_2(vol->bytes_sector) && vol->sector_order >= 5 && vol->sector_order <= 12,
    a055:	0f b7 c9             	movzwl %cx,%ecx
    a058:	ba 77 00 00 00       	mov    $0x77,%edx
    a05d:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a060: R_X86_64_32S	.rodata+0x2600
    a064:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a067: R_X86_64_32S	.rodata.str1.8+0x19c0
    a06b:	31 c0                	xor    %eax,%eax
    a06d:	e8 00 00 00 00       	callq  a072 <afs_fat32_detect+0x662>
			a06e: R_X86_64_PC32	printk-0x4
    a072:	e9 81 fa ff ff       	jmpq   9af8 <afs_fat32_detect+0xe8>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:130
    afs_assert(vol->tables == 1 || vol->tables == 2, out_invalid, "incorrect number of tables");
    a077:	ba 82 00 00 00       	mov    $0x82,%edx
    a07c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a07f: R_X86_64_32S	.rodata+0x2600
    a083:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a086: R_X86_64_32S	.rodata.str1.8+0x1a38
    a08a:	31 c0                	xor    %eax,%eax
    a08c:	e8 00 00 00 00       	callq  a091 <afs_fat32_detect+0x681>
			a08d: R_X86_64_PC32	printk-0x4
    a091:	e9 62 fa ff ff       	jmpq   9af8 <afs_fat32_detect+0xe8>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:135
        afs_debug("FS is Fat32, not Fat16 or 12");
    a096:	ba 87 00 00 00       	mov    $0x87,%edx
    a09b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a09e: R_X86_64_32S	.rodata+0x2600
    a0a2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a0a5: R_X86_64_32S	.rodata.str1.8+0x1a70
    a0a9:	e8 00 00 00 00       	callq  a0ae <afs_fat32_detect+0x69e>
			a0aa: R_X86_64_PC32	printk-0x4
    a0ae:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # a0b4 <afs_fat32_detect+0x6a4>
			a0b0: R_X86_64_PC32	afs_debug_mode-0x4
    a0b4:	e9 b9 fa ff ff       	jmpq   9b72 <afs_fat32_detect+0x162>
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:253
        afs_debug("failed to read dos 2.0 bpb");
    a0b9:	ba fd 00 00 00       	mov    $0xfd,%edx
    a0be:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a0c1: R_X86_64_32S	.rodata+0x2620
    a0c5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a0c8: R_X86_64_32S	.rodata.str1.8+0x1aa8
    a0cc:	31 c0                	xor    %eax,%eax
    a0ce:	e8 00 00 00 00       	callq  a0d3 <afs_fat32_detect+0x6c3>
			a0cf: R_X86_64_PC32	printk-0x4
    a0d3:	e9 51 ff ff ff       	jmpq   a029 <afs_fat32_detect+0x619>
fat_map():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:322
    if (fat_aligned_offset + fat_aligned_size_bytes > 4096) {
    a0d8:	4d 01 ec             	add    %r13,%r12
    a0db:	31 c0                	xor    %eax,%eax
    a0dd:	49 81 fc 00 10 00 00 	cmp    $0x1000,%r12
    a0e4:	0f 87 26 fe ff ff    	ja     9f10 <afs_fat32_detect+0x500>
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:302
    uint8_t *fat_data = NULL;
    a0ea:	45 31 e4             	xor    %r12d,%r12d
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:343
    afs_debug("p: %p", p);
    a0ed:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:340
    vol->fat_map = fat_data;
    a0ef:	4c 89 23             	mov    %r12,(%rbx)
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:343
    afs_debug("p: %p", p);
    a0f2:	0f 84 47 fc ff ff    	je     9d3f <afs_fat32_detect+0x32f>
    a0f8:	4c 89 e1             	mov    %r12,%rcx
    a0fb:	ba 57 01 00 00       	mov    $0x157,%edx
    a100:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a103: R_X86_64_32S	.rodata+0x25f0
    a107:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a10a: R_X86_64_32S	.rodata.str1.8+0x1d38
    a10e:	31 c0                	xor    %eax,%eax
    a110:	e8 00 00 00 00       	callq  a115 <afs_fat32_detect+0x705>
			a111: R_X86_64_PC32	printk-0x4
    a115:	e9 25 fc ff ff       	jmpq   9d3f <afs_fat32_detect+0x32f>
read_boot_sector():
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:270
    afs_debug("Number of data sectors: %u", num_data_sectors);
    a11a:	31 c0                	xor    %eax,%eax
    a11c:	44 89 e9             	mov    %r13d,%ecx
    a11f:	ba 0e 01 00 00       	mov    $0x10e,%edx
    a124:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a127: R_X86_64_32S	.rodata+0x2620
    a12b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a12e: R_X86_64_32S	.rodata.str1.8+0x1b18
    a132:	e8 00 00 00 00       	callq  a137 <afs_fat32_detect+0x727>
			a133: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/modules/dm_afs_fat32.c:271
    afs_debug("Number of reserved: %u", vol->sec_fat);
    a137:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # a13e <afs_fat32_detect+0x72e>
			a139: R_X86_64_PC32	afs_debug_mode-0x5
    a13e:	0f 84 5e fb ff ff    	je     9ca2 <afs_fat32_detect+0x292>
    a144:	8b 4b 54             	mov    0x54(%rbx),%ecx
    a147:	ba 0f 01 00 00       	mov    $0x10f,%edx
    a14c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			a14f: R_X86_64_32S	.rodata+0x2620
    a153:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			a156: R_X86_64_32S	.rodata.str1.8+0x1b50
    a15a:	31 c0                	xor    %eax,%eax
    a15c:	e8 00 00 00 00       	callq  a161 <afs_fat32_detect+0x751>
			a15d: R_X86_64_PC32	printk-0x4
    a161:	e9 3c fb ff ff       	jmpq   9ca2 <afs_fat32_detect+0x292>
afs_fat32_detect():
    a166:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    a16d:	00 00 00 

000000000000a170 <afs_ext4_detect>:
afs_ext4_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_ext4.c:18
 * @fs      The file system information to be filled in.
 * @return  boolean.
 */
bool
afs_ext4_detect(const void *data, struct block_device *device, struct afs_passive_fs *fs)
{
    a170:	e8 00 00 00 00       	callq  a175 <afs_ext4_detect+0x5>
			a171: R_X86_64_PC32	__fentry__-0x4
    a175:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/modules/dm_afs_ext4.c:20
    return false;
}
    a176:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_ext4.c:18
{
    a178:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/modules/dm_afs_ext4.c:20
}
    a17b:	5d                   	pop    %rbp
    a17c:	c3                   	retq   
    a17d:	0f 1f 00             	nopl   (%rax)

000000000000a180 <afs_ntfs_detect>:
afs_ntfs_detect():
/home/austen/programming/dm-afs/src/modules/dm_afs_ntfs.c:18
 * @fs      The file system information to be filled in.
 * @return  boolean.
 */
bool
afs_ntfs_detect(const void *data, struct block_device *device, struct afs_passive_fs *fs)
{
    a180:	e8 00 00 00 00       	callq  a185 <afs_ntfs_detect+0x5>
			a181: R_X86_64_PC32	__fentry__-0x4
    a185:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/modules/dm_afs_ntfs.c:20
    return false;
}
    a186:	31 c0                	xor    %eax,%eax
/home/austen/programming/dm-afs/src/modules/dm_afs_ntfs.c:18
{
    a188:	48 89 e5             	mov    %rsp,%rbp
/home/austen/programming/dm-afs/src/modules/dm_afs_ntfs.c:20
}
    a18b:	5d                   	pop    %rbp
    a18c:	c3                   	retq   

Disassembly of section .init.text:

0000000000000000 <init_module>:
afs_init():
/home/austen/programming/dm-afs/src/dm_afs.c:712
{
   0:	e8 00 00 00 00       	callq  5 <init_module+0x5>
			1: R_X86_64_PC32	__fentry__-0x4
   5:	55                   	push   %rbp
/home/austen/programming/dm-afs/src/dm_afs.c:715
    ret = dm_register_target(&afs_target);
   6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			9: R_X86_64_32S	.data+0x20
/home/austen/programming/dm-afs/src/dm_afs.c:712
{
   d:	48 89 e5             	mov    %rsp,%rbp
  10:	53                   	push   %rbx
  11:	51                   	push   %rcx
/home/austen/programming/dm-afs/src/dm_afs.c:715
    ret = dm_register_target(&afs_target);
  12:	e8 00 00 00 00       	callq  17 <init_module+0x17>
			13: R_X86_64_PC32	dm_register_target-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:716
    afs_assert(ret >= 0, done, "registration failed [%d]", ret);
  17:	85 c0                	test   %eax,%eax
/home/austen/programming/dm-afs/src/dm_afs.c:715
    ret = dm_register_target(&afs_target);
  19:	89 c3                	mov    %eax,%ebx
/home/austen/programming/dm-afs/src/dm_afs.c:716
    afs_assert(ret >= 0, done, "registration failed [%d]", ret);
  1b:	79 1e                	jns    3b <init_module+0x3b>
/home/austen/programming/dm-afs/src/dm_afs.c:716 (discriminator 1)
  1d:	89 c1                	mov    %eax,%ecx
  1f:	ba cc 02 00 00       	mov    $0x2cc,%edx
  24:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			27: R_X86_64_32S	.rodata+0x58
  2b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			2e: R_X86_64_32S	.rodata.str1.8+0x8a0
  32:	31 c0                	xor    %eax,%eax
  34:	e8 00 00 00 00       	callq  39 <init_module+0x39>
			35: R_X86_64_PC32	printk-0x4
  39:	eb 23                	jmp    5e <init_module+0x5e>
/home/austen/programming/dm-afs/src/dm_afs.c:717
    afs_debug("registration successful");
  3b:	83 3d 00 00 00 00 00 	cmpl   $0x0,0x0(%rip)        # 42 <init_module+0x42>
			3d: R_X86_64_PC32	afs_debug_mode-0x5
  42:	74 1a                	je     5e <init_module+0x5e>
/home/austen/programming/dm-afs/src/dm_afs.c:717 (discriminator 1)
  44:	ba cd 02 00 00       	mov    $0x2cd,%edx
  49:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
			4c: R_X86_64_32S	.rodata+0x58
  50:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			53: R_X86_64_32S	.rodata.str1.8+0x8d8
  57:	31 c0                	xor    %eax,%eax
  59:	e8 00 00 00 00       	callq  5e <init_module+0x5e>
			5a: R_X86_64_PC32	printk-0x4
/home/austen/programming/dm-afs/src/dm_afs.c:721
}
  5e:	89 d8                	mov    %ebx,%eax
  60:	5a                   	pop    %rdx
  61:	5b                   	pop    %rbx
  62:	5d                   	pop    %rbp
  63:	c3                   	retq   
